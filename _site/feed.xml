<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-10-11T11:06:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">한헌종의 Git Blog</title><subtitle></subtitle><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><entry><title type="html">ACMG class 를 수치로 표현하는 방법 - bayesian score</title><link href="http://localhost:4000/biology/clinical%20genomics/tech/2020/10/11/ACMG_class-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0.html" rel="alternate" type="text/html" title="ACMG class 를 수치로 표현하는 방법 - bayesian score" /><published>2020-10-11T00:00:00+09:00</published><updated>2020-10-11T00:00:00+09:00</updated><id>http://localhost:4000/biology/clinical%20genomics/tech/2020/10/11/ACMG_class-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/biology/clinical%20genomics/tech/2020/10/11/ACMG_class-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0.html">&lt;p&gt;계산기&lt;/p&gt;
&lt;style&gt;
    table {
        border-collapse: collapse;
        margin: 10px 0px;
    }
    tr {
        padding: 0px 5px;
    }
    td {
        padding: 0px 5px;
        text-align: center;
    }
    input {
        text-align: center;
        border: none;
        font-size:24px;
    }
    input:focus {
        outline: none;
    }
    .rulebox {
        cursor:pointer;
    }
    .rulebox:hover {
        background-color: gray;
        opacity: 0.7;
    }
    .reset {
        cursor:pointer;
    }
    .reset:hover {
        background-color: gray;
        opacity: 0.7;
    }
    .rule_on{
        box-sizing: border-box;
        outline-offset: -2px;
        outline: solid 2px green;
    }
&lt;/style&gt;

&lt;!-- &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; --&gt;
&lt;!-- &lt;script src=&quot;https://code.jquery.com/jquery-3.5.0.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;h2&gt;ACMG class calculator&lt;/h2&gt;
&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h3&gt;
    click rules below:
&lt;table border=&quot;1&quot; style=&quot;width:800px;&quot;&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PVS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PVS1')&quot;&gt;PVS1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS1')&quot;&gt;PS1&lt;/td&gt;
        &lt;td id=&quot;PS2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS2')&quot;&gt;PS2&lt;/td&gt;
        &lt;td id=&quot;PS3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS3')&quot;&gt;PS3&lt;/td&gt;
        &lt;td id=&quot;PS4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS4')&quot;&gt;PS4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PM1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM1')&quot;&gt;PM1&lt;/td&gt;
        &lt;td id=&quot;PM2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM2')&quot;&gt;PM2&lt;/td&gt;
        &lt;td id=&quot;PM3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM3')&quot;&gt;PM3&lt;/td&gt;
        &lt;td id=&quot;PM4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM4')&quot;&gt;PM4&lt;/td&gt;
        &lt;td id=&quot;PM5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM5')&quot;&gt;PM5&lt;/td&gt;
        &lt;td id=&quot;PM6&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM6')&quot;&gt;PM6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PP1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP1')&quot;&gt;PP1&lt;/td&gt;
        &lt;td id=&quot;PP2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP2')&quot;&gt;PP2&lt;/td&gt;
        &lt;td id=&quot;PP3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP3')&quot;&gt;PP3&lt;/td&gt;
        &lt;td id=&quot;PP4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP4')&quot;&gt;PP4&lt;/td&gt;
        &lt;td id=&quot;PP5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP5')&quot;&gt;PP5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;BS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS1')&quot;&gt;BS1&lt;/td&gt;
        &lt;td id=&quot;BS2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS2')&quot;&gt;BS2&lt;/td&gt;
        &lt;td id=&quot;BS3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS3')&quot;&gt;BS3&lt;/td&gt;
        &lt;td id=&quot;BS4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS4')&quot;&gt;BS4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;BP1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP1')&quot;&gt;BP1&lt;/td&gt;
        &lt;td id=&quot;BP2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP2')&quot;&gt;BP2&lt;/td&gt;
        &lt;td id=&quot;BP3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP3')&quot;&gt;BP3&lt;/td&gt;
        &lt;td id=&quot;BP4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP4')&quot;&gt;BP4&lt;/td&gt;
        &lt;td id=&quot;BP5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP5')&quot;&gt;BP5&lt;/td&gt;
        &lt;td id=&quot;BP6&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP6')&quot;&gt;BP6&lt;/td&gt;
        &lt;td id=&quot;BP7&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP7')&quot;&gt;BP7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&quot;reset&quot; colspan=&quot;7&quot; onclick=&quot;reset()&quot;&gt;Reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Class&lt;/td&gt;
        &lt;td id=&quot;acmgclass&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt;
        &lt;td&gt;Score&lt;/td&gt;
        &lt;td id=&quot;score&quot; colspan=&quot;2&quot; style=&quot;width:150px;&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;&lt;/h3&gt;

&lt;script&gt;
    // test if js works
    document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello JavaScript!&quot;;
    
    function reset(){
        document.getElementById('acmgclass').innerHTML = &quot;&quot;;
        document.getElementById('score').innerHTML = &quot;&quot;;
        var rulebuttons = document.getElementsByClassName(&quot;rulebox&quot;);
        for(var i=0; i&lt;rulebuttons.length; i++){
            rulebuttons[i].classList.remove(&quot;rule_on&quot;);
        }
    }

    // on/off color
    function rule_button(rule_id) {
        var element = document.getElementById(rule_id);
        element.classList.toggle(&quot;rule_on&quot;);
        update_res();
    }

    function update_res(){
        var cnt = 0;
        var pvs = 0;
        var ps = 0;
        var pm = 0;
        var pp = 0;
        var bs = 0;
        var bp = 0;
        var rulebuttons = document.getElementsByClassName(&quot;rulebox&quot;);
        for(var i=0; i&lt;rulebuttons.length; i++){
            var cond = rulebuttons[i].classList.contains(&quot;rule_on&quot;)
            if(cond){
                var rule_str = rulebuttons[i].id.substring(0,2);
                if(rule_str == &quot;PV&quot;){pvs += 1;}
                else if(rule_str == &quot;PS&quot;){ps += 1;}
                else if(rule_str == &quot;PM&quot;){pm += 1;}
                else if(rule_str == &quot;PP&quot;){pp += 1;}
                else if(rule_str == &quot;BS&quot;){bs += 1;}
                else if(rule_str == &quot;BP&quot;){bp += 1;}
                cnt = cnt + 1;
            }
        }
        // update result
        var combined = combine_rule(pvs, ps, pm, pp, bs, bp);
        document.getElementById('acmgclass').innerHTML = combined;
        var b_score = cal_bayesian(pvs, ps, pm, pp, bs, bp);
        document.getElementById('score').innerHTML = b_score;
    }

    function combine_rule(pvs, ps, pm, pp, bs, bp){
        var class_res = &quot;VUS&quot;;
        if(pvs &gt;= 1){
            if(pvs &gt;= 2 || ps &gt;= 1 || pm &gt;= 2 || (pm == 1 &amp;&amp; pp == 1) || pp &gt;= 2){
                class_res = &quot;Pathogenic&quot;
            }else if(pvs == 1 &amp;&amp; pm &gt;= 1){
                class_res = &quot;Likely pathogenic&quot;
            }
        }else if(ps &gt;= 2){
                class_res = &quot;Pathogenic&quot;
        }else if(ps == 1){
            if(pm &gt;= 3 || (pm == 2 &amp;&amp; pp &gt;= 2) || pp &gt;= 4){
                class_res = &quot;Pathogenic&quot;
            }else if(pm &gt;= 1 || pp &gt;= 2){
                class_res = &quot;Likely pathogenic&quot;
            }
        }else if(pm &gt;= 3 || (pm == 2 &amp;&amp; pp &gt;= 2) || pp &gt;= 4){
            class_res = &quot;Likely pathogenic&quot;
        }
        // if the result is not &quot;VUS&quot; then break. pathogenic first.
        if(class_res !== &quot;VUS&quot;){
            return class_res
        }
        if(bs &gt;= 2){
            class_res = &quot;Benign&quot;;
        }else if((bs == 1 &amp;&amp; bp == 1) || bp &gt;= 2){
            class_res = &quot;Likely benign&quot;;
        }
        return class_res
    }

    function cal_bayesian(pvs, ps, pm, pp, bs, bp){
        var prior = 0.1;
        var odd_base = 350;
        var oddsPath = odd_base ** (pvs + ps/2 + pm/4 + pp/8 - bs/2 - bp/8)
        var res = oddsPath * prior / ((oddsPath - 1) * prior + 1)
        res = Number.parseFloat(res).toPrecision(5);
        return res
    }
&lt;/script&gt;</content><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><category term="biology" /><category term="clinical genomics" /><category term="tech" /><summary type="html">계산기 ACMG class calculator click rules below: PVS1 PS1 PS2 PS3 PS4 PM1 PM2 PM3 PM4 PM5 PM6 PP1 PP2 PP3 PP4 PP5 BS1 BS2 BS3 BS4 BP1 BP2 BP3 BP4 BP5 BP6 BP7 Reset Class Score</summary></entry><entry><title type="html">ACMG guideline 이란 무엇일까</title><link href="http://localhost:4000/biology/clinical%20genomics/2020/09/27/ACMG-guideline-2015.html" rel="alternate" type="text/html" title="ACMG guideline 이란 무엇일까" /><published>2020-09-27T00:00:00+09:00</published><updated>2020-09-27T00:00:00+09:00</updated><id>http://localhost:4000/biology/clinical%20genomics/2020/09/27/ACMG-guideline-2015</id><content type="html" xml:base="http://localhost:4000/biology/clinical%20genomics/2020/09/27/ACMG-guideline-2015.html">&lt;h3 id=&quot;acmg-guideline-이란-무엇일까&quot;&gt;ACMG guideline 이란 무엇일까&lt;/h3&gt;
&lt;p&gt;안녕하세요. 한헌종입니다.&lt;br /&gt;
오늘은 임상유전학 분야에서 거의 교과서처럼 쓰이고 있는 ACMG guideline에 대해 알아보려 합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;환자의 유전 질환을 진단하려면 어디서부터 시작해야 할까요?&lt;br /&gt;
먼저 환자의 샘플을 채취하고, 시퀀싱 실험을 통해 환자의 DNA 염기서열을 알아내야겠죠.&lt;br /&gt;
그 다음 Reference genome 과 비교해 환자에게 어떤 돌연변이 (variants) 가 나타났는지 알아내야 합니다.&lt;br /&gt;
만약 환자에게서 기존에 알려진 유전병의 원인이 되는 변이가 발견된다면, 그 환자의 질병과 원인에 대해 알아낼 수 있겠죠.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/figure1.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;환자에게서 변이를 찾는 과정&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;문제는, 한명의 환자에게서 발견되는 돌연변이가 매우 많다는 것입니다.&lt;br /&gt;
Whole exome sequencing 실험을 통해 얻은 데이터를 살펴보면, 한 환자마다 약 7만~8만 개의 변이가 나타난다는 사실을 알 수 있습니다.&lt;br /&gt;
이렇게 많은 변이들 중에서 단 몇 개의 변이만 환자의 질병을 일으킵니다.&lt;br /&gt;
그럼 나머지 변이들은 뭘까요? 대부분의 변이는 질환과 상관없거나, 개인마다 그 위험성이 다르기 때문에 질병에 영향을 주지 않는 경우입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이렇게 많은 변이들 중 ‘실제로’ 질병을 일으키는 변이를 어떻게 찾아낼 수 있을까요?&lt;br /&gt;
그 방법을 고안하기 위해 각지에서 전문가들이 모였습니다:&lt;br /&gt;
American College of Medical Genetics and Genomics,&lt;br /&gt;
Association for Molecular Pathology,&lt;br /&gt;
College of American Pathologist 에서 말이죠.&lt;br /&gt;
이렇게 모인 전문가들이 고안해낸 지침서가 바로 ACMG/AMP guideline 입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/ACMG_main.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;2015년에 출판된 ACMG/AMP guidelines 논문. 보통 줄여서 ACMG guideline 이라고 합니다.&lt;br /&gt;DOI: 10.1038/gim.2015.30&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;그래서-acmg-guideline-이-뭐라구요&quot;&gt;그래서 ACMG guideline 이 뭐라구요?&lt;/h3&gt;
&lt;p&gt;한 마디로 변이의 ‘병원성’ (pathogenicity) 를 판단하는 기준들 입니다.&lt;br /&gt;
물론 위의 논문을 읽어보시면, 변이 판별 외에도 사용되는 용어, 명명법, 사용하는 데이터베이스에 대한 설명, 변이를 보고할 때의 고려사항 등 세부적인 내용이 많이 포함되어 있습니다.&lt;br /&gt;
(이 부분들 역시 그리 간단하지가 않습니다..)&lt;br /&gt;
오늘은 그 내용 중에서도, 변이를 판단하는 기준에 집중해볼까요?&lt;/p&gt;

&lt;p&gt;변이에 대한 판별은 두 단계로 나누어집니다.&lt;br /&gt;
&lt;strong&gt;첫 번째 단계는 Evidence 를 할당하는 과정,&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;두 번째 단계는 Pathogenicity 를 구분하는 과정입니다.&lt;/strong&gt;&lt;br /&gt;
이 과정을 거치게 되면, 이중 어떤 변이가 정말로 병을 일으킬 만한지 알 수 있게 됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure2.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;첫 번째 단계를 먼저 살펴볼까요?&lt;br /&gt;
어떤 변이에 대해 evidence 를 할당한다는 것은, 다시 말해서 병원성에 대한 증거를 붙여놓는 것입니다.&lt;br /&gt;
이를 위해서 ACMG guideline 에서는 &lt;strong&gt;28 개의 ‘규칙 (rules)’&lt;/strong&gt; 들을 정해놓았습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure3.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 규칙들은 크게 병원성/비병원성 (Pathogenic/benign) 으로 나뉩니다.&lt;br /&gt;
또한 그 경중에 따라 크게 4가지로 나뉩니다. (Very strong/Strong/Moderate/Supporting)&lt;br /&gt;
예를 들어서, PS3 rule 은 특정 변이가 Pathogenic 하다는 것에 관련된 rule 중 하나이며, 그 강도가 Strong 으로 매우 강력합니다.&lt;br /&gt;
BP7 rule 은 특정 변이가 Benign 하다는 것에 관련된 규칙이고, 그 강도가 Supporting으로 약합니다.&lt;br /&gt;
이 규칙들에 따라서 특정 변이에 대해서 evidence 들을 할당하는 과정이 첫 번째 단계라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 대체 그 rule 이 뭐죠?&lt;br /&gt;
아래 그림에 28개 rule에 대한 설명 중 일부를 가져와봤습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure4.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예를 들어, PS3 evidence 다음과 같은 경우에 할당한다고 하네요:&lt;br /&gt;
PS3: Well-established in vitro or in vivo functional studies supportive of a damaging effect on the gene or gene &lt;br /&gt;
product&lt;br /&gt;
즉, in vitro/in vivo 실험을 통해 특정 변이가 유전자에 손상을 줄 수 있다는 연구가 제시된 경우, 그 변이에 PS3를 할당할 수 있습니다.&lt;br /&gt;
한 변이가 여러 규칙에 해당된다면, 여러 evidence 들을 할당할 수도 있는거죠.&lt;br /&gt;
이렇게 각 규칙에 따라서 변이에 여러가지 evidence 들을 적용하는 과정을 거치면, 1단계가 완성됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;두 번째 단계를 살펴볼까요?&lt;br /&gt;
변이에 대해 evidence들을 할당하고 나면, 어떤 변이들은 Pathogenic evidence를 매우 많이 가지고 있을 수도 있습니다.&lt;br /&gt;
혹은 몇몇 강력한 evidence를 가지고 있는 변이도 있겠죠.&lt;br /&gt;
이 evidence를 종합적으로 판단해서 변이를 다섯 등급 중 하나로 구분합니다:&lt;br /&gt;
Pathogenic, Likely pathogenic, Uncertain signifiacne, Likely benign, Benign&lt;/p&gt;

&lt;p&gt;사실 각 evidence를 정량적으로 판단할 수는 없지만, ACMG guideline에서 방법을 제시하고 있습니다.&lt;br /&gt;
예를 들어 Pathogenic strong evidence 를 두 개 가지고 있는 변이는 마침내 ‘Pathogenic’ 변이로 구분될 수 있습니다.&lt;br /&gt;
이렇게 evidence 들의 조합으로 변이가 정말 pathogenic 인지 확인하는 과정이 바로 두 번째 단계입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/figure5.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;논문에서 발췌한 Pathogenicity class 구분표 입니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;이렇게 ACMG guidelines 의 일부분을 살펴보았습니다.&lt;br /&gt;
물론 이렇게 변이의 pathogenicity를 구분한 뒤에도, 아직도 매우 많은 변이가 Pathogenic 하다고 나올 수 있습니다.&lt;br /&gt;
또한, Pathogenic 으로 구분된 변이라고 무조건 질병을 일으킨다는 보장이 없으며, Uncertain 변이로 구분되었다고 해서 질병과 상관없다고 단정지을 수도 없습니다.&lt;br /&gt;
그리고 실제 진단까지 가려면 이 뿐만 아니라 환자의 증상이나 가족력 등 더 자세한 정보가 필요할 것입니다.&lt;br /&gt;
그럼에도 불구하고, 적어도 선택해야 할 변이의 수를 줄여줄 뿐만 아니라 그 변이들에 대한 설명을 제시해준다는 점에서 ACMG guideline은 큰 의미를 가진다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;오늘도 매우 어려운 내용의 겉핥기를 해보았습니다.&lt;br /&gt;
ACMG guidelines 는 2015년에 나온 이후로 계속 발전하고 있습니다.&lt;br /&gt;
향후 이런 내용에 대해서도 나중에 자세히 다뤄볼까 합니다.&lt;/p&gt;

&lt;p&gt;그럼 여러분, 다음 글에서 만나요!&lt;/p&gt;</content><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><category term="biology" /><category term="clinical genomics" /><summary type="html">ACMG guideline 이란 무엇일까 안녕하세요. 한헌종입니다. 오늘은 임상유전학 분야에서 거의 교과서처럼 쓰이고 있는 ACMG guideline에 대해 알아보려 합니다.</summary></entry><entry><title type="html">파일 형식을 알아보자! 두번째 (VCF, BED, GTF, GFF)</title><link href="http://localhost:4000/biology/tech/2020/09/13/bioinformatics-formats2.html" rel="alternate" type="text/html" title="파일 형식을 알아보자! 두번째 (VCF, BED, GTF, GFF)" /><published>2020-09-13T00:00:00+09:00</published><updated>2020-09-13T00:00:00+09:00</updated><id>http://localhost:4000/biology/tech/2020/09/13/bioinformatics-formats2</id><content type="html" xml:base="http://localhost:4000/biology/tech/2020/09/13/bioinformatics-formats2.html">&lt;h3 id=&quot;생명정보학-분석에서-자주-만나는-파일-형식을-알아봅시다-2&quot;&gt;생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다 (2)&lt;/h3&gt;

&lt;p&gt;안녕하세요, 한헌종입니다.&lt;br /&gt;
오늘은 저번 포스팅에 이어서 생명정보학 분야에서 자주 만나게 되는 파일 형식을 알아보려 합니다.&lt;br /&gt;
오늘은 VCF, BED, GTF, GFF를 알아봅시다.&lt;/p&gt;

&lt;h3 id=&quot;vcf-variant-call-format&quot;&gt;VCF (Variant Call Format)&lt;/h3&gt;

&lt;p&gt;VCF 파일은 Variants 즉 변이 정보를 기록할 때 사용되는 형식입니다.&lt;br /&gt;
Genome 상에서 어느 위치에 원래는 어떤 서열인데 어떤 유전변이가 일어난건지, genotype은 무엇인지에 대한 정보를 가지고 있죠.&lt;br /&gt;
이 VCF 파일 형식은 1000 genome project와 같이 대규모 시퀀싱 프로젝트가 진행되면서 만들어졌다고 해요.&lt;br /&gt;
VCF 파일은 아래와 같이 생겼습니다. 크게 두 부분으로 나뉘어져 있죠. header 와 body 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##fileformat=VCFv4.3
##fileDate=20090805
##source=myImputationProgramV3.1
##reference=file:///seq/references/1000GenomesPilot-NCBI36.fasta
##contig=&amp;lt;ID=20,length=62435964,assembly=B36,md5=f126cdf8a6e0c7f379d618ff66beb2da,species=&quot;Homo sapiens&quot;,taxonomy=x&amp;gt;
##phasing=partial
##INFO=&amp;lt;ID=NS,Number=1,Type=Integer,Description=&quot;Number of Samples With Data&quot;&amp;gt;
##INFO=&amp;lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&amp;gt;
##INFO=&amp;lt;ID=AF,Number=A,Type=Float,Description=&quot;Allele Frequency&quot;&amp;gt;
##INFO=&amp;lt;ID=AA,Number=1,Type=String,Description=&quot;Ancestral Allele&quot;&amp;gt;
##INFO=&amp;lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&amp;gt;
##INFO=&amp;lt;ID=H2,Number=0,Type=Flag,Description=&quot;HapMap2 membership&quot;&amp;gt;
##FILTER=&amp;lt;ID=q10,Description=&quot;Quality below 10&quot;&amp;gt;
##FILTER=&amp;lt;ID=s50,Description=&quot;Less than 50% of samples have data&quot;&amp;gt;
##FORMAT=&amp;lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&amp;gt;
##FORMAT=&amp;lt;ID=GQ,Number=1,Type=Integer,Description=&quot;Genotype Quality&quot;&amp;gt;
##FORMAT=&amp;lt;ID=DP,Number=1,Type=Integer,Description=&quot;Read Depth&quot;&amp;gt;
##FORMAT=&amp;lt;ID=HQ,Number=2,Type=Integer,Description=&quot;Haplotype Quality&quot;&amp;gt;
#CHROM POS      ID         REF   ALT    QUAL  FILTER   INFO                             FORMAT       NA00001         NA00002          NA00003
20     14370    rs6054257  G     A      29    PASS    NS=3;DP=14;AF=0.5;DB;H2           GT:GQ:DP:HQ  0|0:48:1:51,51  1|0:48:8:51,51   1/1:43:5:.,.
20     17330    .          T     A      3     q10     NS=3;DP=11;AF=0.017               GT:GQ:DP:HQ  0|0:49:3:58,50  0|1:3:5:65,3     0/0:41:3
20     1110696  rs6040355  A     G,T    67    PASS    NS=2;DP=10;AF=0.333,0.667;AA=T;DB GT:GQ:DP:HQ  1|2:21:6:23,27  2|1:2:0:18,2     2/2:35:4
20     1230237  .          T     .      47    PASS    NS=3;DP=13;AA=T                   GT:GQ:DP:HQ  0|0:54:7:56,60  0|0:48:4:51,51   0/0:61:2
20     1234567  microsat1  GTC   G,GTCT 50    PASS    NS=3;DP=9;AA=G                    GT:GQ:DP     0/1:35:4        0/2:17:2         1/1:40:3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;VCF 파일의 예시. header 20줄과 body 6줄로 이루어져 있군요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;header&lt;/strong&gt; 는 샵 두개 (##)으로 시작하는 VCF의 가장 윗부분을 말합니다.&lt;br /&gt;
header 부분은 VCF 파일의 전반적인 정보를 가지고 있습니다.&lt;br /&gt;
파일 형식, 날짜, 그리고 body의 INFO/FORMAT column에서 사용되는 단어들에 대한 설명이 포함되어 있죠.&lt;br /&gt;
예를 들어 body 의 INFO column에 있는 정보 중 NS=3 이란 정보가 있는데, header의 설명을 보면 INFO=&amp;lt;ID=NS, … Description=”Number of Samples With Data”&amp;gt; 라고 되어있으니 NS가 샘플 수라는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt; 부분은 샵 하나 (#)로 시작하는 컬럼 제목부분과 실제 데이터부분으로 되어있습니다.&lt;br /&gt;
body에는 꼭 들어가야 하는 8개의 컬럼이 있는데요, 순서대로 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;#CHROM: 염색체 정보&lt;/li&gt;
  &lt;li&gt;POS: position. 해당 염색체에서 변이가 일어난 염기서열 위치를 말합니다.&lt;/li&gt;
  &lt;li&gt;ID: 변이를 나타내는 고유 ID가 있는 경우 표시합니다. 보통 dbSNP (rs로 시작하는) ID를 적거나 ‘.’ 으로만 적어둡니다.&lt;/li&gt;
  &lt;li&gt;REF: reference genome 상에서의 원래 염기서열&lt;/li&gt;
  &lt;li&gt;ALT: 돌연변이로 바뀐 서열&lt;/li&gt;
  &lt;li&gt;QUAL: 해당 variant를 찾아낸 것에 대한 quality score&lt;/li&gt;
  &lt;li&gt;FILTER: 해당 변이가 특정 필터기준을 통과했는지에 대한 표시 (flag)&lt;/li&gt;
  &lt;li&gt;INFO: 각 변이에 대한 자세한 설명이 적힌 컬럼.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 컬럼들은 모두 탭 (tab)으로 나뉘어져 있죠.&lt;br /&gt;
이 외의 컬럼은 없어도 VCF파일이라 할 수 있습니다. 그러나 보통 FORMAT 컬럼, sample 컬럼 하나씩이 더 추가되어 있는 경우가 많습니다.&lt;br /&gt;
보통 한 개의 샘플 정보가 적혀있지만, 가끔 2개 이상의 샘플 정보가 있는 경우 그만큼 컬럼 수도 늘어나게 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;FORMAT: 각 샘플에서 변이 정보를 나타내는 필드 종류. colon (:) 으로 나뉘어져 있습니다. 보통 genotype (GT), AD (allele depth), DP (Total read depth) 등이 적혀 있습니다.&lt;/li&gt;
  &lt;li&gt;sample (실제 샘플 이름이 적힘): FORMAT 에 적힌 필드들의 각 샘플에서의 수치. colon (:)으로 나뉘어져 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;bed-browser-extensible-data&quot;&gt;BED (Browser Extensible Data)&lt;/h3&gt;
&lt;p&gt;BED 파일 형식은 Human Genome Project 가 진행되면서 만들어진 형식이라고 해요.&lt;br /&gt;
bed 파일은 염색체의 특정 ‘영역’에 대한 정보 (annotation) 를 기록하고 사용하기 위해 만들어 졌습니다.&lt;br /&gt;
예를 들어, ChIP-seq 실험 결과를 통해 얻은 protein binding region 을 표시하고자 할 때 쓰일 수 있어요.&lt;br /&gt;
탭 (tab)으로 나뉘어져 있고 염기서열과 같이 큰 정보가 없어서 파싱하기 용이한 형식으로 널리 쓰이게 되었죠.&lt;/p&gt;

&lt;p&gt;bed 파일은 최소 3개의 컬럼만 있으면 되는데, 이에 컬럼이 추가되어서 총 12개까지 늘어날 수 있습니다.&lt;br /&gt;
용도에 따라 필요한 컬럼 수가 다른거죠.&lt;br /&gt;
그래서 컬럼 수에 따라서 확장자 이름을 bed3, bed4, bed12 등으로 나타내기도 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;track name=pairedReads description=&quot;Clone Paired Reads&quot; useScore=1
chr22 1000 5000 cloneA 960 + 1000 5000 0 2 567,488, 0,3512
chr22 2000 6000 cloneB 900 - 2000 6000 0 2 433,399, 0,3601&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;일반적인 bed 파일의 예시.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;bed 파일도 header 와 body 로 나뉘어져 있습니다.&lt;br /&gt;
&lt;strong&gt;header&lt;/strong&gt; 는 기본적으로 track name, description 등이 적혀져 있는 한 줄입니다.&lt;br /&gt;
그런데 이 bed 파일이 UCSC genome browser 등에서 쓰이는 경우, header 에는 추가적인 정보가 들어가기도 합니다.&lt;br /&gt;
추가적인 정보는 browser에서 이 파일을 사용했을 때, 어느 위치를 보여줄 것인지, 어떤 포맷으로 보여줄지 등 다양합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;browser position chr7:127471196-127495720
browser hide all
track name=&quot;ItemRGBDemo&quot; description=&quot;Item RGB demonstration&quot; visibility=2 itemRgb=&quot;On&quot;
chr7    127471196  127472363  Pos1  0  +  127471196  127472363  255,0,0
chr7    127472363  127473530  Pos2  0  +  127472363  127473530  255,0,0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;추가 정보가 header 에 들어있는 bed 파일의 예시.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt; 부분은 탭으로 나뉘어져 있습니다.&lt;br /&gt;
컬럼 수는 3개짜리 파일도 있고, 6개, 9개 등 다양합니다.&lt;br /&gt;
각 컬럼에는 다음과 같은 정보들이 포함되어 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;chrom: 염색체 정보&lt;/li&gt;
  &lt;li&gt;chromStart: 해당 영역의 시작서열 위치&lt;/li&gt;
  &lt;li&gt;chromEnd: 해당 영역의 끝서열 위치&lt;/li&gt;
  &lt;li&gt;name: 영역의 이름&lt;/li&gt;
  &lt;li&gt;score: 영역의 점수 0~1000&lt;/li&gt;
  &lt;li&gt;strand: DNA strand (+/-)&lt;/li&gt;
  &lt;li&gt;thickstart: 해당 영역이 시각화 될 때 두껍게 보여질 부분의 시작위치&lt;/li&gt;
  &lt;li&gt;thickend: 해당 영역이 시각화 될 때 두껍게 보여질 부분의 끝위치&lt;/li&gt;
  &lt;li&gt;itemRgb: 해당 영역이 시각화 될 때 나타날 색깔&lt;/li&gt;
  &lt;li&gt;blockCount: 해당 영역의 Exon 과 같은 block의 수&lt;/li&gt;
  &lt;li&gt;blockSizes: comma (,) 로 나뉘어진 블록들의 크기&lt;/li&gt;
  &lt;li&gt;blockStarts: comma (,) 로 나뉘어진 start 위치 목록. 이는 두번째 컬럼인 chromStart로 부터의 상대적 위치 (zero-base) 입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gff-general-feature-format&quot;&gt;GFF (General Feature Format)&lt;/h3&gt;
&lt;p&gt;GFF 는 DNA/RNA/protein 서열을 설명할 때 사용되는 파일 형식입니다.&lt;br /&gt;
한 줄에는 한 영역 (feature) 에 대한 설명이 9개 컬럼에 걸쳐서 적혀있습니다.&lt;br /&gt;
아래는 그 예시입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chr22	TeleGene	enhancer	10000000	10001000	500	+	.	touch1
chr22	TeleGene	promoter	10010000	10010100	900	+	.	touch1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;각 컬럼이 어떤건지 살펴볼까요?&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sequence: 해당 서열의 이름&lt;/li&gt;
  &lt;li&gt;source: 해당 feature 이 어디서 왔는지에 대한 설명 (feature를 작성한 프로그램이나 연구기관 등)&lt;/li&gt;
  &lt;li&gt;feature: 해당 영역의 이름 (gene 혹은 exon 등)&lt;/li&gt;
  &lt;li&gt;start: 해당 영역의 시작위치 (one-base)&lt;/li&gt;
  &lt;li&gt;end: 해당 영역의 끝 위치 (one-base)&lt;/li&gt;
  &lt;li&gt;score: 영역에 대한 신뢰도 점수&lt;/li&gt;
  &lt;li&gt;strand: ‘+’ (forward) 혹은 ‘-‘ (reverse) 가닥&lt;/li&gt;
  &lt;li&gt;frame: 0,1,2 혹은 dot(.). 0은 해당 feature 의 첫 번째 서열이 reference 의 codon start 서열이라는 뜻이며, 1은 해당 feature의 두 번째 서열이 reference 의 codon start 서열이라는 뜻입니다. 만약 feature 가 exon 이 아닌 경우에는 ‘.’ 으로 되어있어요.&lt;/li&gt;
  &lt;li&gt;group: feature 가 속한 group. 같은 group 인 line 들은 같은 group 값을 가집니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 중 frame 컬럼은 phase라고도 불리는데, &lt;a href=&quot;https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md&quot;&gt;Sequence Ontology (SO) 문서&lt;/a&gt; 에 더 자세히 설명되어 있으니 한번 살펴보세요.&lt;/p&gt;

&lt;h3 id=&quot;gtf-gene-transfer-format&quot;&gt;GTF (Gene Transfer Format)&lt;/h3&gt;
&lt;p&gt;GTF 파일 형식은 GFF 와 매우 유사한 형식이에요.&lt;br /&gt;
실제로 GFF - GTF 변환도 가능하죠.&lt;br /&gt;
GTF 형식의 처음 8개 컬럼은 GFF 와 동일합니다.&lt;/p&gt;

&lt;p&gt;그러나 차이점이 있습니다.&lt;br /&gt;
GTF 파일에는 gene, exon 등의 feature 말고도 5’UTR, 3’UTR, inter, intron 등이 포함되어 있기도 합니다.&lt;br /&gt;
또한, GFF 형식의 9번째 컬럼 ‘group’이 semicolon으로 나뉜 ‘attribute’ 컬럼으로 바뀝니다.&lt;br /&gt;
각 attribute 는 해당 feature에 대한 설명이 type-value 짝을 이루어서 적혀 있어요.&lt;/p&gt;

&lt;p&gt;9번째 컬럼만 보면 다음과 같이 되어 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gene_id &quot;ENSG00000223972&quot;; gene_name &quot;DDX11L1&quot;; gene_source &quot;havana&quot;; gene_biotype &quot;transcribed_unprocessed_pseudogene&quot;; 
gene_id &quot;ENSG00000223972&quot;; transcript_id &quot;ENST00000456328&quot;; gene_name &quot;DDX11L1&quot;; gene_sourc e &quot;havana&quot;; gene_biotype &quot;transcribed_unprocessed_pseudogene&quot;; transcript_name &quot;DDX11L1-002&quot;; transcript_source &quot;havana&quot;;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GTF 에는 해당 feature에 대해 더 자세한 설명이 적혀있는 걸 알 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘 설명드린 파일들은 제가 자주 사용해오던 파일 형식들입니다.&lt;br /&gt;
그런데도 각 컬럼에 대한 세세한 설명까지 알고 있지는 못했던 것 같아요.&lt;br /&gt;
이번 기회에 공부해볼 수 있어서 좋았던 것 같습니다.&lt;/p&gt;

&lt;p&gt;다음에는 또 다른 내용으로 포스팅 해보겠습니다.&lt;br /&gt;
그럼 다음에 만나요!&lt;/p&gt;</content><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><category term="biology" /><category term="tech" /><summary type="html">생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다 (2)</summary></entry><entry><title type="html">파일 형식을 알아보자! (FASTA, FASTQ, BAM, SAM)</title><link href="http://localhost:4000/biology/tech/2020/08/26/Bioinformatics-fileformats.html" rel="alternate" type="text/html" title="파일 형식을 알아보자! (FASTA, FASTQ, BAM, SAM)" /><published>2020-08-26T00:00:00+09:00</published><updated>2020-08-26T00:00:00+09:00</updated><id>http://localhost:4000/biology/tech/2020/08/26/Bioinformatics-fileformats</id><content type="html" xml:base="http://localhost:4000/biology/tech/2020/08/26/Bioinformatics-fileformats.html">&lt;h3 id=&quot;생명정보학-분석에서-자주-만나는-파일-형식을-알아봅시다&quot;&gt;생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다&lt;/h3&gt;

&lt;p&gt;안녕하세요, 한헌종입니다.&lt;br /&gt;
오늘은 생명정보학 분야에서 자주 만나게 되는 파일 형식이 어떤 게 있는지 알아봅시다.&lt;/p&gt;

&lt;p&gt;생명정보학을 공부하면서 가장 많이 만나게 되는 파일 형식은 사실 tsv, csv일 것입니다.&lt;br /&gt;
이 형식들은 여러분이 잘 알고 계시는 ‘표’ 형태의 정보를 텍스트 파일로 나타낸 것입니다.&lt;br /&gt;
tsv 는 tab-separated values, 즉 ‘탭’으로 데이터를 나누어 적어놓은 파일이구요,&lt;br /&gt;
csv 는 comma-separated values, 즉 ‘쉼표’로 데이터를 나누어 적어놓은 파일입니다.&lt;br /&gt;
어려울 것 없이, 그냥 표라고 생각하시면 됩니다. tsv,csv 파일을 엑셀로 열면 아주 이쁘게 표로 표현된답니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;csv 형태의 데이터는 표와 같습니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;세상의 모든 데이터가 tsv/csv 처럼 단순한 형태로 있으면 참 편할텐데, 그렇지가 않습니다.&lt;br /&gt;
생명정보학을 공부하시다 보면 아래에 소개드릴 특별한 파일 형식들을 많이 만나보시게 될 겁니다.&lt;br /&gt;
(사실 생각나는 대로 적어본 거라, 서로 연관성은 많이 없습니다.)&lt;br /&gt;
이 형식들에 익숙해지시면 데이터를 이해하고 분석하는 게 한결 수월해지실 겁니다.&lt;/p&gt;

&lt;p&gt;그럼 한 번 알아볼까요?&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;fasta&quot;&gt;FASTA&lt;/h3&gt;

&lt;p&gt;FASTA 파일은 특정 분자의 서열을 나타내는 데에 사용됩니다.&lt;br /&gt;
주로 Genome 의 각 chromosome 마다의 서열을 저장하는 데 쓰이죠.&lt;br /&gt;
혹은 gene/transcript/protein 각각의 염기서열 및 아미노산 서열을 저장할 때 사용되는 형식이에요.&lt;/p&gt;

&lt;p&gt;FASTA 파일은 두 형태가 반복되는 형식입니다.&lt;br /&gt;
첫 부분은 그 아래에 나올 서열의 이름/ID 입니다. 항상 &amp;gt; (꺽쇠) 글자로 시작하죠.&lt;br /&gt;
다음에는 그 이름에 해당하는 서열이 나오게 됩니다.&lt;br /&gt;
보통 그 서열은 굉장히 깁니다. 염색체는 말할 것도 없고, 특정 유전자나 단백질도 몇백-몇만 글자로 표현해야 하죠.&lt;br /&gt;
그래서 이를 한 줄로 나타내지 않고, 보통 60글자씩 나눠서 여러 줄에 걸쳐 표현합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;FASTA 파일의 예시. 이름-서열-이름-서열 이 반복되네요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* 주의: FASTA 파일은 보통 엄청나게 크기 때문에, 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;fastq&quot;&gt;FASTQ&lt;/h3&gt;

&lt;p&gt;fastq 파일은 NGS (Next generation sequencing data) 의 결과를 저장하는 데 주로 쓰입니다.&lt;br /&gt;
NGS 실험을 진행하면, 그 결과로 cDNA library 서열을 읽어서 데이터로 얻을 수 있습니다.&lt;br /&gt;
즉, 각 cDNA library 의 염기서열을 알 수 있는거죠.&lt;br /&gt;
이 서열 하나를 ‘read’ 라고 하는데요.&lt;br /&gt;
fastq 파일은 여러 read 의 정보를 한 파일에 저장하게 됩니다.&lt;/p&gt;

&lt;p&gt;보통 이 파일을 직접 사용하기보다, reference genome 에 align 한 뒤에 활용됩니다.&lt;br /&gt;
fastq 파일은 대부분의 연구에서 raw data, 즉 가공되지 않은 원본 파일로 여겨집니다.&lt;br /&gt;
그러니 분석하실 땐 fastq를 잘 백업해두셔서 잃어버리지 않도록 하세요!&lt;/p&gt;

&lt;p&gt;fastq 파일은 네 줄이 한 단위입니다.&lt;br /&gt;
위에서 말씀드린 것처럼 하나의 cDNA library 정보가 네 줄에 나눠서 표현되어 있는 거죠.&lt;br /&gt;
이들은 각각 다음 정보를 가지고 있습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sequence ID: @ 로 시작하며, 해당 서열의 이름을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;sequence: 실제로 읽은 염기서열 정보입니다.&lt;/li&gt;
  &lt;li&gt;description: ‘+’ 글자로 시작하는데, + 하나만 있기도 하고 sequence ID를 넣거나 설명을 넣는 부분입니다.&lt;/li&gt;
  &lt;li&gt;quality: 각 염기서열이 얼마나 정확히 읽혔는지를 나타냅니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Phred_quality_score&quot;&gt;Phred quality score&lt;/a&gt; 라는 표현법을 사용합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;fastq 파일의 예시. 이름-서열-설명-품질 이 반복됩니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* 주의: fastq 파일도 역시, 보통은 엄청나게 크기 때문에 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;bam-sam&quot;&gt;BAM, SAM&lt;/h3&gt;

&lt;p&gt;BAM 파일을 먼저 살펴볼까요.&lt;br /&gt;
BAM 은 binary alignment map 이라는 형식이에요.&lt;br /&gt;
이 파일은 위에서 설명한 fastq 파일을 reference genome에 align 했을 때 만들어지는 파일이죠.&lt;br /&gt;
즉, 각 cDNA library 조각이 reference genome 의 어느부분에서 나왔구나~ 하는 정보를 담았다는 거죠.&lt;br /&gt;
fastq 에서는 각 read 의 염기서열과 그 품질을 알 수 있다면, BAM 파일은 염기서열과 reference 에서의 위치정보 를 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇지만 BAM 파일은 사람이 읽을 수 없는 파일입니다…&lt;br /&gt;
정보를 압축하기 위해 binary 형태로 저장된 파일이기 때문이죠.&lt;br /&gt;
다행히도 이 BAM 파일을 ‘볼 수 있게’ 해놓은 파일이 있습니다. 바로 SAM 파일입니다.&lt;br /&gt;
BAM 파일과 SAM 파일은 동일한 정보를 가지고 있고, 서로 변환이 가능합니다. (변환 방법은 다음에 설명드릴게요)&lt;/p&gt;

&lt;p&gt;SAM 파일은 header 부분과 alignment 부분으로 이루어져 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;header&lt;br /&gt;
header 부분은 파일에 대한 설명을 주는 부분입니다. @ 로 시작하는 라인들입니다.&lt;/li&gt;
  &lt;li&gt;alignment&lt;br /&gt;
alignment 부분이 각 read에 대한 alignment 정보를 제공하는 부분입니다.&lt;br /&gt;
필수적인 11개의 컬럼으로 이루어져 있고, 추가로 몇 개의 컬럼이 더 있을 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;SAM 파일의 예시. 11개 컬럼이 너무 길어서 엑셀로 표시해보았어요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;각 column의 설명은 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;QNAME: read 이름&lt;/li&gt;
  &lt;li&gt;FLAG: 2진수로 된 read alignment 에 대한 설명&lt;/li&gt;
  &lt;li&gt;RNAME: refernce sequence 의 이름&lt;/li&gt;
  &lt;li&gt;POS: reference sequence 에서 align 된 위치&lt;/li&gt;
  &lt;li&gt;MAPQ: mapping quality. 즉 얼마나 정확히 align 되었는지.&lt;/li&gt;
  &lt;li&gt;CIGAR string: alignment 정보를 표현한 문자열. Match, Gap 등의 설명을 각 염기마다 표현합니다.&lt;/li&gt;
  &lt;li&gt;RNEXT: 다음 read 의 reference sequence 이름. 주로 paired end read 에 대한 분석을 위해 사용됩니다.&lt;/li&gt;
  &lt;li&gt;PNEXT: 다음 read 의 align 된 위치. 주로 paired end read 에 대한 분석을 위해 사용됩니다.&lt;/li&gt;
  &lt;li&gt;TLEN: Template length. paired-end read 둘의 left-end 부터 right-end 까지의 길이입니다.&lt;/li&gt;
  &lt;li&gt;SEQ: segment sequence. 염기 서열을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;QUAL: Phread quality score 입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;와, 저도 이 11개 컬럼의 뜻을 모두 알지는 못했는데 이렇게 많은 정보가 있는 줄은 몰랐네요!&lt;br /&gt;
* 주의: SAM 파일도 역시, 읽을수는 있다고 하나 엄청나게 크기 때문에 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘은 FASTA, FASTQ, BAM/SAM 파일에 대해 알아봤습니다.&lt;br /&gt;
분석의 앞부분에서 꼭 마주치게 되는 형식들이죠.&lt;br /&gt;
평소에 잘 안다고 생각했던 것들인데, 자세히 들어가보니 내용이 무척 많네요.&lt;br /&gt;
언젠가 이 파일들이 분석 순서상으로 어떻게 연관되어 있는지도 설명드릴게요.&lt;/p&gt;

&lt;p&gt;아, 그리고 이 외에도 널리 사용되는 파일 형식들이 많은데요, VCF/BED/GTF 등이 있어요.&lt;br /&gt;
이 형식들은 다음에 또 알아보도록 할게요.&lt;/p&gt;

&lt;p&gt;그럼 다음시간에 만나요!&lt;/p&gt;</content><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><category term="biology" /><category term="tech" /><summary type="html">생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다</summary></entry><entry><title type="html">깃 블로그에서 코드블록 만들기 - liquid, html, markdown을 한 번에!</title><link href="http://localhost:4000/blog/2020/08/22/Jekyll%EC%97%90%EC%84%9C-%EC%BD%94%EB%93%9C%EB%B8%94%EB%A1%9D-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B8%B0.html" rel="alternate" type="text/html" title="깃 블로그에서 코드블록 만들기 - liquid, html, markdown을 한 번에!" /><published>2020-08-22T00:00:00+09:00</published><updated>2020-08-22T00:00:00+09:00</updated><id>http://localhost:4000/blog/2020/08/22/Jekyll%EC%97%90%EC%84%9C-%EC%BD%94%EB%93%9C%EB%B8%94%EB%A1%9D-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/blog/2020/08/22/Jekyll%EC%97%90%EC%84%9C-%EC%BD%94%EB%93%9C%EB%B8%94%EB%A1%9D-%ED%95%98%EC%9D%B4%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EA%B8%B0.html">&lt;h3 id=&quot;깃-블로그에서-코드-부분을-볼-수-있게-해보자&quot;&gt;깃 블로그에서 코드 부분을 볼 수 있게 해보자!&lt;/h3&gt;

&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
이번엔 블로그에서 코드를 설명할 때 특정 블록으로 처리하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;깃 블로그는 Jekyll로 이루어져 있고, 각 포스트는 .md 파일로 구성되어 있죠.&lt;br /&gt;
이 파일 안에는 그냥 텍스트를 쓸 수도 있지만, liquid, html, markdown 세가지 언어를 통해 특정 기능이나 표현을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 어떤 코드를 썼는지를 그대로 보여주려면 어떻게 할까요?&lt;br /&gt;
예를 들어, 아래처럼 이탤릭체로 기울어진 텍스트는 ‘asterisk 별표 모양을 글 양옆에 붙이면 된다’는 설명을 어떻게 하면 될까요?&lt;br /&gt;
&lt;em&gt;기울임글자&lt;/em&gt;&lt;br /&gt;
별표-텍스트-별표 라고 쓰세요! 이런식으로 설명할 수도 없고 말이죠.&lt;/p&gt;

&lt;p&gt;이럴 때, 코드블록이 필요합니다.&lt;br /&gt;
깃 블로그에서 쓰는 liquid, html, markdown 세가지에 대해 어떻게 코드를 나타낼 수 있는지 알아보겠습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;liquid-의-경우&quot;&gt;liquid 의 경우&lt;/h3&gt;

&lt;p&gt;Jekyll 은 중괄호-퍼센트 글자 사이, 즉 {% 와 %} 모양 안에 특정 문구를 넣어서 원하는 명령을 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이걸 liquid 언어라고 하는데요, 이처럼 작성하면 Jekyll이 이 부분을 인식하고 렌더링을 통해 특정 기능을 실행합니다.&lt;br /&gt;
사실 이전 포스트에서 ‘이 코드를 넣으세요’ 라며 설명하는 부분이 있었는데,&lt;br /&gt;
그 코드를 실제로 쓰려니 코드가 렌더링 되어서 여러분께 보여드릴 수가 없었습니다.&lt;/p&gt;

&lt;p&gt;그래서 찾아보았습니다. 역시 구글은 검색하면 다 나오는군요.&lt;br /&gt;
아래처럼 Jekyll liquid 언어를 블로그에 넣는 방법을 설명드리겠습니다.&lt;br /&gt;
두 가지 방법이 있습니다. 하나는 raw-endraw 구문, 다른 하나는 highlight-endhighlight 구문입니다.&lt;/p&gt;

&lt;p&gt;{%- if page.comments -%}&lt;br /&gt;
    {%- include disqus_comments.html -%}&lt;br /&gt;
{%- endif -%}&lt;/p&gt;

&lt;p&gt;위 세줄을 .md 파일에 그냥 쓰면 이 글에서 보이지 않을 겁니다. 그럼 어떻게 한 걸까요?&lt;br /&gt;
방법은 정말 간단합니다.&lt;br /&gt;
아래 그림처럼 raw - endraw 구문을 넣으면 됩니다!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200822/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;이렇게 말입니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;정말 쉽죠?&lt;br /&gt;
liquid 문구 중 raw-endraw 라는 문구를 쓰면, 그 안에서 Jekyll liquid 언어를 작성하더라도&lt;br /&gt;
실제로 렌더링 하는 대신 ‘그대로’ 보여주더군요.&lt;/p&gt;

&lt;p&gt;그런데, 너무 코드블록 느낌이 안 나는군요. 어떻게 하면 될까요?&lt;br /&gt;
이 때는 pre, code 문구를 추가로 위아래에 집어넣으면 됩니다. 아래 그림처럼요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 표시할 코드부분만 코드블록 안에 나오게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{%- if page.comments -%}
    {%- include disqus_comments.html -%}
{%- endif -%}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 방법을 통해서 여러분께 liquid 언어 쓰는 방법을 더 자세하게 설명할 수 있게 되었습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;html의-경우&quot;&gt;html의 경우&lt;/h3&gt;
&lt;p&gt;html 을 코드블록에 표시하는 방법은 두가지입니다.&lt;br /&gt;
첫 번째는 물결 세 개를 쓰고 html이라고 쓰면 되는군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 이렇게 나옵니다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://hhj6212.github.io/&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   블로그 링크
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹은 highlight-endhighlight 기능을 사용할 수 있습니다.&lt;br /&gt;
highlight는 특정 언어를 지정하면, 그 언어에 맞는 형식대로 코드블록에서 보여줄 수 있게 해줍니다.&lt;br /&gt;
여기서 표시해야 할 언어는 html 이니, {% highlight html %} 이라고 작성해야 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이것도 똑같은 효과를 가져옵니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://hhj6212.github.io/&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   블로그 링크
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;markdown-언어의-경우&quot;&gt;markdown 언어의 경우&lt;/h3&gt;
&lt;p&gt;markdown 언어는 어떻게 할까요?&lt;br /&gt;
위에서 썼던 방법 중 pre, code 문구를 사용하면 됩니다.&lt;br /&gt;
이렇게 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 나타나게 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 하하하&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;세-언어를-동시에-사용할-때는요&quot;&gt;세 언어를 동시에 사용할 때는요?&lt;/h3&gt;
&lt;p&gt;만약 제가 liquid, html, markdown 세 가지 언어로 작성된 .md 파일을 여러분께 그대로 보여드리고 싶을 때는 어떻게 할까요?&lt;br /&gt;
물론 스크린샷을 찍어서 보여드릴 순 있겠죠.&lt;br /&gt;
그렇지만 여러분께서 따라서 연습하고 싶으실 땐 복사-붙여넣기를 하고 싶으실테니까, 좀 더 좋은 방법을 사용해봅시다.&lt;/p&gt;

&lt;p&gt;위에서 사용한 세 가지 방법을 잘 조합하면 됩니다!&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;liquid: raw-endraw 문구&lt;/li&gt;
  &lt;li&gt;html: highlight 문구&lt;/li&gt;
  &lt;li&gt;markdown: pre/code 문구&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;코드를 감쌀 때, 위 세 개의 물고 물리는 관계를 잘 고려해야 합니다.&lt;br /&gt;
예를 들어, pre/code 문구는 html이니, 이건 highlight로 묶기 전에 선언해야 합니다.&lt;br /&gt;
또, highlight 문구는 liquid 언어이므로, raw-endraw로 묶기 전에 선언해야 하죠.&lt;/p&gt;

&lt;p&gt;즉 다음과 같은 구조로 짜야 합니다.&lt;br /&gt;
가장 바깥에 pre-code, 그 다음에 highlight, 그리고 raw 로 묶으면 됩니다.&lt;br /&gt;
아래 그림처럼 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 liquid, html, markdown 세가지 언어가 모두 ‘그대로’ 여러분께 표시됩니다!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;{%- if page.comments -%}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post-disqus&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        ### 하하하
        {%- include disqus_comments.html -%}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{%- endif -%}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금까지 Jekyll 에서 liquid, html, markdown 을 코드블록으로 표시하는 방법을 배워보았습니다.&lt;br /&gt;
여러분의 블로그에서도 잘 활용하셨으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;그럼 다음 시간에 만나요!&lt;/p&gt;</content><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><category term="blog" /><summary type="html">깃 블로그에서 코드 부분을 볼 수 있게 해보자!</summary></entry><entry><title type="html">깃블로그에 댓글창 달기</title><link href="http://localhost:4000/blog/tech/2020/08/20/%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-%EB%8C%93%EA%B8%80%EC%B0%BD%EB%8B%AC%EA%B8%B0.html" rel="alternate" type="text/html" title="깃블로그에 댓글창 달기" /><published>2020-08-20T00:00:00+09:00</published><updated>2020-08-20T00:00:00+09:00</updated><id>http://localhost:4000/blog/tech/2020/08/20/%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-%EB%8C%93%EA%B8%80%EC%B0%BD%EB%8B%AC%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/blog/tech/2020/08/20/%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-%EB%8C%93%EA%B8%80%EC%B0%BD%EB%8B%AC%EA%B8%B0.html">&lt;h3 id=&quot;깃허브-블로그에-댓글창을-달아보자&quot;&gt;깃허브 블로그에 댓글창을 달아보자&lt;/h3&gt;
&lt;p&gt;안녕하세요. 한헌종입니다.&lt;/p&gt;

&lt;p&gt;이번엔 Jekyll 로 구축된 깃허브 블로그에 댓글창을 넣는 방법을 설명해 보겠습니다.&lt;br /&gt;
블로그에는 당연하게 댓글창이 달려있을 거라 생각하실 겁니다.&lt;br /&gt;
그러나 깃허브 블로그는 그렇지 않습니다…&lt;br /&gt;
오로지 글만 올리는 용도의 블로그로만 써야하나? 하는 생각이 들었습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;소통 없는 삭막한 블로그의 현장&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그래서 찾아봤습니다. 어딘가 당연히 방법이 있겠지.&lt;br /&gt;
구글링을 해보니 이미 많은 분들이 Jekyll 에 댓글창을 추가해 사용하고 계시더군요.&lt;br /&gt;
그 방법은 바로 Disqus 라는 사이트의 서비스를 이용하는 것이었습니다.&lt;br /&gt;
자, 일단 &lt;a href=&quot;https://disqus.com/&quot;&gt;https://disqus.com/&lt;/a&gt; 에 접속해서 계정을 만들어 봅시다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;계정을 만든 다음에는 이메일 인증을 꼭 해주세요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;계정을 만들고 Get started 를 클릭하면 다음과 같은 선택창이 뜹니다.&lt;br /&gt;
저는 제 사이트에 댓글을 만들고 싶으므로 아래의 “I want to install Disqus on my site” 를 클릭합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;선택지가 둘 뿐이군요. 아래꺼 선택!&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 후 Disqus를 사용하기 위한 설정들을 해야 합니다.&lt;br /&gt;
먼저 사이트를 나타낼 이름을 지어봅니다. (저는 간단하게 hhangitblog로 했습니다.)&lt;br /&gt;
Category 도 아무거나 선택해주시구요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;간단하고 기억하기 쉬운 걸로 지어봅시다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그런 다음엔 서비스를 선택해야 합니다.&lt;br /&gt;
돈 내고 굉장히 좋은 서비스를 사용할 수도 있군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;돈 안내는 서비스는 없나 찾아보니, 아래쪽에 숨겨뒀네요.&lt;br /&gt;
Basic을 선택하시면 무료로 이용이 가능합니다.&lt;br /&gt;
물론 선택은 여러분에게 달려있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 다음엔 어떤 플랫폼을 사용하고 있는지 고르게 되어있습니다.&lt;br /&gt;
이중 Jekyll을 선택해줍시다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image7.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;Jekyll 말고도 웹사이트 만드는 선택지가 굉장히 많군요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 이러면 disqus 사이트에서 설정할 부분은 모두 끝났습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;다음 장면에서는 Jekyll 코드에서 어떤 부분을 만져야 댓글창이 나오는지 알려줍니다.&lt;br /&gt;
Post를 작성할 때 _post/ 디렉터리에 yyyy-mm-dd-name.md 문서를 작성하실 겁니다.&lt;br /&gt;
이 때, 각 .md 파일의 맨 윗부분에 변수로 “comments” 라는 것을 만들고, 이를 “true”로 설정해줘야 합니다.&lt;br /&gt;
그림에서처럼 말이죠.&lt;br /&gt;
여기서, layout: default 처럼 여러분이 포스트 글에서 사용하고 계신 _layout/[레이아웃이름].html 을 기억하고 계세요!&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image8.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이후, 위 그림의 아래 부분에 나와있는 파란 글씨의 “Universal Embed Code”라는 것을 클릭해봅시다.&lt;br /&gt;
그럼 다음과 같은 긴 코드가 나오는데요.&lt;br /&gt;
여러분의 Jekyll 디렉토리에 _includes/disqus_comments.html 이라는 파일을 만들고, 이 코드를 모두 복사해 붙여넣어 주세요.&lt;br /&gt;
코드 중간에 보시면 제가 위에서 지은 블로그이름 ‘hhangitblog’ 가 사용되고 있는 걸 확인하실 수 있어요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image9.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image10.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;위 코드를 _includes/disqus_comments.html 에 붙여넣기 한 모습&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;거의 다 됐습니다!&lt;br /&gt;
이제 _layouts 만 바꾸면 됩니다.&lt;br /&gt;
저는 각 포스트의 레이아웃을 _layouts/post.html 을 참조하게 해놨는데요.&lt;br /&gt;
그럼 이 코드의 밑 부분에 아래 코드들을 추가하면 댓글창 사용이 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  {%- if page.comments -%}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post-disqus&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    {%- include disqus_comments.html -%}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  {%- endif -%}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image11.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 끝났습니다!&lt;br /&gt;
이제 포스트를 확인하시면 댓글창이 들어와 있는 걸 보실 수 있습니다.&lt;br /&gt;
간단한 것 같으면서도 여러 과정을 거쳐야 하는군요.&lt;br /&gt;
그래도 블로그에 댓글창 정도는 있어야겠죠.&lt;br /&gt;
배워보길 잘했다는 생각이 듭니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image12.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;드디어 댓글로 소통이 가능해졌군요. 편-안&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이제 여러분도 댓글창을 만드실 수 있습니다.&lt;br /&gt;
긴 글 읽어주셔서 감사합니다.&lt;/p&gt;</content><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><category term="blog" /><category term="tech" /><summary type="html">깃허브 블로그에 댓글창을 달아보자 안녕하세요. 한헌종입니다.</summary></entry><entry><title type="html">깃블로그를 시작하며</title><link href="http://localhost:4000/life/2020/08/19/%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html" rel="alternate" type="text/html" title="깃블로그를 시작하며" /><published>2020-08-19T00:00:00+09:00</published><updated>2020-08-19T00:00:00+09:00</updated><id>http://localhost:4000/life/2020/08/19/%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/life/2020/08/19/%EA%B9%83%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html">&lt;h3 id=&quot;블로그를-시작하며&quot;&gt;블로그를 시작하며&lt;/h3&gt;
&lt;p&gt;얼마전까지만 해도 블로그 하면 네이버 블로그밖에 생각이 안나고, 저랑은 전혀 관련없는 세상이라고 생각했습니다.&lt;br /&gt;
그런데 최근들어 주변에서 블로그를 시작해보라는 이야기를 많이 해주셨습니다.&lt;br /&gt;
추천해주신 분들 중에는 이미 몇년간, 혹은 십년 이상 블로그를 운영해오신 분들이 계셨습니다.&lt;br /&gt;
그분들을 보며 “와 저렇게 오래 많은 글을 기록하는 건 무척 힘들겠구나” 라며 압도되었습니다.&lt;br /&gt;
그때마다 제가 들었던 말은, 바로 가장 작은 것부터 시작해보라는 이야기였습니다.&lt;br /&gt;
처음부터 크게 할 생각을 하지 말고, 조금씩 꾸준히 해나가는게 중요하다는 것이었습니다.&lt;br /&gt;
그러다보면 어느새 수많은 글을 포스팅하게 되고, 그 분야의 전문가로 인정받을 수 있다는 말이었죠.&lt;/p&gt;

&lt;p&gt;그래서 한번, 시작해보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떤-내용을-써볼까&quot;&gt;어떤 내용을 써볼까&lt;/h3&gt;
&lt;p&gt;저는 글을 잘쓰는 스타일은 아닙니다.&lt;br /&gt;
그러나 기록하는 걸 좋아합니다.&lt;br /&gt;
기록의 용도는 주로 배웠던 걸 까먹지 않기 위해, 혹은 이전에 할줄 알았던 것들이 오랜만에 하려니 잘 생각이 안날때를 위한 것이었습니다.&lt;br /&gt;
간단한 파이썬 함수라도, 사용법을 알기쉽게 정리해 놓으면 나중에 유용한 경우가 많더군요.&lt;br /&gt;
마침 최근에 새로운 분야를 경험하고 배우고 있기 때문에 관련 지식을 조금씩 정리해나가면 좋을 것 같다는 생각을 했습니다.&lt;br /&gt;
물론, 일상적인 일들도 기록해두면 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;왜-깃블로그-인가&quot;&gt;왜 깃블로그 인가&lt;/h3&gt;
&lt;p&gt;깃허브로 블로그를 시작한 이유는, 일단 추천을 받았기 때문입니다.&lt;br /&gt;
깃허브 자체는 업무에는 많이 써왔지만 그 외에 써본 적은 없었습니다.&lt;br /&gt;
그런데 깃허브는 각 계정마다 하나씩 Git page라는 걸 쓸 수 있게 해주더군요. 무료로!&lt;br /&gt;
또, 몇몇 사람들의 깃허브 블로그를 보니 매우 깔끔했습니다.&lt;br /&gt;
마크다운 언어도 배워가던 중인데 이를 적절히 사용하면 깔끔하게 내용을 정리할 수 있겠다는 생각에 바로 시작하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;시행착오&quot;&gt;시행착오&lt;/h3&gt;
&lt;p&gt;…물론 생각보다 쉽지 않더군요.&lt;br /&gt;
깃블로그를 무작정 시작하려니 정말 하나도 이해할 수 없었습니다.&lt;br /&gt;
깃허브, 루비, Jekyll, Markdown, HTML, CSS, Liquid 등 알아야 하는게 왜이렇게 많은지.&lt;br /&gt;
블로그들의 설명대로 따라해도 뭔가 이상하고 맘에 안들었습니다.&lt;br /&gt;
몇번의 시행착오 끝에, 깃블로그란 깃허브에서 제공하는 개인 페이지에 만드는 것이며 이는 루비 언어로 만들어진 Jekyll 이라는 엔진으로 구축하는 것을 알 수 있었습니다. (쓰면서도 맞나 싶습니다)&lt;br /&gt;
Jekyll 이라는게 뭔지부터 차근차근 공부했다면 시행착오가 덜했을텐데.&lt;br /&gt;
이렇게 겪은 시행착오도 하나씩 블로그에 정리해 나갈 예정입니다.&lt;br /&gt;
앞으로 배울 게 매우 많겠군요.&lt;/p&gt;

&lt;h3 id=&quot;앞으로&quot;&gt;앞으로&lt;/h3&gt;
&lt;p&gt;블로그는 처음이라 어떻게 가꿔나가야 할지 모르겠습니다.&lt;br /&gt;
그러나 누군가 이야기해준 것처럼, 정말 작은것부터 하나하나 해나가는게 중요한 것 같습니다.&lt;br /&gt;
오늘 이렇게 한 페이지를 작성했고, 앞으로 꾸준히 작성해보려 합니다.&lt;/p&gt;</content><author><name>Heonjong Han</name><email>hhj6212@gmail.com</email></author><category term="life" /><summary type="html">블로그를 시작하며 얼마전까지만 해도 블로그 하면 네이버 블로그밖에 생각이 안나고, 저랑은 전혀 관련없는 세상이라고 생각했습니다. 그런데 최근들어 주변에서 블로그를 시작해보라는 이야기를 많이 해주셨습니다. 추천해주신 분들 중에는 이미 몇년간, 혹은 십년 이상 블로그를 운영해오신 분들이 계셨습니다. 그분들을 보며 “와 저렇게 오래 많은 글을 기록하는 건 무척 힘들겠구나” 라며 압도되었습니다. 그때마다 제가 들었던 말은, 바로 가장 작은 것부터 시작해보라는 이야기였습니다. 처음부터 크게 할 생각을 하지 말고, 조금씩 꾸준히 해나가는게 중요하다는 것이었습니다. 그러다보면 어느새 수많은 글을 포스팅하게 되고, 그 분야의 전문가로 인정받을 수 있다는 말이었죠.</summary></entry></feed>