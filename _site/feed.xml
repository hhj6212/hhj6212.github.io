<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>한헌종의 Git Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 01 Nov 2020 21:57:29 +0900</pubDate>
    <lastBuildDate>Sun, 01 Nov 2020 21:57:29 +0900</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>mysql 로 데이터 관리하기 - 설치부터 사용법까지</title>
        <description>&lt;p&gt;최근에 mysql data를 사용할 일이 있어서, 공부를 한번 해봤습니다.&lt;br /&gt;
생각보다 배워야 할 내용들이 많아서, 아래처럼 정리를 일단 해보았습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;설치는-어떻게-하나요&quot;&gt;설치는 어떻게 하나요?&lt;/h3&gt;
&lt;p&gt;맥에는 homebrew 라는 패키지 관리 앱이 거의 표준으로 쓰이고 있다고 합니다.&lt;br /&gt;
제 컴퓨터는 Mac 인데요, 오늘은 이 homebrew를 사용해서 설치해보도록 하겠습니다.&lt;br /&gt;
명령어는 다음 블로그에 무척 자세하게 정리되어 있어서 참고했습니다: &lt;a href=&quot;https://www.44bits.io/ko/keyword/homebrew&quot;&gt;블로그 링크&lt;/a&gt;&lt;br /&gt;
아래에는 관련 명령어들을 모두 요약해보았는데요, 이중에서 필요한 부분만 사용해 mysql 을 설치했습니다.&lt;br /&gt;
(brew 설치, 업데이트, mysql 검색 및 설치)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)&quot; # brew 설치
brew update             # brew 앱 업데이트
brew search mysql       # mysql 관련 패키지 검색
brew install mysql      # mysql 패키지 설치
brew install mysql@5.5  # mysql 을 특정 버전으로 설치
brew list               # 설치된 패키지 목록 보기
brew list mysql         # 설치된 mysql 관련 패키지 목록 보기
brew info mysql         # 설치된 mysql 패키지의 정보 보기
brew upgrade mysql      # mysql 버전 업그레이드
brew upgrade            # 모든 패키지의 버전 업그레이드
brew remove mysql       # mysql 패키지 삭제
brew uninstall mysql    # mysql 패키지 삭제 - 위와 동일한 결과
brew cleanup mysql      # mysql 의 최신버전을 제외한 outdated 버전 삭제
ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; # brew 삭제 &lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;mysql-설치-후-설정하고-시작하기&quot;&gt;mysql 설치 후 설정하고 시작하기&lt;/h3&gt;
&lt;p&gt;mysql 을 설치하신 뒤에는, 몇가지 설정을 해야 mysql 을 사용할 수 있게 됩니다.&lt;br /&gt;
mysql 설정 또한 무척 잘 설명된 블로그가 있으니 한번 참고해보세요! &lt;a href=&quot;https://whitepaek.tistory.com/16&quot;&gt;블로그 링크&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql.server start          # mysql 서버 실행하기
mysql_sequre_installation   # mysql 서버 설정하기 (아래 참조)
mysql -u root -p            # root 게정으로 mysql 접속, 비밀번호 필요
exit                        # mysql 로그아웃
quit                        # mysql 로그아웃
mysql.server stop           # mysql 서버 중지&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mysql_sequre_installation 명령어를 입력하면, 몇가지 질문에 대해 yes/no 선택 혹은 설정이 필요합니다.&lt;br /&gt;
아래를 참고해서 각자 원하시는 방법대로 설정해보세요!&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Would you like to setup VALIDATE PASSWORD component?: yes 인 경우 비밀번호를 어렵게 (숫자문자 조합) 만들어야 함&lt;/li&gt;
  &lt;li&gt;Please set the password for root here. : 비밀번호를 만들어주세요&lt;/li&gt;
  &lt;li&gt;Remove anonymous users? : yes 인 경우 접속 시 -u 옵션으로 유저를 지정해야 함&lt;/li&gt;
  &lt;li&gt;Disallow root login remotely? : yes 인 경우 원격 접속 불가능&lt;/li&gt;
  &lt;li&gt;Remove test database and access to it?: yes 인 경우 테스트로 미리 만들어져 있는 데이터베이스를 삭제함&lt;/li&gt;
  &lt;li&gt;Reload privilege tables now?: yes 인 경우 위의 설정을 테이블에 적용.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;설정을 다 하고나면 mysql 접속이 가능해집니다!&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;mysql-에-접속해-데이터베이스-생성-및-삭제하기&quot;&gt;mysql 에 접속해 데이터베이스 생성 및 삭제하기&lt;/h3&gt;

&lt;p&gt;아래에 기본적인 명령어들을 모아보았습니다.&lt;br /&gt;
mysql 접속한 뒤에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysql&amp;gt;&lt;/code&gt; 와 같은 콘솔로 바뀝니다.&lt;br /&gt;
명령어는 대/소문자를 구분하지 않는 것 같고, semi-colon (;) 으로 끝내야 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql -u root -p                    # root 게정으로 mysql 접속, 비밀번호 필요
show databases;                     # 어떤 databases 들이 있는지 확인
create database example_db;         # example_db 라는 데이터베이스 생성
remove database example_db;         # example_db 라는 데이터베이스 삭제
use example_db;                     # example_db 라는 데이터베이스 사용하기
show tables;                        # example_db 에 있는 테이블 목록 보기
desc example_table;                 # example_table 테이블의 구조 확인
show columns from example_table;    # example_table 테이블의 구조 확인&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;mysql-테이블-만들기&quot;&gt;mysql 테이블 만들기&lt;/h3&gt;
&lt;p&gt;테이블을 만들 때는 기본적으로 다음 형식으로 작성합니다.&lt;br /&gt;
테이블 이름 다음에는 괄호 안에 필요한 컬럼 이름과 형태를 적어줘야 합니다.&lt;br /&gt;
comma(,) 로 구분하고, 마지막엔 comma 가 없습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create table example_table (
    name char,
    weight tinyint,
    height int,
    birthday date
);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;컬럼에 대한 형태 및 설정은 다음과 같이 하면 됩니다. &lt;a href=&quot;https://www.mysqltutorial.org/mysql-create-table/&quot;&gt;링크 참조&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;column_name data_type(length) [NOT NULL] [DEFAULT value] [AUTO_INCREMENT] column_constraint;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;데이터 타입은 numeric, date and time, string, spatial, JSON 등 다양합니다. 다음 링크에서 확인할 수 있습니다: &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/data-types.html&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;데이터의 길이 등을 괄호 안에 지정해줄 수 있는데요, 예를 들어 char(3) 은 최대 3글자 까지 허용해준다는 뜻입니다. &lt;a href=&quot;https://www.w3schools.com/sql/sql_datatypes.asp&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;NOT NULL 이라고 쓰면, 해당 컬럼에는 NULL 값이 들어갈 수 없게 됩니다.&lt;/li&gt;
  &lt;li&gt;DEFAULT value 부분에는 입력안했을 때의 기본값을 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;AUTO_INCREMENT 는 새로운 row가 추가될 때마다 자동으로 1씩 증가한다는 뜻입니다. 각 테이블에는 최대 1개의 AUTO_INCREMENT 컬럼을 만들 수 있습니다. 또한 이 값은 항상 key로 설정해 줘야 합니다.&lt;/li&gt;
  &lt;li&gt;column constraint 에는 UNIQUE, CHECK, primary key 등을 추가할 수 있습니다. 예를 들어, UNIQUE 는 해당 컬럼 값들이 서로 달라야 한다는 뜻입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 항목을 참고하면 다음과 같이 테이블을 만들 수 있습니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create table example_table (
    name char(12),
    sex char(6),
    id char(20) not null unique,
    number int AUTO_INCREMENT,
    weight tinyint,
    height int,
    birthday date,
    primary key(number)
);&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;mysql-table-을-써보자&quot;&gt;mysql table 을 써보자!&lt;/h3&gt;
&lt;p&gt;이제 테이블을 만들었으니 사용을 해볼까요?&lt;br /&gt;
다음 명령어들을 통해 테이블 내용을 수정, 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;show tables;                                              # example_db 에 있는 테이블 목록 조회
desc example_table;                                       # example_table 테이블의 구조 확인
show columns from example_table;                          # example_table 테이블의 구조 확인
select name from example_table;                           # example_table 에서 'name' 컬럼 내용 조회
select name, birthday from example_table;                 # example_table 에서 'name,birthday' 컬럼 내용 조회
select * from example_table;                              # example_table 에서 모든 컬럼 내용 조회
select * from example_table limit 5;                      # 모든 컬럼 내용 중 '5개'만 조회
select name from example_table where weight &amp;lt; 60;         # weight 가 60 보다 작은 항목의 name 조회
select height from example_table where name = 'Joey';     # name 이 'Joey' 인 항목의 height 조회
select sex from example_table group by sex;               # 'sex' 컬럼의 내용을 sex 별로 조회하기
select sex, avg(height) from example_table group by sex;  # 'sex 와 'height'의 평균값을 sex 별로 조회하기
select * from example_table order by weight asc;          # 모든 컬럼을 'weight' 오름차순으로 나열해 조회하기
select * from example_table order by weight desc;         # 모든 컬럼을 'weight' 내림차순으로 나열해 조회하기&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또한, 다음 명령어들을 사용해서 컬럼의 추가/삭제가 가능합니다.&lt;br /&gt;
insert 의 경우, NOT NULL 인 컬럼을 제외하고는 모든 값을 추가해줘야 합니다.&lt;br /&gt;
Update 의 경우 set 명령어 뒤에 바꿀 내용을 작성해주는데요, where 뒤의 조건에 맞는 모든 row에 대해 수정을 진행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into example_table(name,id) values('Ross','RG123');   # name, id 컬럼이 각각 Ross, RG123 이라는 row 추가하기
update example_table set id = 'RG1004' where name = 'Ross';  # name 이 'Ross'인 row의 id값을 RG1004로 교체
delete from example_table where name = 'Ross';               # name 이 'Ross'인 row 삭제&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;일단 기본적인 명령어들을 모아서 정리해보았습니다.&lt;br /&gt;
생각보다 공부해야 할 내용들이 많은 것 같습니다.&lt;br /&gt;
다음엔 좀 더 재밌는 내용을 찾아봐야겠군요.&lt;/p&gt;

&lt;p&gt;그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tech/programming/2020/10/20/brew-mysql.html</link>
        <guid isPermaLink="true">http://localhost:4000/tech/programming/2020/10/20/brew-mysql.html</guid>
        
        
        <category>tech</category>
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>Samtools 사용법 총정리!</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다!&lt;br /&gt;
오늘은 sequencing data 분석에 굉장히 많이 쓰이는 samtools 라는 툴을 사용하는 예제를 적어보고자 합니다.&lt;br /&gt;
samtools 는 BAM, SAM 형태의 파일을 읽고, 쓰고, 조작할 수 있게 해줍니다.&lt;br /&gt;
영어로 된 설명은 여기서 찾아볼 수 있습니다: &lt;a href=&quot;http://www.htslib.org/&quot;&gt;Samtools 사이트 링크&lt;/a&gt;&lt;br /&gt;
내용이 매우 길어서, 아직 미완성이라 계속 보충해 나갈 예정입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;부연설명을 하자면, Samtools 는 BCFtools, HTSLib 와 관계가 있습니다.&lt;br /&gt;
HTSLib 은 high-throughput sequencing 데이터를 읽고 쓰게 해주는 라이브러리 이구요,&lt;br /&gt;
이를 Samtools, BCFtools 내부에서 사용하고 있습니다.&lt;br /&gt;
Samtools 는 BAM/SAM 을 다루는 툴이고, BCFtools는 BCF/VCF 파일을 다루는 툴입니다.&lt;br /&gt;
(BCF는 VCF의 binary 형태입니다. BCF-VCF 관계는 BAM-SAM 관계와 비슷하죠.)&lt;br /&gt;
Samtools, BCFtools 는 서로 다른 repository 로 각각 설치 가능하고, 이 때 HTSLib이 자동으로 같이 설치됩니다.&lt;br /&gt;
물론 HTSLib은 따로 설치할 수도 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;samtools-설치부터-알려주세요&quot;&gt;samtools 설치부터 알려주세요&lt;/h3&gt;
&lt;p&gt;samtools 를 설치하는 방법은 다양합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;source code 를 사용해서 설치:&lt;br /&gt;
 다음 링크에서 samtools source code 를 받을 수 있습니다: &lt;a href=&quot;http://www.htslib.org/download/&quot;&gt;다운로드 링크&lt;/a&gt;&lt;br /&gt;
 다운로드 한 뒤 압축을 풀고, 다음 명령어로 설치 가능합니다.
    &lt;pre&gt;&lt;code&gt;cd samtools-1.x    
./configure --prefix=/where/to/install
make
make install&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;github 를 통해서 설치:&lt;br /&gt;
 다음 링크에 samtool github repository 가 있습니다. &lt;a href=&quot;https://github.com/samtools&quot;&gt;samtools github&lt;/a&gt;&lt;br /&gt;
 (samtools github에는 이것 말고도 bcftools, htslib 등 다양한 repository 가 있군요.)&lt;br /&gt;
 clone으로 저장소를 불러온 다음 설치하면 되겠습니다.
    &lt;pre&gt;&lt;code&gt;git clone https://github.com/samtools/samtools.git
cd samtools
./configure
make
make install&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;conda 를 사용해 설치&lt;br /&gt;
 만약 anaconda 를 사용하고 계시다면, 더 쉽게 설치가 가능합니다.&lt;br /&gt;
 다음 명령어를 사용해보세요 &lt;a href=&quot;https://anaconda.org/bioconda/samtools&quot;&gt;(링크 참조)&lt;/a&gt;
    &lt;pre&gt;&lt;code&gt;conda install -c bioconda samtools&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;다양한-samtools-명령어들&quot;&gt;다양한 samtools 명령어들&lt;/h3&gt;
&lt;p&gt;설치가 끝나셨다면 samtools 명령어를 실행해볼까요?&lt;br /&gt;
터미널에서 samtools라고 작성하면 다음과 같이 나옵니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ samtools

Program: samtools (Tools for alignments in the SAM format)
Version: 1.11 (using htslib 1.11)

Usage:   samtools &lt;command /&gt; [options]

Commands:
  -- Indexing
     dict           create a sequence dictionary file
     faidx          index/extract FASTA
     fqidx          index/extract FASTQ
     index          index alignment

  -- Editing
     calmd          recalculate MD/NM tags and '=' bases
     fixmate        fix mate information
     reheader       replace BAM header
     targetcut      cut fosmid regions (for fosmid pool only)
     addreplacerg   adds or replaces RG tags
     markdup        mark duplicates
     ampliconclip   clip oligos from the end of reads

  -- File operations
     collate        shuffle and group alignments by name
     cat            concatenate BAMs
     merge          merge sorted alignments
     mpileup        multi-way pileup
     sort           sort alignment file
     split          splits a file by read group
     quickcheck     quickly check if SAM/BAM/CRAM file appears intact
     fastq          converts a BAM to a FASTQ
     fasta          converts a BAM to a FASTA

  -- Statistics
     bedcov         read depth per BED region
     coverage       alignment depth and percent coverage
     depth          compute the depth
     flagstat       simple stats
     idxstats       BAM index stats
     phase          phase heterozygotes
     stats          generate stats (former bamcheck)
     ampliconstats  generate amplicon specific stats

  -- Viewing
     flags          explain BAM flags
     tview          text alignment viewer
     view           SAM&amp;lt;-&amp;gt;BAM&amp;lt;-&amp;gt;CRAM conversion
     depad          convert padded BAM to unpadded BAM&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;명령어가 굉장히 많군요!&lt;br /&gt;
이 명령어들을 하나씩 살펴보기로 하죠.&lt;br /&gt;
그 전에! BAM/SAM 파일 형식을 잘 숙지하고 계셔야 쉽게 이해가 될 것입니다. &lt;a href=&quot;https://hhj6212.github.io/biology/tech/2020/08/26/Bioinformatics-fileformats.html&quot;&gt;(참고링크)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;*참고로 데이터는 1000 genome project 에서 NA12878 샘플의 chromosome 20번 데이터를 골라봤습니다. &lt;a href=&quot;https://www.internationalgenome.org/data&quot;&gt;(링크)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;indexing-fastabam-파일의-index-를-만들고-싶을-때&quot;&gt;Indexing: fasta/bam 파일의 index 를 만들고 싶을 때&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;dict&lt;br /&gt;
 fasta 파일에서 sequence dictionary 를 만들 때 쓰입니다.&lt;br /&gt;
 이를 통해 SAM 형식의 header 가 나오게 되는데, 여기에는 fasta 파일의 contig 수, 길이 등이 나오게 됩니다.&lt;br /&gt;
 다음 명령어를 통해 진행합니다:
    &lt;pre&gt;&lt;code&gt;$ samtools dict chr20.fa
@HD	VN:1.0	SO:unsorted
@SQ	SN:20	LN:63025520	M5:0dec9660ec1efaaf33281c0d5ea2560f	UR:file:/path/to/fasta/chr20.fa&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;faidx&lt;br /&gt;
 faidx는 fasta 파일을 indexing 할 때 씁니다.&lt;br /&gt;
 이 indexing 과정은, read data (fastq) 를 reference 에 빠르게 mapping 할 때 쓰입니다.&lt;br /&gt;
 reference fasta 파일을 활용해서 무언가 작업을 하고 싶을 땐, fasta index를 먼저 만들어놓아야 합니다.&lt;br /&gt;
 다음 명령어를 실행하면 fasta index file 인 reference.fa.fai 파일이 만들어 집니다.
    &lt;pre&gt;&lt;code&gt;samtools faidx reference.fa&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;fqidx&lt;br /&gt;
 fqidx 는 fastq 로 되어있는 reference sequence 의 index를 만들 때 쓰입니다.&lt;br /&gt;
 fastq 형태로 된 reference sequence는 전 아직 본적 없지만요…&lt;br /&gt;
 이 명령어의 경우, short reads 가 많은 fastq를 사용하면 거의 원본만큼의 크기를 가진 큰 idx 파일이 나오고, 이를 통해 연산할 경우 메모리를 매우 많이 잡아먹는다고 합니다.&lt;br /&gt;
 그래서 input으로는 적은 수의 sequence 를 가진 fastq 파일이 필요합니다.
    &lt;pre&gt;&lt;code&gt;samtools fqidx reference.fq&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;index&lt;br /&gt;
 여기서의 indexing 은 bam file indexing 을 말합니다.&lt;br /&gt;
 이 과정은 bam 파일에서 특정 영역의 alignment 정보를 빨리 불러올 수 있게 만드는 bai 파일을 만들어 줍니다.&lt;br /&gt;
 bam 파일에서 어떤 작업을 하고싶을 땐 이 index 파일이 있어야 합니다.&lt;br /&gt;
 사용법은 다음과 같습니다:
    &lt;pre&gt;&lt;code&gt;samtools index example.bam&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;editing-bam-파일을-수정하고-싶을-때&quot;&gt;Editing: bam 파일을 수정하고 싶을 때&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;calmd&lt;br /&gt;
 BAM 파일의 MD tag 와 NM tag 를 다시 계산하고자 할 때 사용하는 명령어입니다.&lt;br /&gt;
 MD tag 는 reference sequence 와 얼마나 일치하는지를 표현하는 방법입니다. &lt;a href=&quot;https://oktopbang.tistory.com/entry/MD-tag-and-cigar&quot;&gt;링크 참조&lt;/a&gt;&lt;br /&gt;
 NM tag 는 edit distance to reference 라는건데요, 쉽게 말해서 number of mismatches 입니다.&lt;br /&gt;
 사용법은 다음과 같습니다.&lt;br /&gt;
 결과물이 standard output으로 나오므로, output file 을 지정해주는 것이 좋습니다.&lt;br /&gt;
 또한, default output 형식은 sam 파일이므로, -b 옵션을 설정해주면 bam 결과물을 얻을 수 있습니다.
    &lt;pre&gt;&lt;code&gt;samtools calmd -b example.bam reference.fa &amp;gt; result.bam&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;fixmate&lt;br /&gt;
 read alignment 를 수행하는 툴은 여러가지인데요, 어떤 툴은 가끔 FLAG (2nd column) 값을 이상하게 만드는 경우가 있습니다.&lt;br /&gt;
 paired-end reads 분석을 위해서는 fragment 를 이루는 read pair 정보를 정확히 가지고 있는것이 중요합니다.&lt;br /&gt;
 때문에 fixmate 기능으로 FLAG 값을 수정해주는 작업이 필요할 때가 있습니다.&lt;br /&gt;
 fixmate 를 사용하려면 먼저 read 들이 genomic coordinate 가 아닌, 이름순으로 나열되어 있어야 합니다.&lt;br /&gt;
 다음과 같이 실행하시면 됩니다.
    &lt;pre&gt;&lt;code&gt;samtools sort -n example.bam | samtools fixmate - example.fixmate.sam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;(‘-‘ 표시는 이전 명령어의 standard output을 현재 명령어의 input으로 받는다는 뜻입니다.)&lt;br /&gt;
 만약 이름으로 이미 나열되어 있다면 다음과 같이 실행하시면 됩니다.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;samtools fixmate -O bam example.bam example.fixmate.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;input 은 sam, bam 아무거나 상관이 없는데, output 형태가 bam 파일이 되려면 -O bam 이라는 옵션을 추가해줘야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;reheader&lt;br /&gt;
 bam 파일에 header 가 없거나, header 가 이상해서 이를 수정하고 싶을 때가 있습니다.&lt;br /&gt;
 그런 경우에는 header sam 파일을 만들어 놓고, 다음과 같은 명령어를 수행하시면 됩니다.
    &lt;pre&gt;&lt;code&gt;samtools reheader new_header.sam example.bam &amp;gt; result.sam&lt;/code&gt;&lt;/pre&gt;
    &lt;!-- 1. targetcut --&gt;
  &lt;/li&gt;
  &lt;li&gt;addreplacerg&lt;br /&gt;
 이 명령어는 read group 명을 더하거나 바꾸고 싶을 때 사용합니다.&lt;br /&gt;
 bam header 에 @RG 로 표현된 부분이 바로 read group 에 대한 정보이며, 각 read 들은 이런 read group ID 중 하나를 가지고 있습니다.&lt;br /&gt;
 read group 에 대한 자세한 설명은 다음 링크에서 보실 수 있습니다. &lt;a href=&quot;https://gatk.broadinstitute.org/hc/en-us/articles/360035890671-Read-groups&quot;&gt;링크&lt;/a&gt;&lt;br /&gt;
 -r 옵션으로 @RG 전체 string을 지정해줄 수도 있으며, -R 옵션으로 이미 있는 RG ID 를 지정해줄 수도 있습니다.&lt;br /&gt;
 -m 옵션으로 덮어쓸지 추가할지를 결정할 수 있는데요, -m orphan_only 옵션으로는 추가, -m overwrite_all 으로는 덮어쓰기가 가능합니다.
    &lt;pre&gt;&lt;code&gt;samtools addreplacerg -r '@RG\tID:NG01G\tLB:NG01G\tPL:ILLUMINA\tSM:NG01G' -m orphan_only example.bam -o example.addrg.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;위 명령어를 통해 ‘@RG\tID:NG01G\tLB:NG01G\tPL:ILLUMINA\tSM:NG01G’ 라는 read group 이 bam file에 추가됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;markdup&lt;br /&gt;
 markdup 은 duplicated alignments 를 표시하기 위한 기능입니다.&lt;br /&gt;
 먼저 input bam file 은 coordinate 순서대로 나열되어 있어야 합니다.&lt;br /&gt;
 또한 위에서 언급한 fixmate 를 -m option 추가한 상태로 돌린 뒤에 가능합니다.&lt;br /&gt;
 그래서 1) name sort 진행 후 2) fixmate -m 진행하고 3) coordinate sort 를 진행한 뒤에 4) markdup 기능을 사용할 수 있습니다.&lt;br /&gt;
 다음 명령어로 진행합니다: (‘-‘ 표시는 이전 명령어의 standard output을 현재 명령어의 input으로 받는다는 뜻입니다.)
    &lt;pre&gt;&lt;code&gt;samtools sort -n example.bam|samtools fixmate -m - example.fixmate.bam
samtools sort example.fixmate.bam|samtools markdup - example.markdup.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;이 때, duplicated alignments를 없애고 싶다면 markdup 에 -r 옵션을 사용하면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;file-operations-bam-파일을-합치고-나누고-나열하는-방법&quot;&gt;File operations: bam 파일을 합치고 나누고, 나열하는 방법&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;collate&lt;br /&gt;
 collate read 들을 read group 별로 나열해주는 작업입니다.&lt;br /&gt;
 이 작업은 ‘read groups’ 를 알고나면 이해하기 쉽습니다. &lt;a href=&quot;https://gatk.broadinstitute.org/hc/en-us/articles/360035890671-Read-groups&quot;&gt;(관련 링크)&lt;/a&gt;&lt;br /&gt;
 요약하면, read group 이란 각 single lane 마다 부여되는 이름입니다.&lt;br /&gt;
 최근 시퀀싱 기술은 여러 sample libraries 들을 pooling 해서 한번에 분석하는 경우가 많은데요,&lt;br /&gt;
 이런 경우 sample 들을 여러 lane 에 나누어서 분석하는 것을 바로 multiplexed sequencing 이라고 합니다. 더 빠르고, 효율적인 방법이죠.&lt;br /&gt;
 결과로 나온 reads 에는 어떤 lane에서 분석된 것인지를 이름으로 구분해주는데요, 우리는 이 정보를 활용해서 각 lane 에서 오는 영향을 관찰하고 활용할 수 있습니다.&lt;br /&gt;
 collate 는 read 들을 read group 별로, 즉 sequencing lane 별로 묶어서 나열해주는 작업을 진행합니다.&lt;br /&gt;
 다음 명령어로 진행합니다.
    &lt;pre&gt;&lt;code&gt;samtools collate example.bam --output-fmt sam -o example.collate.sam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;output 형식은 –output-fmt 옵션으로 지정해주시고, output 파일은 -o 옵션으로 지정해주시면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;cat&lt;br /&gt;
 cat 은 concatenate 의 약자입니다. 이름대로 여러개의 bam 파일을 합칠 때 사용합니다.&lt;br /&gt;
 합치는 방식은 정말 간단하게 각 파일을 이전 파일의 맨 뒤에 붙이는 방식으로 진행합니다.&lt;br /&gt;
 단, 조건이 있습니다. 먼저 파일들의 형식이 모두 같아야 하고, 파일들은 모두 똑같은 sequence dictionary 를 가져야 합니다.&lt;br /&gt;
 사용법은 간단합니다. -o 옵션으로 결과를 저장합니다.
    &lt;pre&gt;&lt;code&gt;samtools cat example_1.bam example_2.bam -o example_cat.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;합칠 파일들을 특정 텍스트파일에 적어놓고 사용할 수도 있습니다. 한 줄에 파일이름 하나씩 적어놓은 file_list.txt 를 만들고, -b 옵션으로 다음과 같이 쓰시면 됩니다:&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;samtools cat -b file_list.txt -o example_cat.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;header 는 default 로 첫번째 파일의 header 를 사용하나, 이를 -h 옵션으로 다른 파일의 헤더를 사용할 수도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;merge&lt;br /&gt;
 merge 역시 여러개의 bam 파일을 합칠 때 사용합니다.&lt;br /&gt;
 cat 명령어와 같다고 생각하실 수 있으나, 한 가지 차이점이 있습니다.&lt;br /&gt;
 바로 ‘sorted output’을 결과물로 준다는 것인데요.&lt;br /&gt;
 그러기 위해서는 input 파일들이 모두 같은 알고리즘으로 나열되어 있어야 합니다.&lt;br /&gt;
 즉, 한 파일을 samtools sort -n 옵션으로 나열했다면, merge 하려는 다른 파일들 역시 -n 옵션으로 나열되어 있어야 합니다.&lt;br /&gt;
 사용법은 다음과 같습니다:
    &lt;pre&gt;&lt;code&gt;samtools merge example_1.bam example_2.bam -o example_cat.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;여기서도 -h 옵션으로 헤더를 지정해줄 수 있는데요, 지정하지 않는 경우엔 input header 들이 모두 합쳐집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;mpileup&lt;br /&gt;
 bam 파일을 사용해 pileup 형식의 파일을 만들어내는 명령어입니다.&lt;br /&gt;
 pileup 형식이란? SNP/indel 등의 variant 정보를 한눈에 확인할 수 있는 파일 형식입니다.&lt;br /&gt;
 자세한 설명은 다음 링크에서 확인하실 수 있어요! &lt;a href=&quot;http://samtools.sourceforge.net/pileup.shtml&quot;&gt;(링크)&lt;/a&gt;&lt;br /&gt;
 간단한 사용법은 다음과 같습니다. -o 로 output 파일을 만들어 줍니다.
    &lt;pre&gt;&lt;code&gt;samtools mpileup example.bam -o example.pileup&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;옵션을 살펴보니 몇가지 알아두면 좋을 항목이 있었습니다:&lt;br /&gt;
 -f [fasta 파일]: indexing 되어있는 reference fasta 파일을 사용할 수 있습니다.&lt;br /&gt;
 -l [bed 파일]: 지정해준 bed 파일에 나타난 영역에 대해서만 mpileup 을 진행합니다.&lt;br /&gt;
 -b [bam 파일 목록이 적힌 텍스트 파일]: 여러 bam 파일에 대해 작업할 때, 파일 목록을 만들어서 줄 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;sort&lt;br /&gt;
 bam 파일에 있는 read 들을 나열할 때 사용합니다.&lt;br /&gt;
 간단한 사용법은 다음과 같습니다. -o 옵션으로 ouput 파일을 지정해 줍니다.
    &lt;pre&gt;&lt;code&gt;samtools sort example.bam -o example_sorted.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;sort 에는 여러 유용한 옵션들이 있으니 한번 참고해볼까요?&lt;br /&gt;
 -n: read 를 나열할 때 read name 순으로 나열합니다.&lt;br /&gt;
 -t: read 를 나열할 때 TAG 숫자 순으로 나열합니다.&lt;br /&gt;
 -T [prefix]: sort 를 진행하면 temporary 파일들이 많이 사용되는데요, 이 때 temporary 파일의 형식을 지정해준 prefix.nnnn.bam 으로 만들도록 합니다.&lt;br /&gt;
 -@ [thread 수]: 나열할 때 사용할 thread 를 지정해줍니다.&lt;br /&gt;
 -m [memory]: 나열할 때 사용할 thread 별 최대 메모리를 지정해줍니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;split&lt;br /&gt;
 bam 파일에 있는 reads 들을 read group 별 독립된 파일들로 나눠줍니다.&lt;br /&gt;
 이 작업은 ‘read groups’ 를 알고나면 이해하기 쉽습니다. &lt;a href=&quot;https://gatk.broadinstitute.org/hc/en-us/articles/360035890671-Read-groups&quot;&gt;(관련 링크)&lt;/a&gt;&lt;br /&gt;
 사용법은 다음과 같습니다.
    &lt;pre&gt;&lt;code&gt;samtools split example.bam&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;결과물로는 read group 마다 example_0.bam, example_1.bam … 으로 나옵니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;quickcheck&lt;br /&gt;
 이름 그대로 bam 파일이 온전한지를 빠르게 체크하는 명령어입니다.&lt;br /&gt;
 설명에 따르면 header 를 제대로 가지고 있는지, target sequnece를 최소한 하나 가지고 있는지, 그리고 파일 끝 부분이 EOF (end-of-file) 을 제대로 가지고 있는지를 확인한다고 하는군요.&lt;br /&gt;
 파일 하나씩 체크할 수도 있지만, 매뉴얼에는 여러 파일을 한번에 체크하는 방법을 추천하고 있습니다.&lt;br /&gt;
 다음 명령어 입니다. 한번 확인해볼까요?
    &lt;pre&gt;&lt;code&gt;samtools quickcheck example.bam
samtools quickcheck *.bam &amp;amp;&amp;amp; echo 'all ok' || echo 'fail!'
samtools quickcheck -qv *.bam &amp;gt; bad_bams.fofn &amp;amp;&amp;amp; echo 'all ok'  || echo 'some files failed check, see bad_bams.fofn'&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;첫 번째 명령어는 파일 하나만 체크하는 방법입니다.&lt;br /&gt;
 두 번째 명령어는 모든 bam 파일 확인 후, 정상이라면 ‘all ok’를 출력하고, 그렇지 않으면 ‘fail!’을 출력합니다.&lt;br /&gt;
 세 번째 명령어는 모든 bam 파일 확인 후, 비정상 bam 파일 목록은 bad_bams.fofn 에 저장하며, 모두 정상이라면 ‘all ok’를 출력하고, 그렇지 않으면 ‘fail!’을 출력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;fastq&lt;br /&gt;
 bam 파일을 fastq 로 바꿔주는 명령어입니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;pre&gt;&lt;code&gt;samtools fastq example.bam -o example.fastq&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;만약 paired-end sequencing 데이터라면 read1, read2 파일을 따로 지정해주면 됩니다.&lt;br /&gt;
 이 때, 두 개의 fastq 파일에 같은 read 순서로 만들고 싶다면 먼저 collate 혹은 sort -n 으로 나열되어 있어야 합니다.&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;samtools fastq example.bam -1 example_1.fastq -2 example_2.fastq -0 example_0.fastq&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;이 때, read1, read2 이외의 read 들은 standard out으로 출력이 될 겁니다. 어마어마한 reads 들이 출력되기 때문에, 만약 출력하고 싶지 않다면 -0 [파일이름] 으로 지정해주셔야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;fasta&lt;br /&gt;
 bam 파일을 fasta 로 바꿔주는 명령어입니다.&lt;br /&gt;
 매뉴얼에서는 samtools fastq 와 samtools fasta 를 같이 설명하고 있군요!&lt;br /&gt;
 fastq 에서와 마찬가지로 read1, read2, other reads 를 구분해서 쓰시면 되겠습니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;pre&gt;&lt;code&gt;samtools fasta example.bam -o example.fasta
samtools fasta example.bam -1 example_1.fasta -2 example_2.fasta -0 example_0.fasta&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;statistics-bam-파일의-통계치를-확인하고-싶을-때&quot;&gt;Statistics: bam 파일의 통계치를 확인하고 싶을 때&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;bedcov&lt;br /&gt;
 특정 영역에 대해서 read base count 를 세어주는 명령어 입니다.&lt;br /&gt;
 read base count 는 the sum of per base read depths, 즉 mapping 된 총 base 수를 합친 값입니다.&lt;br /&gt;
 영역은 bed 파일로 지정해주면 되고, 각 영역별 read base count 를 세어줍니다.&lt;br /&gt;
 다음 명령어로 실행합니다.
    &lt;pre&gt;&lt;code&gt;&amp;gt; cat example.bed # 이 형태의 bed 파일을 사용한다고 하면...
20	60000	70000
20	70000	80000
20	80000	100000
&amp;gt; samtools bedcov example.bed example.bam # 이 명령어로 아래와 같은 결과가 나옵니다.
20	60000	70000	51006
20	70000	80000	163986
20	80000	100000	51060&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;coverage&lt;br /&gt;
 특정 영역에 대해서 read coverage 를 표시한 histogram 을 만들어주는 명령어 입니다.&lt;br /&gt;
 아래 명령어로 실행합니다.
    &lt;pre&gt;&lt;code&gt;&amp;gt; samtools coverage -r 20:100000-200000 example.bam
#rname	startpos	endpos	numreads	covbases	coverage	meandepth	meanbaseq	meanmapq
20	100000	200000	7577	87538	87.5371	5.32686	33.7	54.3
&amp;gt; samtools coverage -r 20:100000-200000 -m example.bam
20 (63.03Mbp)
&amp;gt;  88.57% │ ▆▃  ▄▂▄     ▄▃▁▄▆     ▃█ ▃▁  ▆▅▂▃     ▄ ▃▃  ▄▃  ▄  ▁  ▂▄  █▂│ Number of reads: 7577
&amp;gt;  78.73% │▅███▁███▅▆ ▇▂█████▂▂  ▃██▆██ █████▇▅▆▅▅████▆███▄▄█▂▃█  ██ ▂██│     (887 filtered)
&amp;gt;  68.89% │██████████ █████████▄▇███████████████████████████████▅▄██▄███│ Covered bases:   87.5Kbp
&amp;gt;  59.05% │█████████████████████████████████████████████████████████████│ Percent covered: 87.54%
&amp;gt;  49.21% │█████████████████████████████████████████████████████████████│ Mean coverage:   5.33x
&amp;gt;  39.37% │█████████████████████████████████████████████████████████████│ Mean baseQ:      33.7
&amp;gt;  29.52% │█████████████████████████████████████████████████████████████│ Mean mapQ:       54.3
&amp;gt;  19.68% │█████████████████████████████████████████████████████████████│
&amp;gt;   9.84% │█████████████████████████████████████████████████████████████│ Histo bin width: 1.6Kbp
&amp;gt;   0.00% │█████████████████████████████████████████████████████████████│ Histo max bin:   98.414%
     100.0K    116.4K    132.8K    149.2K    165.6K    181.9K     200.0K&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;어떤 옵션이 있는지 살펴볼까요?&lt;br /&gt;
 -r [chromosome:start-end]: -r 옵션으로 영역을 지정해줄 수 있고, 영역을 지정해주지 않으면 모든 chromosome 에 대한 결과를 각각 만들어서 제공해줍니다.&lt;br /&gt;
 -m : table 형태의 결과 대신 histogram 을 보여줍니다.&lt;br /&gt;
 -w [bin 개수]: historgram 을 몇 개의 bin 으로 나눠서 보여줄지 결정합니다. &lt;br /&gt;
 -o [output 파일]: 결과를 output 파일에 저장합니다.&lt;br /&gt;
 -b [bam 목록 파일]: 여러 bam 파일을 사용할 때, bam 파일들의 이름이 적힌 목록 파일을 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;depth&lt;br /&gt;
 지정해준 영역 혹은 position 에 대해 read depth 를 계산해줍니다.&lt;br /&gt;
 영역은 bed 파일로 제시해주면 되는데요, 만약 제공하지 않으면 bam 파일이 걸친 모든 영역의 &lt;strong&gt;position 마다&lt;/strong&gt; 결과를 제공합니다.&lt;br /&gt;
 그럼 매우 큰 결과가 나오게 되니 주의해주세요!&lt;br /&gt;
 다음 명령어를 사용합니다:
    &lt;pre&gt;&lt;code&gt;samtools depth -b example.bed example.bam -o example_depth.txt&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;옵션들을 한번 살펴보시죠.&lt;br /&gt;
 -a : 모든 position 에 대해 결과를 제공합니다. 이는 depth 가 0 인 position 도 포함합니다.&lt;br /&gt;
 -aa : 사용하지 않은 reference sequence에 있는 영역까지, 정말 전체 영역에 대한 결과를 모두 제공합니다.&lt;br /&gt;
 -b [bed 파일]: 결과를 만들 영역을 bed 파일로 제시해줍니다.&lt;br /&gt;
 -f [bam 목록파일]: 여러 bam 파일을 사용할 때, 파일 이름을 목록으로 만들어 제시합니다.&lt;br /&gt;
 -o [output 파일]: 결과를 output 파일에 저장합니다.&lt;br /&gt;
 -g [flags]: 특정 flag 를 가진 read 는 제외합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;flagstat&lt;br /&gt;
 bam 파일의 기본적인 상태를 보여줍니다.&lt;br /&gt;
 주로 몇 개의 read 중 몇 개가 mapping 되었는지 등의 결과를 확인하고자 할 때 쓰입니다.&lt;br /&gt;
 설명하기 보다, 아래 결과를 보시면 더욱 이해가 쉬우실 겁니다!
    &lt;pre&gt;&lt;code&gt;&amp;gt; samtools flagstat example.bam
4579959 + 0 in total (QC-passed reads + QC-failed reads)
0 + 0 secondary
0 + 0 supplementary
371078 + 0 duplicates
4532991 + 0 mapped (98.97% : N/A)
4569463 + 0 paired in sequencing
2284756 + 0 read1
2284707 + 0 read2
4413160 + 0 properly paired (96.58% : N/A)
4475527 + 0 with itself and mate mapped
46968 + 0 singletons (1.03% : N/A)
21515 + 0 with mate mapped to a different chr
15292 + 0 with mate mapped to a different chr (mapQ&amp;gt;=5)&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;idxstats&lt;br /&gt;
 bam 파일의 통계 결과를 index 파일에서 찾아 출력해줍니다.&lt;br /&gt;
 즉, 이 명령어를 쓰기 위해서는 samtools index 가 선행되어야 합니다.&lt;br /&gt;
 결과는 다음 네 개의 컬럼으로 나옵니다.&lt;br /&gt;
 1) reference sequence name, 2)sequence length, 3) # mapped read-segments, 4)# unmapped read-segments&lt;br /&gt;
 다음 명령어로 실행합니다.
    &lt;pre&gt;&lt;code&gt;&amp;gt; samtools idxstats example.bam
1	249250621	0	0
2	243199373	0	0
...
19	59128983	0	0
20	63025520	4532991	46968
21	48129895	0	0
22	51304566	0	0&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;20번 염색체에 대한 bam 파일을 가져와서 결과가 하나밖에 안나오는군요.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;여기까지 samtools 설치부터 indexing, editing 까지 살펴보았습니다.&lt;br /&gt;
명령어가 무척 많아서 한 글에서 다 다루기 힘들군요.&lt;br /&gt;
앞으로 시간이 더 남으면 뒷부분을 추가해보도록 하겠습니다.&lt;br /&gt;
samtools view, flagstat 등 유용하게 쓰이는 명령어들이 매우 많거든요.&lt;br /&gt;
그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2020/10/18/samtools.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2020/10/18/samtools.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>ACMG class 를 수치로 표현하는 방법 - bayesian score 및 ACMG class 계산기</title>
        <description>&lt;p&gt;안녕하세요. 한헌종입니다.&lt;br /&gt;
오늘은 지난번에 이어, ACMG pathogenicity class 의 수치적 표현에 대한 이야기를 하려 합니다.&lt;br /&gt;
글 맨 아래에는 ACMG evidence 조합에 따라 class 와 bayesian score를 구할 수 있는 계산기를 만들어 보았으니 한번 참고해보세요!&lt;/p&gt;

&lt;p&gt;아래 내용은 다음 논문을 참조해서 작성했습니다:&lt;br /&gt;
Tavtigian, Sean V et al. “Modeling the ACMG/AMP variant classification guidelines as a Bayesian classification framework.” Genetics in medicine : official journal of the American College of Medical Genetics vol. 20,9 (2018): 1054-1060. doi:10.1038/gim.2017.210&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;acmg-class-가-뭐더라&quot;&gt;ACMG class 가 뭐더라&lt;/h3&gt;

&lt;p&gt;지난번에 말씀드린 대로, ACMG/AMP guideline에 따라 각 유전변이의 pathogenicity를 판별할 수 있습니다.&lt;br /&gt;
규칙에 따라 여러 evidence를 할당하고, 그 결과를 조합해 5가지 class 중 하나를 규정하는 방식이죠.&lt;br /&gt;
5가지 class는 다음과 같습니다: Pathogenic, Likely pathogenic, vairiant of uncertain significance, Likely benign, Benign.&lt;br /&gt;
이를 줄여서 P, LP, VUS, LB, B 로 간단히 나타내기도 합니다.&lt;/p&gt;

&lt;p&gt;ACMG guideline을 따르면 pathogenicity를 어느정도 가늠할 수 있게 됩니다.&lt;br /&gt;
그러나 연구자들은 이를 ‘수치적’으로 나타내기를 원했습니다.&lt;br /&gt;
이를 위해 연구자들은 Bayesian framework 를 사용해 수치화 하는 방법을 강구해냅니다.&lt;br /&gt;
바로 다음 식처럼 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201011/figure1.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Bayesian framework에 따라서, 먼저 알고 있는 prior probability를 여러 조건부확률을 사용해 posterior probability를 계산하는 방식입니다.&lt;br /&gt;
이 식을 사용하면 특정 변이의 pathogenicity를 0~1 사이의 값으로 나타낼 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;물론, 결국엔 ACMG guideline 조합에 따른 5가지 class를 사용해서 변이를 설명해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;어떻게-계산하는-건가요&quot;&gt;어떻게 계산하는 건가요?&lt;/h3&gt;
&lt;p&gt;그럼 식에 대해 좀더 알아보겠습니다.&lt;br /&gt;
위의 공식은 밑에 있는 일반적인 베이즈 규칙에 따라 만들어졌습니다:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201011/figure2.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;여기서 P(A) 가 prior probability, 즉 the probability of pathogenicity 가 됩니다.&lt;br /&gt;
변이가 병원성을 가질 확률이죠.&lt;br /&gt;
P(B)는 the probability of the evidence for pathogenicity 입니다.&lt;br /&gt;
P(A|B) 가 여기서 posterior probability 가 되는데요,&lt;br /&gt;
그 의미는 the probability of pathogenicity given the evidence 즉 주어진 evidence들에 대해 이 변이가 병원성을 가질 확률입니다.&lt;br /&gt;
P(B|A) 는 the probability of the evidence, given that the variant is pathogenic, 즉 pathogenic 변이가 주어졌을 때 각 evidence를 가질 확률입니다.&lt;/p&gt;

&lt;p&gt;여기서 prior는 0.1을 기본값으로 사용합니다.&lt;br /&gt;
이는 논문에서 제시한 값으로써, 유전자 패널 등에서 병원성 변이를 발견하게 될 확률을 경험적으로 나타낸 것이라고 하는군요.&lt;/p&gt;

&lt;h3 id=&quot;odds_path-는-어떻게-구하는거죠&quot;&gt;Odds_Path 는 어떻게 구하는거죠?&lt;/h3&gt;

&lt;p&gt;Odds_Path 는 odds of pathogenicity 를 나타냅니다.&lt;br /&gt;
이는 evidence categories 들을 설명하는 방향으로 만들어졌습니다.&lt;br /&gt;
그래서 이 값이 1 보다 크면 pathogenic evidence가 많다는 것이고, 1보다 작으면 benign evidence 가 많다는 것을 의미입니다.&lt;br /&gt;
이 Odds_Path 는 다음 식으로 구해집니다:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201011/figure3.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;설명드리자면, Odds_Path 는 PVS evidence 의 odds 값을 ‘특정 값’으로 제곱해서 계산합니다.&lt;br /&gt;
그 ‘특정 값’ 은 각 evidence 의 개수를 활용해 만들어집니다.&lt;br /&gt;
예를 들어, NPSu 는 pathogenic-supporting evidence의 개수를 말합니다.&lt;/p&gt;

&lt;p&gt;이 evidence의 개수는 그 strength에 따라서 2배씩 줄어들도록 보정이 되는데요,&lt;br /&gt;
그 결과 very strong evidence 한개의 영향력은 strong evidence 두 개의 영향력과 같게 됩니다.&lt;br /&gt;
(여기서의 그 ‘두 배’ 라는 값도 역시 논문에서 정해준 값입니다.)&lt;/p&gt;

&lt;p&gt;또한 pathogenic evidence 개수는 덧셈, benign evidence는 뺄셈으로 사용해서 결과값을 보정하고 있습니다.&lt;br /&gt;
Benign evidence 가 많으면 odds_path 가 1 이하로 떨어지겠죠?&lt;/p&gt;

&lt;p&gt;여기서, O(PVSt) 즉 the odds of very strong pathogenicity 는 논문에서 350으로 제시하고 있습니다.&lt;br /&gt;
이렇게 해서 Odds_path 를 구하는 방식을 알아보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;그럼-이-값이-뭘-뜻하나요&quot;&gt;그럼 이 값이 뭘 뜻하나요?&lt;/h3&gt;
&lt;p&gt;결국 Bayesian score를 구하기 위해서는 다음 두 단계를 거치면 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Odds_Path 를 evidence 개수를 사용해 구한다.&lt;/li&gt;
  &lt;li&gt;Posterior probability를 bayesian framework에 따라 계산한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 제시한 O(PVSt)=350, Prior=0.1 를 사용하면 다음과 같은 현상이 나타납니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt;= 0.99 : &lt;strong&gt;Pathogenic&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.99 &amp;gt; &lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt;= 0.90 : &lt;strong&gt;Likely pathogenic&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.90 &amp;gt; &lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt; 0.1 : &lt;strong&gt;VUS&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.1 &amp;gt;= &lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt; 0.001 : &lt;strong&gt;Likely benign&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.001 &amp;gt;= &lt;strong&gt;Post_P&lt;/strong&gt; : &lt;strong&gt;Benign&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉 Bayesian score 가 pathogenicity를 나타낼 수 있게 된 거죠.&lt;br /&gt;
높을 수록 Pathogenic 변이이며, 특정 값을 넘는지를 통해 class 도 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 이 공식으로 구해진 bayesian score는 완벽하지 않아서, 여러 예외상황이 발생하기도 합니다.&lt;br /&gt;
예를 들어 class 는 VUS 로 분류되지만 bayesian score 는 0.9를 넘는 경우가 발생하기도 하죠.&lt;br /&gt;
bayesian score는 설명을 돕기 위한 점수일 뿐이고, 결국 ACMG class 를 중점적으로 봐야한답니다.&lt;/p&gt;

&lt;h3 id=&quot;acmg-class-계산기&quot;&gt;ACMG class 계산기&lt;/h3&gt;
&lt;p&gt;js 를 사용해서 ACMG class 계산기를 만들어보았습니다.&lt;br /&gt;
해당하는 rule을 클릭해서 조합을 만들면, 밑부분의 결과에 ACMG class 와 bayesian score가 계산되어 나타납니다.&lt;br /&gt;
한번 직접 사용해보세요!&lt;/p&gt;
&lt;style&gt;
    table {
        border-collapse: collapse;
        margin: 10px 0px;
    }
    tr {
        padding: 0px 5px;
    }
    td {
        padding: 0px 5px;
        text-align: center;
    }
    input {
        text-align: center;
        border: none;
        font-size:24px;
    }
    input:focus {
        outline: none;
    }
    .rulebox {
        cursor:pointer;
    }
    .rulebox:hover {
        background-color: gray;
        opacity: 0.7;
    }
    .reset {
        cursor:pointer;
    }
    .reset:hover {
        background-color: gray;
        opacity: 0.7;
    }
    .rule_on{
        box-sizing: border-box;
        outline-offset: -2px;
        outline: solid 2px green;
    }
&lt;/style&gt;

&lt;h2&gt;ACMG class calculator&lt;/h2&gt;
&lt;p&gt;made by HJHan&lt;/p&gt;
&lt;h3&gt;click rules below:
&lt;table border=&quot;1&quot; style=&quot;width:100%;&quot;&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PVS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PVS1')&quot;&gt;PVS1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS1')&quot;&gt;PS1&lt;/td&gt;
        &lt;td id=&quot;PS2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS2')&quot;&gt;PS2&lt;/td&gt;
        &lt;td id=&quot;PS3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS3')&quot;&gt;PS3&lt;/td&gt;
        &lt;td id=&quot;PS4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS4')&quot;&gt;PS4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PM1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM1')&quot;&gt;PM1&lt;/td&gt;
        &lt;td id=&quot;PM2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM2')&quot;&gt;PM2&lt;/td&gt;
        &lt;td id=&quot;PM3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM3')&quot;&gt;PM3&lt;/td&gt;
        &lt;td id=&quot;PM4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM4')&quot;&gt;PM4&lt;/td&gt;
        &lt;td id=&quot;PM5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM5')&quot;&gt;PM5&lt;/td&gt;
        &lt;td id=&quot;PM6&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM6')&quot;&gt;PM6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PP1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP1')&quot;&gt;PP1&lt;/td&gt;
        &lt;td id=&quot;PP2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP2')&quot;&gt;PP2&lt;/td&gt;
        &lt;td id=&quot;PP3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP3')&quot;&gt;PP3&lt;/td&gt;
        &lt;td id=&quot;PP4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP4')&quot;&gt;PP4&lt;/td&gt;
        &lt;td id=&quot;PP5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP5')&quot;&gt;PP5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;BS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS1')&quot;&gt;BS1&lt;/td&gt;
        &lt;td id=&quot;BS2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS2')&quot;&gt;BS2&lt;/td&gt;
        &lt;td id=&quot;BS3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS3')&quot;&gt;BS3&lt;/td&gt;
        &lt;td id=&quot;BS4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS4')&quot;&gt;BS4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;BP1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP1')&quot;&gt;BP1&lt;/td&gt;
        &lt;td id=&quot;BP2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP2')&quot;&gt;BP2&lt;/td&gt;
        &lt;td id=&quot;BP3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP3')&quot;&gt;BP3&lt;/td&gt;
        &lt;td id=&quot;BP4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP4')&quot;&gt;BP4&lt;/td&gt;
        &lt;td id=&quot;BP5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP5')&quot;&gt;BP5&lt;/td&gt;
        &lt;td id=&quot;BP6&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP6')&quot;&gt;BP6&lt;/td&gt;
        &lt;td id=&quot;BP7&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP7')&quot;&gt;BP7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&quot;reset&quot; colspan=&quot;7&quot; onclick=&quot;reset()&quot;&gt;Reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Class&lt;/td&gt;
        &lt;td id=&quot;acmgclass&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt;
        &lt;td&gt;Score&lt;/td&gt;
        &lt;td id=&quot;score&quot; colspan=&quot;2&quot; style=&quot;width:150px;&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/h3&gt;

&lt;script&gt;
    function reset(){
        document.getElementById('acmgclass').innerHTML = &quot;&quot;;
        document.getElementById('score').innerHTML = &quot;&quot;;
        var rulebuttons = document.getElementsByClassName(&quot;rulebox&quot;);
        for(var i=0; i&lt;rulebuttons.length; i++){
            rulebuttons[i].classList.remove(&quot;rule_on&quot;);
        }
    }

    // on/off color
    function rule_button(rule_id) {
        var element = document.getElementById(rule_id);
        element.classList.toggle(&quot;rule_on&quot;);
        update_res();
    }

    function update_res(){
        var cnt = 0;
        var pvs = 0;
        var ps = 0;
        var pm = 0;
        var pp = 0;
        var bs = 0;
        var bp = 0;
        var rulebuttons = document.getElementsByClassName(&quot;rulebox&quot;);
        for(var i=0; i&lt;rulebuttons.length; i++){
            var cond = rulebuttons[i].classList.contains(&quot;rule_on&quot;)
            if(cond){
                var rule_str = rulebuttons[i].id.substring(0,2);
                if(rule_str == &quot;PV&quot;){pvs += 1;}
                else if(rule_str == &quot;PS&quot;){ps += 1;}
                else if(rule_str == &quot;PM&quot;){pm += 1;}
                else if(rule_str == &quot;PP&quot;){pp += 1;}
                else if(rule_str == &quot;BS&quot;){bs += 1;}
                else if(rule_str == &quot;BP&quot;){bp += 1;}
            }
        }
        // update result
        var combined = combine_rule(pvs, ps, pm, pp, bs, bp);
        document.getElementById('acmgclass').innerHTML = combined;
        var b_score = cal_bayesian(pvs, ps, pm, pp, bs, bp);
        document.getElementById('score').innerHTML = b_score;
    }

    function combine_rule(pvs, ps, pm, pp, bs, bp){
        var class_res = &quot;VUS&quot;;
        if(pvs &gt;= 1){
            if(pvs &gt;= 2 || ps &gt;= 1 || pm &gt;= 2 || (pm == 1 &amp;&amp; pp == 1) || pp &gt;= 2){
                class_res = &quot;Pathogenic&quot;
            }else if(pvs == 1 &amp;&amp; pm &gt;= 1){
                class_res = &quot;Likely pathogenic&quot;
            }
        }else if(ps &gt;= 2){
                class_res = &quot;Pathogenic&quot;
        }else if(ps == 1){
            if(pm &gt;= 3 || (pm == 2 &amp;&amp; pp &gt;= 2) || (pm == 1 &amp;&amp; pp &gt;= 4)){
                class_res = &quot;Pathogenic&quot;
            }else if(pm &gt;= 1 || pp &gt;= 2){
                class_res = &quot;Likely pathogenic&quot;
            }
        }else if(pm &gt;= 3 || (pm == 2 &amp;&amp; pp &gt;= 2) || (pm == 1 &amp;&amp; pp &gt;= 4)){
            class_res = &quot;Likely pathogenic&quot;
        }
        // if the result is not &quot;VUS&quot; then break. pathogenic first.
        if(class_res !== &quot;VUS&quot;){
            return class_res
        }
        if(bs &gt;= 2){
            class_res = &quot;Benign&quot;;
        }else if((bs == 1 &amp;&amp; bp == 1) || bp &gt;= 2){
            class_res = &quot;Likely benign&quot;;
        }
        return class_res
    }

    function cal_bayesian(pvs, ps, pm, pp, bs, bp){
        var prior = 0.1;
        var odd_base = 350;
        var oddsPath = odd_base ** (pvs + ps/2 + pm/4 + pp/8 - bs/2 - bp/8)
        var res = oddsPath * prior / ((oddsPath - 1) * prior + 1)
        res = Number.parseFloat(res).toPrecision(5);
        return res
    }
&lt;/script&gt;

&lt;hr /&gt;

&lt;p&gt;지금까지 ACMG class 를 수치화 하는 bayesian framework 를 살펴보았습니다.&lt;br /&gt;
더욱 자세한 내용은 맨 위에 말씀드린 논문에서 찾아볼 수 있습니다.&lt;br /&gt;
그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/clinical%20genomics/tech/2020/10/11/calculating-ACMG-class.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/clinical%20genomics/tech/2020/10/11/calculating-ACMG-class.html</guid>
        
        
        <category>biology</category>
        
        <category>clinical genomics</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>ACMG guideline 이란 무엇일까</title>
        <description>&lt;h3 id=&quot;acmg-guideline-이란-무엇일까&quot;&gt;ACMG guideline 이란 무엇일까&lt;/h3&gt;
&lt;p&gt;안녕하세요. 한헌종입니다.&lt;br /&gt;
오늘은 임상유전학 분야에서 거의 교과서처럼 쓰이고 있는 ACMG guideline에 대해 알아보려 합니다.&lt;br /&gt;
작성한 내용은 다음 논문을 참조해서 작성했습니다:&lt;br /&gt;
Richards, Sue et al. “Standards and guidelines for the interpretation of sequence variants: a joint consensus recommendation of the American College of Medical Genetics and Genomics and the Association for Molecular Pathology.” Genetics in medicine : official journal of the American College of Medical Genetics vol. 17,5 (2015): 405-24. doi:10.1038/gim.2015.30&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;환자의 유전 질환을 진단하려면 어디서부터 시작해야 할까요?&lt;br /&gt;
먼저 환자의 샘플을 채취하고, 시퀀싱 실험을 통해 환자의 DNA 염기서열을 알아내야겠죠.&lt;br /&gt;
그 다음 Reference genome 과 비교해 환자에게 어떤 돌연변이 (variants) 가 나타났는지 알아내야 합니다.&lt;br /&gt;
만약 환자에게서 기존에 알려진 유전병의 원인이 되는 변이가 발견된다면, 그 환자의 질병과 원인에 대해 알아낼 수 있겠죠.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/figure1.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;환자에게서 변이를 찾는 과정&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;문제는, 한명의 환자에게서 발견되는 돌연변이가 매우 많다는 것입니다.&lt;br /&gt;
Whole exome sequencing 실험을 통해 얻은 데이터를 살펴보면, 한 환자마다 약 7만~8만 개의 변이가 나타난다는 사실을 알 수 있습니다.&lt;br /&gt;
이렇게 많은 변이들 중에서 단 몇 개의 변이만 환자의 질병을 일으킵니다.&lt;br /&gt;
그럼 나머지 변이들은 뭘까요? 대부분의 변이는 질환과 상관없거나, 개인마다 그 위험성이 다르기 때문에 질병에 영향을 주지 않는 경우입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이렇게 많은 변이들 중 ‘실제로’ 질병을 일으키는 변이를 어떻게 찾아낼 수 있을까요?&lt;br /&gt;
그 방법을 고안하기 위해 각지에서 전문가들이 모였습니다:&lt;br /&gt;
American College of Medical Genetics and Genomics,&lt;br /&gt;
Association for Molecular Pathology,&lt;br /&gt;
College of American Pathologist 에서 말이죠.&lt;br /&gt;
이렇게 모인 전문가들이 고안해낸 지침서가 바로 ACMG/AMP guideline 입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/ACMG_main.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;2015년에 출판된 ACMG/AMP guidelines 논문. 보통 줄여서 ACMG guideline 이라고 합니다.&lt;br /&gt;DOI: 10.1038/gim.2015.30&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;그래서-acmg-guideline-이-뭐라구요&quot;&gt;그래서 ACMG guideline 이 뭐라구요?&lt;/h3&gt;
&lt;p&gt;한 마디로 변이의 ‘병원성’ (pathogenicity) 를 판단하는 기준들 입니다.&lt;br /&gt;
물론 위의 논문을 읽어보시면, 변이 판별 외에도 사용되는 용어, 명명법, 사용하는 데이터베이스에 대한 설명, 변이를 보고할 때의 고려사항 등 세부적인 내용이 많이 포함되어 있습니다.&lt;br /&gt;
(이 부분들 역시 그리 간단하지가 않습니다..)&lt;br /&gt;
오늘은 그 내용 중에서도, 변이를 판단하는 기준에 집중해볼까요?&lt;/p&gt;

&lt;p&gt;변이에 대한 판별은 두 단계로 나누어집니다.&lt;br /&gt;
&lt;strong&gt;첫 번째 단계는 Evidence 를 할당하는 과정,&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;두 번째 단계는 Pathogenicity 를 구분하는 과정입니다.&lt;/strong&gt;&lt;br /&gt;
이 과정을 거치게 되면, 이중 어떤 변이가 정말로 병을 일으킬 만한지 알 수 있게 됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure2.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;첫 번째 단계를 먼저 살펴볼까요?&lt;br /&gt;
어떤 변이에 대해 evidence 를 할당한다는 것은, 다시 말해서 병원성에 대한 증거를 붙여놓는 것입니다.&lt;br /&gt;
이를 위해서 ACMG guideline 에서는 &lt;strong&gt;28 개의 ‘규칙 (rules)’&lt;/strong&gt; 들을 정해놓았습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure3.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 규칙들은 크게 병원성/비병원성 (Pathogenic/benign) 으로 나뉩니다.&lt;br /&gt;
또한 그 경중에 따라 크게 4가지로 나뉩니다. (Very strong/Strong/Moderate/Supporting)&lt;br /&gt;
예를 들어서, PS3 rule 은 특정 변이가 Pathogenic 하다는 것에 관련된 rule 중 하나이며, 그 강도가 Strong 으로 매우 강력합니다.&lt;br /&gt;
BP7 rule 은 특정 변이가 Benign 하다는 것에 관련된 규칙이고, 그 강도가 Supporting으로 약합니다.&lt;br /&gt;
이 규칙들에 따라서 특정 변이에 대해서 evidence 들을 할당하는 과정이 첫 번째 단계라고 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;그런데-대체-그-rule-이-뭐죠&quot;&gt;그런데 대체 그 rule 이 뭐죠?&lt;/h3&gt;
&lt;p&gt;아래 그림에 28개 rule에 대한 설명 중 일부를 가져와봤습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure4.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예를 들어, PS3 evidence 다음과 같은 경우에 할당한다고 하네요:&lt;br /&gt;
PS3: Well-established in vitro or in vivo functional studies supportive of a damaging effect on the gene or gene &lt;br /&gt;
product&lt;br /&gt;
즉, in vitro/in vivo 실험을 통해 특정 변이가 유전자에 손상을 줄 수 있다는 연구가 제시된 경우, 그 변이에 PS3를 할당할 수 있습니다.&lt;br /&gt;
한 변이가 여러 규칙에 해당된다면, 여러 evidence 들을 할당할 수도 있는거죠.&lt;br /&gt;
이렇게 각 규칙에 따라서 변이에 여러가지 evidence 들을 적용하는 과정을 거치면, 1단계가 완성됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;두 번째 단계를 살펴볼까요?&lt;br /&gt;
변이에 대해 evidence들을 할당하고 나면, 어떤 변이들은 Pathogenic evidence를 매우 많이 가지고 있을 수도 있습니다.&lt;br /&gt;
혹은 몇몇 강력한 evidence를 가지고 있는 변이도 있겠죠.&lt;br /&gt;
이 evidence를 종합적으로 판단해서 변이를 다섯 등급 중 하나로 구분합니다:&lt;br /&gt;
Pathogenic, Likely pathogenic, Uncertain signifiacne, Likely benign, Benign&lt;/p&gt;

&lt;p&gt;사실 각 evidence를 정량적으로 판단할 수는 없지만, ACMG guideline에서 방법을 제시하고 있습니다.&lt;br /&gt;
예를 들어 Pathogenic strong evidence 를 두 개 가지고 있는 변이는 마침내 ‘Pathogenic’ 변이로 구분될 수 있습니다.&lt;br /&gt;
이렇게 evidence 들의 조합으로 변이가 정말 pathogenic 인지 확인하는 과정이 바로 두 번째 단계입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/figure5.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;논문에서 발췌한 Pathogenicity class 구분표 입니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;이렇게 ACMG guidelines 의 일부분을 살펴보았습니다.&lt;br /&gt;
물론 이렇게 변이의 pathogenicity를 구분한 뒤에도, 아직도 매우 많은 변이가 Pathogenic 하다고 나올 수 있습니다.&lt;br /&gt;
또한, Pathogenic 으로 구분된 변이라고 무조건 질병을 일으킨다는 보장이 없으며, Uncertain 변이로 구분되었다고 해서 질병과 상관없다고 단정지을 수도 없습니다.&lt;br /&gt;
그리고 실제 진단까지 가려면 이 뿐만 아니라 환자의 증상이나 가족력 등 더 자세한 정보가 필요할 것입니다.&lt;br /&gt;
그럼에도 불구하고, 적어도 선택해야 할 변이의 수를 줄여줄 뿐만 아니라 그 변이들에 대한 설명을 제시해준다는 점에서 ACMG guideline은 큰 의미를 가진다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;오늘도 매우 어려운 내용의 겉핥기를 해보았습니다.&lt;br /&gt;
ACMG guidelines 는 2015년에 나온 이후로 계속 발전하고 있습니다.&lt;br /&gt;
향후 이런 내용에 대해서도 나중에 자세히 다뤄볼까 합니다.&lt;/p&gt;

&lt;p&gt;그럼 여러분, 다음 글에서 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/clinical%20genomics/2020/09/27/ACMG-guideline-2015.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/clinical%20genomics/2020/09/27/ACMG-guideline-2015.html</guid>
        
        
        <category>biology</category>
        
        <category>clinical genomics</category>
        
      </item>
    
      <item>
        <title>파일 형식을 알아보자! 두번째 (VCF, BED, GTF, GFF)</title>
        <description>&lt;h3 id=&quot;생명정보학-분석에서-자주-만나는-파일-형식을-알아봅시다-2&quot;&gt;생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다 (2)&lt;/h3&gt;

&lt;p&gt;안녕하세요, 한헌종입니다.&lt;br /&gt;
오늘은 저번 포스팅에 이어서 생명정보학 분야에서 자주 만나게 되는 파일 형식을 알아보려 합니다.&lt;br /&gt;
오늘은 VCF, BED, GTF, GFF를 알아봅시다.&lt;/p&gt;

&lt;h3 id=&quot;vcf-variant-call-format&quot;&gt;VCF (Variant Call Format)&lt;/h3&gt;

&lt;p&gt;VCF 파일은 Variants 즉 변이 정보를 기록할 때 사용되는 형식입니다.&lt;br /&gt;
Genome 상에서 어느 위치에 원래는 어떤 서열인데 어떤 유전변이가 일어난건지, genotype은 무엇인지에 대한 정보를 가지고 있죠.&lt;br /&gt;
이 VCF 파일 형식은 1000 genome project와 같이 대규모 시퀀싱 프로젝트가 진행되면서 만들어졌다고 해요.&lt;br /&gt;
VCF 파일은 아래와 같이 생겼습니다. 크게 두 부분으로 나뉘어져 있죠. header 와 body 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##fileformat=VCFv4.3
##fileDate=20090805
##source=myImputationProgramV3.1
##reference=file:///seq/references/1000GenomesPilot-NCBI36.fasta
##contig=&amp;lt;ID=20,length=62435964,assembly=B36,md5=f126cdf8a6e0c7f379d618ff66beb2da,species=&quot;Homo sapiens&quot;,taxonomy=x&amp;gt;
##phasing=partial
##INFO=&amp;lt;ID=NS,Number=1,Type=Integer,Description=&quot;Number of Samples With Data&quot;&amp;gt;
##INFO=&amp;lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&amp;gt;
##INFO=&amp;lt;ID=AF,Number=A,Type=Float,Description=&quot;Allele Frequency&quot;&amp;gt;
##INFO=&amp;lt;ID=AA,Number=1,Type=String,Description=&quot;Ancestral Allele&quot;&amp;gt;
##INFO=&amp;lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&amp;gt;
##INFO=&amp;lt;ID=H2,Number=0,Type=Flag,Description=&quot;HapMap2 membership&quot;&amp;gt;
##FILTER=&amp;lt;ID=q10,Description=&quot;Quality below 10&quot;&amp;gt;
##FILTER=&amp;lt;ID=s50,Description=&quot;Less than 50% of samples have data&quot;&amp;gt;
##FORMAT=&amp;lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&amp;gt;
##FORMAT=&amp;lt;ID=GQ,Number=1,Type=Integer,Description=&quot;Genotype Quality&quot;&amp;gt;
##FORMAT=&amp;lt;ID=DP,Number=1,Type=Integer,Description=&quot;Read Depth&quot;&amp;gt;
##FORMAT=&amp;lt;ID=HQ,Number=2,Type=Integer,Description=&quot;Haplotype Quality&quot;&amp;gt;
#CHROM POS      ID         REF   ALT    QUAL  FILTER   INFO                             FORMAT       NA00001         NA00002          NA00003
20     14370    rs6054257  G     A      29    PASS    NS=3;DP=14;AF=0.5;DB;H2           GT:GQ:DP:HQ  0|0:48:1:51,51  1|0:48:8:51,51   1/1:43:5:.,.
20     17330    .          T     A      3     q10     NS=3;DP=11;AF=0.017               GT:GQ:DP:HQ  0|0:49:3:58,50  0|1:3:5:65,3     0/0:41:3
20     1110696  rs6040355  A     G,T    67    PASS    NS=2;DP=10;AF=0.333,0.667;AA=T;DB GT:GQ:DP:HQ  1|2:21:6:23,27  2|1:2:0:18,2     2/2:35:4
20     1230237  .          T     .      47    PASS    NS=3;DP=13;AA=T                   GT:GQ:DP:HQ  0|0:54:7:56,60  0|0:48:4:51,51   0/0:61:2
20     1234567  microsat1  GTC   G,GTCT 50    PASS    NS=3;DP=9;AA=G                    GT:GQ:DP     0/1:35:4        0/2:17:2         1/1:40:3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;VCF 파일의 예시. header 20줄과 body 6줄로 이루어져 있군요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;header&lt;/strong&gt; 는 샵 두개 (##)으로 시작하는 VCF의 가장 윗부분을 말합니다.&lt;br /&gt;
header 부분은 VCF 파일의 전반적인 정보를 가지고 있습니다.&lt;br /&gt;
파일 형식, 날짜, 그리고 body의 INFO/FORMAT column에서 사용되는 단어들에 대한 설명이 포함되어 있죠.&lt;br /&gt;
예를 들어 body 의 INFO column에 있는 정보 중 NS=3 이란 정보가 있는데, header의 설명을 보면 INFO=&amp;lt;ID=NS, … Description=”Number of Samples With Data”&amp;gt; 라고 되어있으니 NS가 샘플 수라는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt; 부분은 샵 하나 (#)로 시작하는 컬럼 제목부분과 실제 데이터부분으로 되어있습니다.&lt;br /&gt;
body에는 꼭 들어가야 하는 8개의 컬럼이 있는데요, 순서대로 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;#CHROM: 염색체 정보&lt;/li&gt;
  &lt;li&gt;POS: position. 해당 염색체에서 변이가 일어난 염기서열 위치를 말합니다.&lt;/li&gt;
  &lt;li&gt;ID: 변이를 나타내는 고유 ID가 있는 경우 표시합니다. 보통 dbSNP (rs로 시작하는) ID를 적거나 ‘.’ 으로만 적어둡니다.&lt;/li&gt;
  &lt;li&gt;REF: reference genome 상에서의 원래 염기서열&lt;/li&gt;
  &lt;li&gt;ALT: 돌연변이로 바뀐 서열&lt;/li&gt;
  &lt;li&gt;QUAL: 해당 variant를 찾아낸 것에 대한 quality score&lt;/li&gt;
  &lt;li&gt;FILTER: 해당 변이가 특정 필터기준을 통과했는지에 대한 표시 (flag)&lt;/li&gt;
  &lt;li&gt;INFO: 각 변이에 대한 자세한 설명이 적힌 컬럼.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 컬럼들은 모두 탭 (tab)으로 나뉘어져 있죠.&lt;br /&gt;
이 외의 컬럼은 없어도 VCF파일이라 할 수 있습니다. 그러나 보통 FORMAT 컬럼, sample 컬럼 하나씩이 더 추가되어 있는 경우가 많습니다.&lt;br /&gt;
보통 한 개의 샘플 정보가 적혀있지만, 가끔 2개 이상의 샘플 정보가 있는 경우 그만큼 컬럼 수도 늘어나게 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;FORMAT: 각 샘플에서 변이 정보를 나타내는 필드 종류. colon (:) 으로 나뉘어져 있습니다. 보통 genotype (GT), AD (allele depth), DP (Total read depth) 등이 적혀 있습니다.&lt;/li&gt;
  &lt;li&gt;sample (실제 샘플 이름이 적힘): FORMAT 에 적힌 필드들의 각 샘플에서의 수치. colon (:)으로 나뉘어져 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;bed-browser-extensible-data&quot;&gt;BED (Browser Extensible Data)&lt;/h3&gt;
&lt;p&gt;BED 파일 형식은 Human Genome Project 가 진행되면서 만들어진 형식이라고 해요.&lt;br /&gt;
bed 파일은 염색체의 특정 ‘영역’에 대한 정보 (annotation) 를 기록하고 사용하기 위해 만들어 졌습니다.&lt;br /&gt;
예를 들어, ChIP-seq 실험 결과를 통해 얻은 protein binding region 을 표시하고자 할 때 쓰일 수 있어요.&lt;br /&gt;
탭 (tab)으로 나뉘어져 있고 염기서열과 같이 큰 정보가 없어서 파싱하기 용이한 형식으로 널리 쓰이게 되었죠.&lt;/p&gt;

&lt;p&gt;bed 파일은 최소 3개의 컬럼만 있으면 되는데, 이에 컬럼이 추가되어서 총 12개까지 늘어날 수 있습니다.&lt;br /&gt;
용도에 따라 필요한 컬럼 수가 다른거죠.&lt;br /&gt;
그래서 컬럼 수에 따라서 확장자 이름을 bed3, bed4, bed12 등으로 나타내기도 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;track name=pairedReads description=&quot;Clone Paired Reads&quot; useScore=1
chr22 1000 5000 cloneA 960 + 1000 5000 0 2 567,488, 0,3512
chr22 2000 6000 cloneB 900 - 2000 6000 0 2 433,399, 0,3601&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;일반적인 bed 파일의 예시.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;bed 파일도 header 와 body 로 나뉘어져 있습니다.&lt;br /&gt;
&lt;strong&gt;header&lt;/strong&gt; 는 기본적으로 track name, description 등이 적혀져 있는 한 줄입니다.&lt;br /&gt;
그런데 이 bed 파일이 UCSC genome browser 등에서 쓰이는 경우, header 에는 추가적인 정보가 들어가기도 합니다.&lt;br /&gt;
추가적인 정보는 browser에서 이 파일을 사용했을 때, 어느 위치를 보여줄 것인지, 어떤 포맷으로 보여줄지 등 다양합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;browser position chr7:127471196-127495720
browser hide all
track name=&quot;ItemRGBDemo&quot; description=&quot;Item RGB demonstration&quot; visibility=2 itemRgb=&quot;On&quot;
chr7    127471196  127472363  Pos1  0  +  127471196  127472363  255,0,0
chr7    127472363  127473530  Pos2  0  +  127472363  127473530  255,0,0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;추가 정보가 header 에 들어있는 bed 파일의 예시.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt; 부분은 탭으로 나뉘어져 있습니다.&lt;br /&gt;
컬럼 수는 3개짜리 파일도 있고, 6개, 9개 등 다양합니다.&lt;br /&gt;
각 컬럼에는 다음과 같은 정보들이 포함되어 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;chrom: 염색체 정보&lt;/li&gt;
  &lt;li&gt;chromStart: 해당 영역의 시작서열 위치&lt;/li&gt;
  &lt;li&gt;chromEnd: 해당 영역의 끝서열 위치&lt;/li&gt;
  &lt;li&gt;name: 영역의 이름&lt;/li&gt;
  &lt;li&gt;score: 영역의 점수 0~1000&lt;/li&gt;
  &lt;li&gt;strand: DNA strand (+/-)&lt;/li&gt;
  &lt;li&gt;thickstart: 해당 영역이 시각화 될 때 두껍게 보여질 부분의 시작위치&lt;/li&gt;
  &lt;li&gt;thickend: 해당 영역이 시각화 될 때 두껍게 보여질 부분의 끝위치&lt;/li&gt;
  &lt;li&gt;itemRgb: 해당 영역이 시각화 될 때 나타날 색깔&lt;/li&gt;
  &lt;li&gt;blockCount: 해당 영역의 Exon 과 같은 block의 수&lt;/li&gt;
  &lt;li&gt;blockSizes: comma (,) 로 나뉘어진 블록들의 크기&lt;/li&gt;
  &lt;li&gt;blockStarts: comma (,) 로 나뉘어진 start 위치 목록. 이는 두번째 컬럼인 chromStart로 부터의 상대적 위치 (zero-base) 입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gff-general-feature-format&quot;&gt;GFF (General Feature Format)&lt;/h3&gt;
&lt;p&gt;GFF 는 DNA/RNA/protein 서열을 설명할 때 사용되는 파일 형식입니다.&lt;br /&gt;
한 줄에는 한 영역 (feature) 에 대한 설명이 9개 컬럼에 걸쳐서 적혀있습니다.&lt;br /&gt;
아래는 그 예시입니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chr22	TeleGene	enhancer	10000000	10001000	500	+	.	touch1
chr22	TeleGene	promoter	10010000	10010100	900	+	.	touch1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;각 컬럼이 어떤건지 살펴볼까요?&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sequence: 해당 서열의 이름&lt;/li&gt;
  &lt;li&gt;source: 해당 feature 이 어디서 왔는지에 대한 설명 (feature를 작성한 프로그램이나 연구기관 등)&lt;/li&gt;
  &lt;li&gt;feature: 해당 영역의 이름 (gene 혹은 exon 등)&lt;/li&gt;
  &lt;li&gt;start: 해당 영역의 시작위치 (one-base)&lt;/li&gt;
  &lt;li&gt;end: 해당 영역의 끝 위치 (one-base)&lt;/li&gt;
  &lt;li&gt;score: 영역에 대한 신뢰도 점수&lt;/li&gt;
  &lt;li&gt;strand: ‘+’ (forward) 혹은 ‘-‘ (reverse) 가닥&lt;/li&gt;
  &lt;li&gt;frame: 0,1,2 혹은 dot(.). 0은 해당 feature 의 첫 번째 서열이 reference 의 codon start 서열이라는 뜻이며, 1은 해당 feature의 두 번째 서열이 reference 의 codon start 서열이라는 뜻입니다. 만약 feature 가 exon 이 아닌 경우에는 ‘.’ 으로 되어있어요.&lt;/li&gt;
  &lt;li&gt;group: feature 가 속한 group. 같은 group 인 line 들은 같은 group 값을 가집니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 중 frame 컬럼은 phase라고도 불리는데, &lt;a href=&quot;https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md&quot;&gt;Sequence Ontology (SO) 문서&lt;/a&gt; 에 더 자세히 설명되어 있으니 한번 살펴보세요.&lt;/p&gt;

&lt;h3 id=&quot;gtf-gene-transfer-format&quot;&gt;GTF (Gene Transfer Format)&lt;/h3&gt;
&lt;p&gt;GTF 파일 형식은 GFF 와 매우 유사한 형식이에요.&lt;br /&gt;
실제로 GFF - GTF 변환도 가능하죠.&lt;br /&gt;
GTF 형식의 처음 8개 컬럼은 GFF 와 동일합니다.&lt;/p&gt;

&lt;p&gt;그러나 차이점이 있습니다.&lt;br /&gt;
GTF 파일에는 gene, exon 등의 feature 말고도 5’UTR, 3’UTR, inter, intron 등이 포함되어 있기도 합니다.&lt;br /&gt;
또한, GFF 형식의 9번째 컬럼 ‘group’이 semicolon으로 나뉜 ‘attribute’ 컬럼으로 바뀝니다.&lt;br /&gt;
각 attribute 는 해당 feature에 대한 설명이 type-value 짝을 이루어서 적혀 있어요.&lt;/p&gt;

&lt;p&gt;9번째 컬럼만 보면 다음과 같이 되어 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gene_id &quot;ENSG00000223972&quot;; gene_name &quot;DDX11L1&quot;; gene_source &quot;havana&quot;; gene_biotype &quot;transcribed_unprocessed_pseudogene&quot;; 
gene_id &quot;ENSG00000223972&quot;; transcript_id &quot;ENST00000456328&quot;; gene_name &quot;DDX11L1&quot;; gene_sourc e &quot;havana&quot;; gene_biotype &quot;transcribed_unprocessed_pseudogene&quot;; transcript_name &quot;DDX11L1-002&quot;; transcript_source &quot;havana&quot;;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GTF 에는 해당 feature에 대해 더 자세한 설명이 적혀있는 걸 알 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘 설명드린 파일들은 제가 자주 사용해오던 파일 형식들입니다.&lt;br /&gt;
그런데도 각 컬럼에 대한 세세한 설명까지 알고 있지는 못했던 것 같아요.&lt;br /&gt;
이번 기회에 공부해볼 수 있어서 좋았던 것 같습니다.&lt;/p&gt;

&lt;p&gt;다음에는 또 다른 내용으로 포스팅 해보겠습니다.&lt;br /&gt;
그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2020/09/13/bioinformatics-formats2.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2020/09/13/bioinformatics-formats2.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>파일 형식을 알아보자! (FASTA, FASTQ, BAM, SAM)</title>
        <description>&lt;h3 id=&quot;생명정보학-분석에서-자주-만나는-파일-형식을-알아봅시다&quot;&gt;생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다&lt;/h3&gt;

&lt;p&gt;안녕하세요, 한헌종입니다.&lt;br /&gt;
오늘은 생명정보학 분야에서 자주 만나게 되는 파일 형식이 어떤 게 있는지 알아봅시다.&lt;/p&gt;

&lt;p&gt;생명정보학을 공부하면서 가장 많이 만나게 되는 파일 형식은 사실 tsv, csv일 것입니다.&lt;br /&gt;
이 형식들은 여러분이 잘 알고 계시는 ‘표’ 형태의 정보를 텍스트 파일로 나타낸 것입니다.&lt;br /&gt;
tsv 는 tab-separated values, 즉 ‘탭’으로 데이터를 나누어 적어놓은 파일이구요,&lt;br /&gt;
csv 는 comma-separated values, 즉 ‘쉼표’로 데이터를 나누어 적어놓은 파일입니다.&lt;br /&gt;
어려울 것 없이, 그냥 표라고 생각하시면 됩니다. tsv,csv 파일을 엑셀로 열면 아주 이쁘게 표로 표현된답니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;csv 형태의 데이터는 표와 같습니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;세상의 모든 데이터가 tsv/csv 처럼 단순한 형태로 있으면 참 편할텐데, 그렇지가 않습니다.&lt;br /&gt;
생명정보학을 공부하시다 보면 아래에 소개드릴 특별한 파일 형식들을 많이 만나보시게 될 겁니다.&lt;br /&gt;
(사실 생각나는 대로 적어본 거라, 서로 연관성은 많이 없습니다.)&lt;br /&gt;
이 형식들에 익숙해지시면 데이터를 이해하고 분석하는 게 한결 수월해지실 겁니다.&lt;/p&gt;

&lt;p&gt;그럼 한 번 알아볼까요?&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;fasta&quot;&gt;FASTA&lt;/h3&gt;

&lt;p&gt;FASTA 파일은 특정 분자의 서열을 나타내는 데에 사용됩니다.&lt;br /&gt;
주로 Genome 의 각 chromosome 마다의 서열을 저장하는 데 쓰이죠.&lt;br /&gt;
혹은 gene/transcript/protein 각각의 염기서열 및 아미노산 서열을 저장할 때 사용되는 형식이에요.&lt;/p&gt;

&lt;p&gt;FASTA 파일은 두 형태가 반복되는 형식입니다.&lt;br /&gt;
첫 부분은 그 아래에 나올 서열의 이름/ID 입니다. 항상 &amp;gt; (꺽쇠) 글자로 시작하죠.&lt;br /&gt;
다음에는 그 이름에 해당하는 서열이 나오게 됩니다.&lt;br /&gt;
보통 그 서열은 굉장히 깁니다. 염색체는 말할 것도 없고, 특정 유전자나 단백질도 몇백-몇만 글자로 표현해야 하죠.&lt;br /&gt;
그래서 이를 한 줄로 나타내지 않고, 보통 60글자씩 나눠서 여러 줄에 걸쳐 표현합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;FASTA 파일의 예시. 이름-서열-이름-서열 이 반복되네요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* 주의: FASTA 파일은 보통 엄청나게 크기 때문에, 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;fastq&quot;&gt;FASTQ&lt;/h3&gt;

&lt;p&gt;fastq 파일은 NGS (Next generation sequencing data) 의 결과를 저장하는 데 주로 쓰입니다.&lt;br /&gt;
NGS 실험을 진행하면, 그 결과로 cDNA library 서열을 읽어서 데이터로 얻을 수 있습니다.&lt;br /&gt;
즉, 각 cDNA library 의 염기서열을 알 수 있는거죠.&lt;br /&gt;
이 서열 하나를 ‘read’ 라고 하는데요.&lt;br /&gt;
fastq 파일은 여러 read 의 정보를 한 파일에 저장하게 됩니다.&lt;/p&gt;

&lt;p&gt;보통 이 파일을 직접 사용하기보다, reference genome 에 align 한 뒤에 활용됩니다.&lt;br /&gt;
fastq 파일은 대부분의 연구에서 raw data, 즉 가공되지 않은 원본 파일로 여겨집니다.&lt;br /&gt;
그러니 분석하실 땐 fastq를 잘 백업해두셔서 잃어버리지 않도록 하세요!&lt;/p&gt;

&lt;p&gt;fastq 파일은 네 줄이 한 단위입니다.&lt;br /&gt;
위에서 말씀드린 것처럼 하나의 cDNA library 정보가 네 줄에 나눠서 표현되어 있는 거죠.&lt;br /&gt;
이들은 각각 다음 정보를 가지고 있습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sequence ID: @ 로 시작하며, 해당 서열의 이름을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;sequence: 실제로 읽은 염기서열 정보입니다.&lt;/li&gt;
  &lt;li&gt;description: ‘+’ 글자로 시작하는데, + 하나만 있기도 하고 sequence ID를 넣거나 설명을 넣는 부분입니다.&lt;/li&gt;
  &lt;li&gt;quality: 각 염기서열이 얼마나 정확히 읽혔는지를 나타냅니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Phred_quality_score&quot;&gt;Phred quality score&lt;/a&gt; 라는 표현법을 사용합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;fastq 파일의 예시. 이름-서열-설명-품질 이 반복됩니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* 주의: fastq 파일도 역시, 보통은 엄청나게 크기 때문에 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;bam-sam&quot;&gt;BAM, SAM&lt;/h3&gt;

&lt;p&gt;BAM 파일을 먼저 살펴볼까요.&lt;br /&gt;
BAM 은 binary alignment map 이라는 형식이에요.&lt;br /&gt;
이 파일은 위에서 설명한 fastq 파일을 reference genome에 align 했을 때 만들어지는 파일이죠.&lt;br /&gt;
즉, 각 cDNA library 조각이 reference genome 의 어느부분에서 나왔구나~ 하는 정보를 담았다는 거죠.&lt;br /&gt;
fastq 에서는 각 read 의 염기서열과 그 품질을 알 수 있다면, BAM 파일은 염기서열과 reference 에서의 위치정보 를 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇지만 BAM 파일은 사람이 읽을 수 없는 파일입니다…&lt;br /&gt;
정보를 압축하기 위해 binary 형태로 저장된 파일이기 때문이죠.&lt;br /&gt;
다행히도 이 BAM 파일을 ‘볼 수 있게’ 해놓은 파일이 있습니다. 바로 SAM 파일입니다.&lt;br /&gt;
BAM 파일과 SAM 파일은 동일한 정보를 가지고 있고, 서로 변환이 가능합니다. (변환 방법은 다음에 설명드릴게요)&lt;/p&gt;

&lt;p&gt;SAM 파일은 header 부분과 alignment 부분으로 이루어져 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;header&lt;br /&gt;
header 부분은 파일에 대한 설명을 주는 부분입니다. @ 로 시작하는 라인들입니다.&lt;/li&gt;
  &lt;li&gt;alignment&lt;br /&gt;
alignment 부분이 각 read에 대한 alignment 정보를 제공하는 부분입니다.&lt;br /&gt;
필수적인 11개의 컬럼으로 이루어져 있고, 추가로 몇 개의 컬럼이 더 있을 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;SAM 파일의 예시. 11개 컬럼이 너무 길어서 엑셀로 표시해보았어요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;각 column의 설명은 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;QNAME: read 이름&lt;/li&gt;
  &lt;li&gt;FLAG: 2진수로 된 read alignment 에 대한 설명&lt;/li&gt;
  &lt;li&gt;RNAME: refernce sequence 의 이름&lt;/li&gt;
  &lt;li&gt;POS: reference sequence 에서 align 된 위치&lt;/li&gt;
  &lt;li&gt;MAPQ: mapping quality. 즉 얼마나 정확히 align 되었는지.&lt;/li&gt;
  &lt;li&gt;CIGAR string: alignment 정보를 표현한 문자열. Match, Gap 등의 설명을 각 염기마다 표현합니다.&lt;/li&gt;
  &lt;li&gt;RNEXT: 다음 read 의 reference sequence 이름. 주로 paired end read 에 대한 분석을 위해 사용됩니다.&lt;/li&gt;
  &lt;li&gt;PNEXT: 다음 read 의 align 된 위치. 주로 paired end read 에 대한 분석을 위해 사용됩니다.&lt;/li&gt;
  &lt;li&gt;TLEN: Template length. paired-end read 둘의 left-end 부터 right-end 까지의 길이입니다.&lt;/li&gt;
  &lt;li&gt;SEQ: segment sequence. 염기 서열을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;QUAL: Phread quality score 입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;와, 저도 이 11개 컬럼의 뜻을 모두 알지는 못했는데 이렇게 많은 정보가 있는 줄은 몰랐네요!&lt;br /&gt;
* 주의: SAM 파일도 역시, 읽을수는 있다고 하나 엄청나게 크기 때문에 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘은 FASTA, FASTQ, BAM/SAM 파일에 대해 알아봤습니다.&lt;br /&gt;
분석의 앞부분에서 꼭 마주치게 되는 형식들이죠.&lt;br /&gt;
평소에 잘 안다고 생각했던 것들인데, 자세히 들어가보니 내용이 무척 많네요.&lt;br /&gt;
언젠가 이 파일들이 분석 순서상으로 어떻게 연관되어 있는지도 설명드릴게요.&lt;/p&gt;

&lt;p&gt;아, 그리고 이 외에도 널리 사용되는 파일 형식들이 많은데요, VCF/BED/GTF 등이 있어요.&lt;br /&gt;
이 형식들은 다음에 또 알아보도록 할게요.&lt;/p&gt;

&lt;p&gt;그럼 다음시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2020/08/26/Bioinformatics-fileformats.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2020/08/26/Bioinformatics-fileformats.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>깃 블로그에서 코드블록 만들기 - liquid, html, markdown을 한 번에!</title>
        <description>&lt;h3 id=&quot;깃-블로그에서-코드-부분을-볼-수-있게-해보자&quot;&gt;깃 블로그에서 코드 부분을 볼 수 있게 해보자!&lt;/h3&gt;

&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
이번엔 블로그에서 코드를 설명할 때 특정 블록으로 처리하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;깃 블로그는 Jekyll로 이루어져 있고, 각 포스트는 .md 파일로 구성되어 있죠.&lt;br /&gt;
이 파일 안에는 그냥 텍스트를 쓸 수도 있지만, liquid, html, markdown 세가지 언어를 통해 특정 기능이나 표현을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 어떤 코드를 썼는지를 그대로 보여주려면 어떻게 할까요?&lt;br /&gt;
예를 들어, 아래처럼 이탤릭체로 기울어진 텍스트는 ‘asterisk 별표 모양을 글 양옆에 붙이면 된다’는 설명을 어떻게 하면 될까요?&lt;br /&gt;
&lt;em&gt;기울임글자&lt;/em&gt;&lt;br /&gt;
별표-텍스트-별표 라고 쓰세요! 이런식으로 설명할 수도 없고 말이죠.&lt;/p&gt;

&lt;p&gt;이럴 때, 코드블록이 필요합니다.&lt;br /&gt;
깃 블로그에서 쓰는 liquid, html, markdown 세가지에 대해 어떻게 코드를 나타낼 수 있는지 알아보겠습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;liquid-의-경우&quot;&gt;liquid 의 경우&lt;/h3&gt;

&lt;p&gt;Jekyll 은 중괄호-퍼센트 글자 사이, 즉 {% 와 %} 모양 안에 특정 문구를 넣어서 원하는 명령을 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이걸 liquid 언어라고 하는데요, 이처럼 작성하면 Jekyll이 이 부분을 인식하고 렌더링을 통해 특정 기능을 실행합니다.&lt;br /&gt;
사실 이전 포스트에서 ‘이 코드를 넣으세요’ 라며 설명하는 부분이 있었는데,&lt;br /&gt;
그 코드를 실제로 쓰려니 코드가 렌더링 되어서 여러분께 보여드릴 수가 없었습니다.&lt;/p&gt;

&lt;p&gt;그래서 찾아보았습니다. 역시 구글은 검색하면 다 나오는군요.&lt;br /&gt;
아래처럼 Jekyll liquid 언어를 블로그에 넣는 방법을 설명드리겠습니다.&lt;br /&gt;
두 가지 방법이 있습니다. 하나는 raw-endraw 구문, 다른 하나는 highlight-endhighlight 구문입니다.&lt;/p&gt;

&lt;p&gt;{%- if page.comments -%}&lt;br /&gt;
    {%- include disqus_comments.html -%}&lt;br /&gt;
{%- endif -%}&lt;/p&gt;

&lt;p&gt;위 세줄을 .md 파일에 그냥 쓰면 이 글에서 보이지 않을 겁니다. 그럼 어떻게 한 걸까요?&lt;br /&gt;
방법은 정말 간단합니다.&lt;br /&gt;
아래 그림처럼 raw - endraw 구문을 넣으면 됩니다!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200822/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;이렇게 말입니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;정말 쉽죠?&lt;br /&gt;
liquid 문구 중 raw-endraw 라는 문구를 쓰면, 그 안에서 Jekyll liquid 언어를 작성하더라도&lt;br /&gt;
실제로 렌더링 하는 대신 ‘그대로’ 보여주더군요.&lt;/p&gt;

&lt;p&gt;그런데, 너무 코드블록 느낌이 안 나는군요. 어떻게 하면 될까요?&lt;br /&gt;
이 때는 pre, code 문구를 추가로 위아래에 집어넣으면 됩니다. 아래 그림처럼요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 표시할 코드부분만 코드블록 안에 나오게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{%- if page.comments -%}
    {%- include disqus_comments.html -%}
{%- endif -%}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 방법을 통해서 여러분께 liquid 언어 쓰는 방법을 더 자세하게 설명할 수 있게 되었습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;html의-경우&quot;&gt;html의 경우&lt;/h3&gt;
&lt;p&gt;html 을 코드블록에 표시하는 방법은 두가지입니다.&lt;br /&gt;
첫 번째는 물결 세 개를 쓰고 html이라고 쓰면 되는군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 이렇게 나옵니다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://hhj6212.github.io/&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   블로그 링크
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹은 highlight-endhighlight 기능을 사용할 수 있습니다.&lt;br /&gt;
highlight는 특정 언어를 지정하면, 그 언어에 맞는 형식대로 코드블록에서 보여줄 수 있게 해줍니다.&lt;br /&gt;
여기서 표시해야 할 언어는 html 이니, {% highlight html %} 이라고 작성해야 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이것도 똑같은 효과를 가져옵니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://hhj6212.github.io/&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   블로그 링크
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;markdown-언어의-경우&quot;&gt;markdown 언어의 경우&lt;/h3&gt;
&lt;p&gt;markdown 언어는 어떻게 할까요?&lt;br /&gt;
위에서 썼던 방법 중 pre, code 문구를 사용하면 됩니다.&lt;br /&gt;
이렇게 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 나타나게 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 하하하&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;세-언어를-동시에-사용할-때는요&quot;&gt;세 언어를 동시에 사용할 때는요?&lt;/h3&gt;
&lt;p&gt;만약 제가 liquid, html, markdown 세 가지 언어로 작성된 .md 파일을 여러분께 그대로 보여드리고 싶을 때는 어떻게 할까요?&lt;br /&gt;
물론 스크린샷을 찍어서 보여드릴 순 있겠죠.&lt;br /&gt;
그렇지만 여러분께서 따라서 연습하고 싶으실 땐 복사-붙여넣기를 하고 싶으실테니까, 좀 더 좋은 방법을 사용해봅시다.&lt;/p&gt;

&lt;p&gt;위에서 사용한 세 가지 방법을 잘 조합하면 됩니다!&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;liquid: raw-endraw 문구&lt;/li&gt;
  &lt;li&gt;html: highlight 문구&lt;/li&gt;
  &lt;li&gt;markdown: pre/code 문구&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;코드를 감쌀 때, 위 세 개의 물고 물리는 관계를 잘 고려해야 합니다.&lt;br /&gt;
예를 들어, pre/code 문구는 html이니, 이건 highlight로 묶기 전에 선언해야 합니다.&lt;br /&gt;
또, highlight 문구는 liquid 언어이므로, raw-endraw로 묶기 전에 선언해야 하죠.&lt;/p&gt;

&lt;p&gt;즉 다음과 같은 구조로 짜야 합니다.&lt;br /&gt;
가장 바깥에 pre-code, 그 다음에 highlight, 그리고 raw 로 묶으면 됩니다.&lt;br /&gt;
아래 그림처럼 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 liquid, html, markdown 세가지 언어가 모두 ‘그대로’ 여러분께 표시됩니다!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;{%- if page.comments -%}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post-disqus&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        ### 하하하
        {%- include disqus_comments.html -%}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{%- endif -%}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금까지 Jekyll 에서 liquid, html, markdown 을 코드블록으로 표시하는 방법을 배워보았습니다.&lt;br /&gt;
여러분의 블로그에서도 잘 활용하셨으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/2020/08/22/Jekyll-highlight-codeblock.html</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2020/08/22/Jekyll-highlight-codeblock.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>깃블로그에 댓글창 달기</title>
        <description>&lt;h3 id=&quot;깃허브-블로그에-댓글창을-달아보자&quot;&gt;깃허브 블로그에 댓글창을 달아보자&lt;/h3&gt;
&lt;p&gt;안녕하세요. 한헌종입니다.&lt;/p&gt;

&lt;p&gt;이번엔 Jekyll 로 구축된 깃허브 블로그에 댓글창을 넣는 방법을 설명해 보겠습니다.&lt;br /&gt;
블로그에는 당연하게 댓글창이 달려있을 거라 생각하실 겁니다.&lt;br /&gt;
그러나 깃허브 블로그는 그렇지 않습니다…&lt;br /&gt;
오로지 글만 올리는 용도의 블로그로만 써야하나? 하는 생각이 들었습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;소통 없는 삭막한 블로그의 현장&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그래서 찾아봤습니다. 어딘가 당연히 방법이 있겠지.&lt;br /&gt;
구글링을 해보니 이미 많은 분들이 Jekyll 에 댓글창을 추가해 사용하고 계시더군요.&lt;br /&gt;
그 방법은 바로 Disqus 라는 사이트의 서비스를 이용하는 것이었습니다.&lt;br /&gt;
자, 일단 &lt;a href=&quot;https://disqus.com/&quot;&gt;https://disqus.com/&lt;/a&gt; 에 접속해서 계정을 만들어 봅시다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;계정을 만든 다음에는 이메일 인증을 꼭 해주세요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;계정을 만들고 Get started 를 클릭하면 다음과 같은 선택창이 뜹니다.&lt;br /&gt;
저는 제 사이트에 댓글을 만들고 싶으므로 아래의 “I want to install Disqus on my site” 를 클릭합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;선택지가 둘 뿐이군요. 아래꺼 선택!&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 후 Disqus를 사용하기 위한 설정들을 해야 합니다.&lt;br /&gt;
먼저 사이트를 나타낼 이름을 지어봅니다. (저는 간단하게 hhangitblog로 했습니다.)&lt;br /&gt;
Category 도 아무거나 선택해주시구요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;간단하고 기억하기 쉬운 걸로 지어봅시다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그런 다음엔 서비스를 선택해야 합니다.&lt;br /&gt;
돈 내고 굉장히 좋은 서비스를 사용할 수도 있군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;돈 안내는 서비스는 없나 찾아보니, 아래쪽에 숨겨뒀네요.&lt;br /&gt;
Basic을 선택하시면 무료로 이용이 가능합니다.&lt;br /&gt;
물론 선택은 여러분에게 달려있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 다음엔 어떤 플랫폼을 사용하고 있는지 고르게 되어있습니다.&lt;br /&gt;
이중 Jekyll을 선택해줍시다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image7.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;Jekyll 말고도 웹사이트 만드는 선택지가 굉장히 많군요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 이러면 disqus 사이트에서 설정할 부분은 모두 끝났습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;다음 장면에서는 Jekyll 코드에서 어떤 부분을 만져야 댓글창이 나오는지 알려줍니다.&lt;br /&gt;
Post를 작성할 때 _post/ 디렉터리에 yyyy-mm-dd-name.md 문서를 작성하실 겁니다.&lt;br /&gt;
이 때, 각 .md 파일의 맨 윗부분에 변수로 “comments” 라는 것을 만들고, 이를 “true”로 설정해줘야 합니다.&lt;br /&gt;
그림에서처럼 말이죠.&lt;br /&gt;
여기서, layout: default 처럼 여러분이 포스트 글에서 사용하고 계신 _layout/[레이아웃이름].html 을 기억하고 계세요!&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image8.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이후, 위 그림의 아래 부분에 나와있는 파란 글씨의 “Universal Embed Code”라는 것을 클릭해봅시다.&lt;br /&gt;
그럼 다음과 같은 긴 코드가 나오는데요.&lt;br /&gt;
여러분의 Jekyll 디렉토리에 _includes/disqus_comments.html 이라는 파일을 만들고, 이 코드를 모두 복사해 붙여넣어 주세요.&lt;br /&gt;
코드 중간에 보시면 제가 위에서 지은 블로그이름 ‘hhangitblog’ 가 사용되고 있는 걸 확인하실 수 있어요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image9.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image10.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;위 코드를 _includes/disqus_comments.html 에 붙여넣기 한 모습&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;거의 다 됐습니다!&lt;br /&gt;
이제 _layouts 만 바꾸면 됩니다.&lt;br /&gt;
저는 각 포스트의 레이아웃을 _layouts/post.html 을 참조하게 해놨는데요.&lt;br /&gt;
그럼 이 코드의 밑 부분에 아래 코드들을 추가하면 댓글창 사용이 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  {%- if page.comments -%}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post-disqus&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    {%- include disqus_comments.html -%}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  {%- endif -%}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image11.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 끝났습니다!&lt;br /&gt;
이제 포스트를 확인하시면 댓글창이 들어와 있는 걸 보실 수 있습니다.&lt;br /&gt;
간단한 것 같으면서도 여러 과정을 거쳐야 하는군요.&lt;br /&gt;
그래도 블로그에 댓글창 정도는 있어야겠죠.&lt;br /&gt;
배워보길 잘했다는 생각이 듭니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image12.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;드디어 댓글로 소통이 가능해졌군요. 편-안&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이제 여러분도 댓글창을 만드실 수 있습니다.&lt;br /&gt;
긴 글 읽어주셔서 감사합니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/tech/programming/2020/08/20/comments-section-gitblog.html</link>
        <guid isPermaLink="true">http://localhost:4000/blog/tech/programming/2020/08/20/comments-section-gitblog.html</guid>
        
        
        <category>blog</category>
        
        <category>tech</category>
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>깃블로그를 시작하며</title>
        <description>&lt;h3 id=&quot;블로그를-시작하며&quot;&gt;블로그를 시작하며&lt;/h3&gt;
&lt;p&gt;얼마전까지만 해도 블로그 하면 네이버 블로그밖에 생각이 안나고, 저랑은 전혀 관련없는 세상이라고 생각했습니다.&lt;br /&gt;
그런데 최근들어 주변에서 블로그를 시작해보라는 이야기를 많이 해주셨습니다.&lt;br /&gt;
추천해주신 분들 중에는 이미 몇년간, 혹은 십년 이상 블로그를 운영해오신 분들이 계셨습니다.&lt;br /&gt;
그분들을 보며 “와 저렇게 오래 많은 글을 기록하는 건 무척 힘들겠구나” 라며 압도되었습니다.&lt;br /&gt;
그때마다 제가 들었던 말은, 바로 가장 작은 것부터 시작해보라는 이야기였습니다.&lt;br /&gt;
처음부터 크게 할 생각을 하지 말고, 조금씩 꾸준히 해나가는게 중요하다는 것이었습니다.&lt;br /&gt;
그러다보면 어느새 수많은 글을 포스팅하게 되고, 그 분야의 전문가로 인정받을 수 있다는 말이었죠.&lt;/p&gt;

&lt;p&gt;그래서 한번, 시작해보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떤-내용을-써볼까&quot;&gt;어떤 내용을 써볼까&lt;/h3&gt;
&lt;p&gt;저는 글을 잘쓰는 스타일은 아닙니다.&lt;br /&gt;
그러나 기록하는 걸 좋아합니다.&lt;br /&gt;
기록의 용도는 주로 배웠던 걸 까먹지 않기 위해, 혹은 이전에 할줄 알았던 것들이 오랜만에 하려니 잘 생각이 안날때를 위한 것이었습니다.&lt;br /&gt;
간단한 파이썬 함수라도, 사용법을 알기쉽게 정리해 놓으면 나중에 유용한 경우가 많더군요.&lt;br /&gt;
마침 최근에 새로운 분야를 경험하고 배우고 있기 때문에 관련 지식을 조금씩 정리해나가면 좋을 것 같다는 생각을 했습니다.&lt;br /&gt;
물론, 일상적인 일들도 기록해두면 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;왜-깃블로그-인가&quot;&gt;왜 깃블로그 인가&lt;/h3&gt;
&lt;p&gt;깃허브로 블로그를 시작한 이유는, 일단 추천을 받았기 때문입니다.&lt;br /&gt;
깃허브 자체는 업무에는 많이 써왔지만 그 외에 써본 적은 없었습니다.&lt;br /&gt;
그런데 깃허브는 각 계정마다 하나씩 Git page라는 걸 쓸 수 있게 해주더군요. 무료로!&lt;br /&gt;
또, 몇몇 사람들의 깃허브 블로그를 보니 매우 깔끔했습니다.&lt;br /&gt;
마크다운 언어도 배워가던 중인데 이를 적절히 사용하면 깔끔하게 내용을 정리할 수 있겠다는 생각에 바로 시작하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;시행착오&quot;&gt;시행착오&lt;/h3&gt;
&lt;p&gt;…물론 생각보다 쉽지 않더군요.&lt;br /&gt;
깃블로그를 무작정 시작하려니 정말 하나도 이해할 수 없었습니다.&lt;br /&gt;
깃허브, 루비, Jekyll, Markdown, HTML, CSS, Liquid 등 알아야 하는게 왜이렇게 많은지.&lt;br /&gt;
블로그들의 설명대로 따라해도 뭔가 이상하고 맘에 안들었습니다.&lt;br /&gt;
몇번의 시행착오 끝에, 깃블로그란 깃허브에서 제공하는 개인 페이지에 만드는 것이며 이는 루비 언어로 만들어진 Jekyll 이라는 엔진으로 구축하는 것을 알 수 있었습니다. (쓰면서도 맞나 싶습니다)&lt;br /&gt;
Jekyll 이라는게 뭔지부터 차근차근 공부했다면 시행착오가 덜했을텐데.&lt;br /&gt;
이렇게 겪은 시행착오도 하나씩 블로그에 정리해 나갈 예정입니다.&lt;br /&gt;
앞으로 배울 게 매우 많겠군요.&lt;/p&gt;

&lt;h3 id=&quot;앞으로&quot;&gt;앞으로&lt;/h3&gt;
&lt;p&gt;블로그는 처음이라 어떻게 가꿔나가야 할지 모르겠습니다.&lt;br /&gt;
그러나 누군가 이야기해준 것처럼, 정말 작은것부터 하나하나 해나가는게 중요한 것 같습니다.&lt;br /&gt;
오늘 이렇게 한 페이지를 작성했고, 앞으로 꾸준히 작성해보려 합니다.&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/life/2020/08/19/beginning_gitblog.html</link>
        <guid isPermaLink="true">http://localhost:4000/life/2020/08/19/beginning_gitblog.html</guid>
        
        
        <category>life</category>
        
      </item>
    
  </channel>
</rss>