<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>한헌종의 Git Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 09 Jan 2022 22:28:23 +0900</pubDate>
    <lastBuildDate>Sun, 09 Jan 2022 22:28:23 +0900</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>Flask 로 웹페이지 만들기</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
오늘은 python 으로 작성된 웹 프레임워크인 flask 를 이용해 웹페이지를 구현해보겠습니다.&lt;br /&gt;
참고로 저는 &lt;a href=&quot;https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world&quot;&gt;이 웹사이트&lt;/a&gt; 를 통해 flask 를 배울 수 있었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-flask-기본-구조&quot;&gt;1. Flask 기본 구조&lt;/h3&gt;

&lt;h4 id=&quot;폴더-구조&quot;&gt;폴더 구조:&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myapp/
    __init__.py
    routes.py
run_myapp.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;myapp__init__py&quot;&gt;myapp/__init__.py:&lt;/h4&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;myapp&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;routes&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;myapproutespy&quot;&gt;myapp/routes.py:&lt;/h4&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;myapp&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;run_myapppy&quot;&gt;run_myapp.py:&lt;/h4&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;myapp&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;웹페이지-실행하기&quot;&gt;웹페이지 실행하기&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;FLASK_APP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;run_myapp.py
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;flask run
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Serving Flask app &lt;span class=&quot;s1&quot;&gt;'run_myapp.py'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lazy loading&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Environment: production
   WARNING: This is a development server. Do not use it &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;a production deployment.
   Use a production WSGI server instead.
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Debug mode: off
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Running on http://127.0.0.1:5000/ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Press CTRL+C to quit&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이후 http://127.0.0.1:5000/ 로 접속하면 “hello world!” 를 볼 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/220109/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;Hello world 로 시작하는게 정석!&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;설명하자면, __init__.py 작성을 통해 myapp 이라는 패키지가 만들어지게 됩니다.&lt;br /&gt;
여기서 Flask 클래스의 인스턴스인 app 이라는 변수가 만들어지고, 이는 myapp 패키지의 멤버 변수가 됩니다.&lt;br /&gt;
routes.py 모듈에서는 myapp 패키지의 app 변수를 import 합니다.&lt;br /&gt;
그리고 이를 decorator 로 활용해 “/” 와 “/index” 페이지를 index_func 함수에 연결해 줍니다.&lt;br /&gt;
즉, 이 URL 에 대한 request 가 들어오면 해당 함수가 응답해주는 겁니다.&lt;br /&gt;
여기서는 다른 작업 없이 문자열 “hello world!” 만 반환하고 있습니다.&lt;br /&gt;
환경변수 FLASK_APP 을 run_myapp.py 로 설정하고 flask run 명령어를 입력하면 웹페이지가 구동됩니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;2-html-rendering-및-html-상속&quot;&gt;2. html rendering 및 html 상속&lt;/h3&gt;
&lt;p&gt;위에서 만들어진 웹 페이지는 html 구조 없이 문자열만 출력한 상태였습니다.&lt;br /&gt;
이제 html 을 사용해 웹 페이지의 구조를 만들어보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;이 때, 이 웹사이트는 하나가 아닌 여러 페이지로 구성되겠죠?&lt;br /&gt;
그런데 각 페이지를 만들 때마다 매번 html 을 복사해야 한다면 매우 귀찮을 겁니다.&lt;br /&gt;
따라서 이를 여러번 반복하지 않고 templates 를 사용해 하나의 html 을 여러곳에서 활용할 수 있게 해봅시다.&lt;/p&gt;

&lt;p&gt;만들어진 html 을 렌더링하기 위해 flask 의 render_template 함수가 사용됩니다.&lt;/p&gt;

&lt;h4 id=&quot;폴더-구조-1&quot;&gt;폴더 구조:&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myapp/
    templates/
        base.html
        index.html
        somepage.html
    __init__.py
    routes.py
run_myapp.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;basehtml&quot;&gt;base.html:&lt;/h4&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My website&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
            Go to:
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ url_for('index_func') }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Home&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{ url_for('some_func') }}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Some page&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
        {% block content %}{% endblock %}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;indexhtml&quot;&gt;index.html&lt;/h4&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends &quot;base.html&quot; %}
{% block content %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    This is home page. Hello world!&quot;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;somepagehtml&quot;&gt;somepage.html&lt;/h4&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends &quot;base.html&quot; %}
{% block content %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
        Some page. Nothing created yet.
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;routespy&quot;&gt;routes.py&lt;/h4&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url_for&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;myapp&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;index.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Home&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/somepage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;some_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;somepage.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SomePage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;init 과 run_myapp.py 는 바꾸지 않습니다.&lt;br /&gt;
이후 실행하면 다음과 같은 화면이 나옵니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/220109/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;http://localhost:5000/ 의 모습&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/220109/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;http://localhost:5000/somepage 의 모습&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;설명드리자면, 먼저 base.html 은 html 기본 골격을 가지고 있습니다.&lt;br /&gt;
head 에는 title 항목을 가지고 있고, body 에는 웹사이트의 두 링크를 가지고 있군요.&lt;br /&gt;
여기서 link 는 url_for 라는 함수를 통해 routes.py 의 각 함수를 연결해주고 있습니다.&lt;br /&gt;
여기서 실제 url 을 적어둘 수 도 있지만, url_for 라는 함수를 사용하면 다음과 같은 이점이 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;url 은 함수 이름보다 자주 바뀝니다. 따라서 함수 이름으로 지정해두면 수정할 일이 적습니다.&lt;/li&gt;
  &lt;li&gt;url 은 이후 동적 요소를 가질 수 있는데, 이를 위해 url concatenation 으로 작업하면 틀리기 쉽습니다. url_for 는 이런 복잡한 url 을 만들어줄 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이후 아래쪽에 {% block content %}{% endblock %} 구문은 이 부분에 다른 content 가 올 수 있음을 알려주고 있습니다.&lt;br /&gt;
이런 “{% 명령어 %}” 구문은 Jinja2 template engine 이 사용하는 expression/logic 구문입니다.&lt;/p&gt;

&lt;p&gt;이렇게 만들어진 base.html 은 각각 index.html 과 somepage.html 에서 사용하고 있습니다.&lt;br /&gt;
{% extends “base.html” %} 구문을 통해 base.html 을 가져오고 있고,&lt;br /&gt;
{% block content %} ~ {% endblock %} 안에서 링크마다의 형태를 구축했습니다.&lt;/p&gt;

&lt;p&gt;routes.py 를 보시면, 서로 다른 url 에 대한 두 함수가 만들어진 것을 볼 수 있습니다.&lt;br /&gt;
각 함수는 반환값으로 render_template() 을 사용하고 있죠.&lt;br /&gt;
render_template() 은 Jinja2 template engine 을 사용해 웹페이지를 보여줍니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;3-데이터-전달-및-get-post&quot;&gt;3. 데이터 전달 및 GET, POST&lt;/h3&gt;
&lt;p&gt;이제 웹페이지에 신호를 전달하고, 전달받은 명령어로 결과값을 보여주는 부분을 작성해보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;somepagehtml-1&quot;&gt;somepage.html&lt;/h4&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends &quot;base.html&quot; %}
{% block content %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This is a calculator!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;number1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;number2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sub&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mul&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
    {% if result %}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;result: {{ result }}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    {% endif %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;routespy-1&quot;&gt;routes.py&lt;/h4&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url_for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;myapp&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;index.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Home&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/somepage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GET&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;some_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;form_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;form&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;form_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;number1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;form_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;number2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;form_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;somepage.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SomePage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;form_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sub&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;somepage.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SomePage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;form_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;mul&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;somepage.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SomePage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;form_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;somepage.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SomePage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render_template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;somepage.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SomePage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 작성한 뒤 실행하면 다음과 같은 결과가 나옵니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/220109/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;게산기 페이지&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/220109/image5.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;3 과 4 를 입력했습니다. 이제 mul 을 누르면…&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/220109/image6.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;결과로 12 가 나옵니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위 코드를 설명드리도록 할게요.&lt;br /&gt;
사용자가 전달하는 request 를 받기 위해 먼저 flask 의 request 함수를 import 합니다.&lt;br /&gt;
routes.py 에서 some_func 의 decorator 를 보면, methods 두 가지가 가능한 것을 설정해 두었습니다.&lt;br /&gt;
여기서 request.method 는 사용자가 전달한 request 에 따라 “GET” 혹은 “POST” 값을 가질 수 있죠.&lt;br /&gt;
이 때 값을 전달하는 POST method 를 받게 되면, 아래 if 문 안으로 들어가게 됩니다.&lt;/p&gt;

&lt;p&gt;request.form 에는 html 에서 form 구문에서 전달하는 값들의 “name” 과 “value” 가 각각 dictionary 형태로 전달됩니다.&lt;br /&gt;
somepage.html 페이지에서 숫자 두 개를 입력하고 버튼을 누르게 되면, form 구문을 통해 POST 명령어가 전달되는데요.&lt;br /&gt;
이를 통해 {“number1”: “3”, “number2”: “4”, “button”: “mul”} 이라는 데이터가 request.form 에 dictionary 형태로 전달되는 거죠.&lt;br /&gt;
따라서 이 값을 받아 적절히 계산한 뒤 다시 somepage.html 에 전달해 페이지를 렌더링하는 겁니다.&lt;br /&gt;
이 때는 인자로 result 값을 전달하는데요, somepage.html 에서는 이 result 라는 값을 받아서 사용할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;somepage.html 을 보면, {% if result %} 로 시작하는 구문이 보이는데요,&lt;br /&gt;
이것이 result 값이 있는지를 확인하는 부분입니다.&lt;br /&gt;
맨 처음 somepage.html 에 들어가게 되면 아무 값도 전달하지 않았을 테니, 결과도 보이지 않게 해야겠죠.&lt;br /&gt;
그런데 button 을 눌러 값을 전달하게 된다면, 이 계산 결과 result 를 이 if 문을 통해 보여줄 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;이렇게 값을 html 로 전달하고, 다시 html 에서 form 으로 값을 전달받을 수 있는 것입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;네 오늘은 간단하게 flask 를 어떻게 사용할 수 있는지 알아보았습니다.&lt;br /&gt;
여기서 좀 더 나아가 DB 를 쓰고, CSS 로 모양새를 갖추고, 더 복잡한 함수를 쓰게 되면 훨씬 더 다양한 일을 할 수 있겠죠?&lt;br /&gt;
도움이 되셨기를 바라며, 오늘 포스트는 여기까지 하도록 하겠습니다.&lt;br /&gt;
그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 09 Jan 2022 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tech/programming/2022/01/09/flask1.html</link>
        <guid isPermaLink="true">http://localhost:4000/tech/programming/2022/01/09/flask1.html</guid>
        
        
        <category>tech</category>
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>희귀질환 환자가 시퀀싱 검사를 받아야 하는 이유</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
오늘은 &lt;strong&gt;희귀질환 환자에게 WES / WGS 검사가 필요한 이유&lt;/strong&gt;를 말씀드리고자 합니다.&lt;/p&gt;

&lt;p&gt;아래 내용은 다음 논문의 내용을 요약해 작성했습니다:&lt;br /&gt;
Manickam et al., Exome and genome sequencing for pediatric patients with congenital anomalies or intellectual disability: an evidence-based clinical guideline of the American College of Medical Genetics and Genomics (ACMG), Genetics in Medicine (2021)&lt;br /&gt;
&lt;a href=&quot;https://www.nature.com/articles/s41436-021-01242-6&quot;&gt;https://www.nature.com/articles/s41436-021-01242-6&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;희귀질환 환자와 가족들에게 가장 중요한건 아마도 ‘진단’ 일 것입니다.&lt;br /&gt;
어떤 질환을 가지고 있는지 정확히 진단을 받아야 비로소 알맞은 임상 관리 및 치료를 시작할 수 있기 때문이에요.&lt;br /&gt;
희귀질환 환자가 진단을 받기까지는 평균적으로 5년이 걸린다고 하는데요, 그만큼 희귀질환을 진단하는 것이 쉽지 않기 때문이에요.&lt;br /&gt;
이런 &lt;strong&gt;진단 방랑 (diagnostic odyssey)&lt;/strong&gt; 을 하루 빨리 끝내는 것이 환자와 가족들에게 무척 중요한 일이겠죠.&lt;/p&gt;

&lt;p&gt;희귀질환을 진단하기 위해 사용되는 검사 방법은 여러가지가 있습니다.&lt;br /&gt;
기존의 검사 방법으로는 다음 기술들이 있어요.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;candidate single-gene testing (단일 후보 유전자 검사)&lt;/li&gt;
  &lt;li&gt;large gene panel testing (유전자 패널 검사)&lt;/li&gt;
  &lt;li&gt;chromosomal microarray (염색체 마이크로어레이 CMA)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 더 많은 범위를 포괄하는 시퀀싱 기반 검사들이 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Whole exome sequencing (전장 엑솜 시퀀싱, WES)&lt;/li&gt;
  &lt;li&gt;Whole genome sequencing (전장 유전체 시퀀싱, WGS)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기존 검사 방법들은 &lt;strong&gt;싸고 빠르다&lt;/strong&gt; 는 장점이 있지만, &lt;strong&gt;정해진 유전자 및 변이들만 확인할 수 있다&lt;/strong&gt;는 단점이 있죠.&lt;br /&gt;
반면 WES/WGS 검사 방법은 &lt;strong&gt;비싸고 상대적으로 느리다&lt;/strong&gt;는 단점이 있지만 &lt;strong&gt;거의 모든 변이를 확인할 수 있고 더욱 정확하다&lt;/strong&gt; 는 장점이 있죠.&lt;br /&gt;
과연 환자 입장에서 어떤 선택을 해야할까요?&lt;/p&gt;

&lt;p&gt;이에 대한 지침을 만들기 위해 American College of Medical Genetics and Genomics (ACMG) 연구진들이 투입되었습니다.&lt;br /&gt;
이들은 2017 년부터 희귀질환 환자에 대한 WES/WGS 적용 연구들을 모아서 체계적으로 검토해보았습니다.&lt;br /&gt;
대상은 1세 이하의 선천적 기형 혹은 18세 이하의 지적 장애 혹은 발달장애 환자들에 대한 연구였습니다.&lt;br /&gt;
이들은 총 167 건의 연구 결과를 검토했으며, 그 결론은 다음과 같았습니다.&lt;/p&gt;
&lt;h4 id=&quot;선천적-기형-지적-장애-발달-장애-환자에-대해-첫-번째-혹은-두-번째-검사로써-weswgs-검사를-강력하게-추천한다&quot;&gt;&lt;strong&gt;“선천적 기형, 지적 장애, 발달 장애 환자에 대해 첫 번째 혹은 두 번째 검사로써 WES/WGS 검사를 강력하게 추천한다.”&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;이런 결론을 내릴 수 있었던 이유는 무엇일까요?&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;1-진단율&quot;&gt;1. 진단율&lt;/h4&gt;
&lt;p&gt;진단율은 이 논문의 주요 초점이 아니었지만 그 결과를 취합할 수 있었다고 합니다.&lt;br /&gt;
여러 연구 결과에서 기존 검사 방식과 WES/WGS 검사를 했을 때의 진단율을 비교해 보았습니다.&lt;br /&gt;
기존 검사로는 &lt;strong&gt;21% 의 진단율&lt;/strong&gt;을 보인 반면,&lt;br /&gt;
WES/WGS 기반 검사 방법은 &lt;strong&gt;38% 의 진단율&lt;/strong&gt;을 보였다고 합니다.&lt;br /&gt;
특히 &lt;strong&gt;WES (34%)&lt;/strong&gt; 를 사용한 경우보다 &lt;strong&gt;WGS (43%)&lt;/strong&gt; 를 사용했을 때 진단율이 더 높았다고 하네요.&lt;br /&gt;
물론, 논문에서는 환자의 부모에게 있어 negative result 의 중요성도 크기 때문에, 진단율을 강조하는 것이 항상 좋은 것은 아니라고 합니다.&lt;/p&gt;

&lt;h4 id=&quot;2-비용-절감&quot;&gt;2. 비용 절감&lt;/h4&gt;
&lt;p&gt;기존 검사를 한 다음 WES/WGS 검사를 하는것은, 당연하게도, 기존 검사만 수행하는 것에 비해 추가 비용이 들었다고 합니다.&lt;br /&gt;
그러나 WES/WGS 검사를 첫 번째 혹은 두 번째 검사로 하게 된 경우는 기존 검사를 여러번 수행한 경우보다 &lt;strong&gt;더 적은 비용으로 더 많은 진단&lt;/strong&gt;을 이룰 수 있었다고 합니다.&lt;br /&gt;
또한, 시퀀싱 비용은 앞으로도 계속 낮아질 것이기 때문에, 초기에 WES/WGS 검사를 하는 것은 환자들이 더 빠르게 진단을 받을 수 있도록 할 것이라고 합니다.&lt;/p&gt;

&lt;h4 id=&quot;3-임상-관리방법-변경&quot;&gt;3. 임상 관리방법 변경&lt;/h4&gt;
&lt;p&gt;검사를 통해 기존에 환자가 받던 관리방법이 바뀔 수 있겠죠.&lt;br /&gt;
이 관리방법은 크게 단기 관리방법 (약물, 절차 또는 치료법) 과 장기 관리방법 (전문의에게 의뢰하기 혹은 검사/생활방식의 변경) 으로 나눌 수 있는데요,&lt;br /&gt;
단기 관리방법의 경우 25 건의 연구 결과에서 WES/WGS 검사를 받은 환자들 중 8% 에게 영향을 주었으며,&lt;br /&gt;
장기 관리방법의 경우 19 건의 연구 결과에서 WES/WGS 검사를 받은 환자들 중 10% 에게 영향을 주었다고 합니다.&lt;/p&gt;

&lt;p&gt;논문에서는 무작위 대조군을 설정해 연구의 품질이 가장 높았던 NSIGHT2 의 연구를 언급하고 있는데요,&lt;br /&gt;
이 연구에서는 rapid genome sequencing 이 57 명 (28%) 의 신생아에 대한 관리방법에 영향을 주었다고 합니다.&lt;br /&gt;
이는 특히 ultra rapid genome sequencing 일 때, 그리고 positive result 일 때 대조군에 비해 매우 유의미한 수치였다고 하네요 (각각 p &amp;lt; 0.0001, p &amp;lt; 0.00001).&lt;br /&gt;
이러한 rapid genome sequencing 은 6.7 배 더 유용하게 받아들여졌고, 소요 시간 (turnaround time) 역시 더 짧았다고 합니다.&lt;br /&gt;
또한 이러한 rapid genome sequencing 결과가 임상의나 환자 가족에게 혼란 혹은 고통을 주는 경우도 거의 없었다고 해요.&lt;/p&gt;

&lt;h4 id=&quot;4-바람직하지-않은-효과&quot;&gt;4. 바람직하지 않은 효과&lt;/h4&gt;
&lt;p&gt;여기서는 잠재적 피해라는 것을 언급하고 있는데요, 이는 보험 차별, 가족 소통에의 안 좋은 영향, 추가적인 검사/감시/약물치료 또는 식이조절로 인한 재정적 부담, 환자와 가족들에 대한 심리적 영향, 그리고 사생활 침해 등을 이야기합니다.&lt;br /&gt;
WES/WGS 검사에 대한 연구중에서는 오직 5 건의 연구만이 이 영향을 언급하고 있었는데요, 이는 주로 검사로 알게된 친자 확인 결과에 의한 것이었습니다.&lt;br /&gt;
이런 경우를 제외하고는 WES/WGS 검사로 인해 받은 심리적 피해는 보고된 바가 없었다고 합니다.&lt;br /&gt;
그리고 몇몇 케이스에서는 검사로 인한 고통이 낮았으며, 심리적으로는 &lt;strong&gt;오히려 긍정적인 영향&lt;/strong&gt;을 경험했다고 해요.&lt;/p&gt;

&lt;h4 id=&quot;5-가치&quot;&gt;5. 가치&lt;/h4&gt;
&lt;p&gt;환자들의 선호도와 가치를 조사한 결과, 공통적으로 WES/WGS 검사를 통해 진단받지 못한 발달 장애 및 선천적 기형을 진단하는 것에 동기부여를 받으며 가치를 두고 있었다고 합니다.&lt;br /&gt;
또한, 환자들은 시퀀싱 및 진단에 대해 배우고자 할 때 genetic counseling 으로 얻는 정보에 매우 큰 가치가 있다고 느꼈다고 하네요.&lt;br /&gt;
NSIGHT2 의 연구에 따르면, 대부분의 부모들은 첫 번째 검사로 rapid diagnostic genome sequencing 이 ICU 에 있는 원인 불명의 신생아 환자들에게 매우 유익하다고 느꼈다고 합니다.&lt;br /&gt;
이 외에도 10,000 genome project 혹은 Rapid Paediatric Sequencing 연구에 참여한 부모들은 검사 결과에 대해 매우 긍정적이었고, 빠른 진단을 받을 수 있는 기회가 임상적으로 그리고 감정적으로 매우 유익했다고 언급하고 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;6-결론&quot;&gt;6. 결론&lt;/h4&gt;
&lt;p&gt;수 많은 연구 결과를 체계적으로 검토해본 결과, 선천적 기형, 발달 장애 및 지적 장애를 가진 환자들에게 첫 번째 혹은 두 번째 검사로 WES/WGS 를 매우 강력하게 추천한다고 합니다.&lt;br /&gt;
부정적인 영향에 대한 근거가 거의 없다는 것과 나날이 늘어나는 치료에 대한 유익성 근거를 보았을 때, WES/WGS 검사는 임상적으로 그리고 환자 가족에게도 유용하다는 것이 입증되었다는 것을 말하고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;네. 오늘은 ACMG 에서 2021 년 출판한 논문에 기반해서 WES/WGS 검사가 필요한 이유에 대해 설명해보았습니다.&lt;br /&gt;
다만 이 연구는 선천적 기형 / 발달 장애 / 지적 장애에 초점이 맞춰져 있었습니다.&lt;br /&gt;
이 논문은 또한 위에 언급한 내용 외에도 어떤 점들을 고려해야 하는지 여러 주제에 대해 언급하고 있습니다.&lt;br /&gt;
논문 내용이 좀 어려운 편이지만, 직접 읽어보시면 도움이 될 수 있을 것 같습니다.&lt;/p&gt;

&lt;p&gt;그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Oct 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/clinical%20genomics/2021/10/31/ACMG2021.html</link>
        <guid isPermaLink="true">http://localhost:4000/clinical%20genomics/2021/10/31/ACMG2021.html</guid>
        
        
        <category>clinical genomics</category>
        
      </item>
    
      <item>
        <title>BAM/SAM 의 flag 정보, samtools flagstat 설명</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
오늘은 bam / sam 파일에 있는 flag 에 대해, 그리고 이 flag 정보를 요약해 보여주는 samtools flagstat 결과에 대해 알아보겠습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;bam--sam-파일의-flag-란&quot;&gt;BAM / SAM 파일의 flag 란?&lt;/h3&gt;
&lt;p&gt;flag 란 무엇일까요?&lt;br /&gt;
flag 는 bam / sam 파일에서 각 read alignment 에 대한 설명을 숫자로 나타낸 것이에요.&lt;br /&gt;
이 flag 는 0 ~ 4095 사이의 숫자인데요, SAM 파일의 두 번째 컬럼이 가지고 있는 숫자를 말해요.&lt;br /&gt;
이전 포스트에 있는 그림을 다시 보여드릴게요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;SAM 파일의 예시. 2 번째 컬럼 (B) 에 적힌 숫자가 각 read 에 대한 flag 입니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;read1 의 flag 는 16, read2 의 flag 는 1032 이군요.&lt;br /&gt;
그럼 이 숫자가 무엇을 뜻하는 걸까요?&lt;br /&gt;
이걸 알아내려면 flag 를 이진수로 나타내봐야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;flag-를-이진수로-나타내기&quot;&gt;flag 를 이진수로 나타내기&lt;/h3&gt;
&lt;p&gt;flag 는 0~4095 사이의 숫자라고 했죠?&lt;br /&gt;
이를 2진수로 바꾸면 최대 12자리 이진수가 됩니다. (이때 빈 자릿수는 0으로 채워서 12자리를 맞춰줍니다.)&lt;br /&gt;
예를 들어 16 이라는 flag 값을 2진수로 나타내면 0000000&lt;strong&gt;1&lt;/strong&gt;0000 가 되구요,&lt;br /&gt;
1032 라는 flag 값을 2진수로 나타내면 0&lt;strong&gt;1&lt;/strong&gt;000000&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;00 가 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;왜-flag-값을-12자리의-2진수로-바꾸는-걸까요&quot;&gt;왜 flag 값을 12자리의 2진수로 바꾸는 걸까요?&lt;/h3&gt;
&lt;p&gt;이는 read alignment 가 가질 수 있는 12가지 특성 각각이 있느냐, 없느냐를 표현하기 위해서에요.&lt;br /&gt;
2진수로 바꾼 flag 값에서 &lt;strong&gt;각 자리수는 각 특성을 나타내고, 1 이 의미하는 것은 해당 특성을 가지고 있다는 뜻&lt;/strong&gt;이에요.&lt;br /&gt;
예를 들어 1032 라는 flag 값을 이진수로 나타낸 &lt;strong&gt;010000001100&lt;/strong&gt; 를 보시죠.&lt;br /&gt;
이 숫자를 보면, &lt;strong&gt;뒤에서&lt;/strong&gt; 3번째 / 4번째 / 11번째 숫자가 1이고, 나머지는 모두 0이네요. (뒤에서부터 세어야 합니다)&lt;br /&gt;
즉, 이 read alignment 는 12가지 특성 중 3번째 / 4번째 / 11번째 특성을 가지고 있다는 뜻이에요.&lt;/p&gt;

&lt;h3 id=&quot;flag-의-각-자리수는-어떤-특성을-가리키나요&quot;&gt;flag 의 각 자리수는 어떤 특성을 가리키나요?&lt;/h3&gt;
&lt;p&gt;다음 표에는 각 자리수가 의미하는 바를 정리해보았어요.&lt;br /&gt;
이는 SAM format specification 문서에 있는 표를 참고했습니다. &lt;a href=&quot;https://samtools.github.io/hts-specs/SAMv1.pdf&quot;&gt;(SAM format specification 문서 링크)&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;bit&lt;/th&gt;
      &lt;th&gt;2진수&lt;/th&gt;
      &lt;th&gt;16진수&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;000000000001&lt;/td&gt;
      &lt;td&gt;0x1&lt;/td&gt;
      &lt;td&gt;template having multiple segments in sequencing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;000000000010&lt;/td&gt;
      &lt;td&gt;0x2&lt;/td&gt;
      &lt;td&gt;each segment properly aligned according to the aligner&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;000000000100&lt;/td&gt;
      &lt;td&gt;0x4&lt;/td&gt;
      &lt;td&gt;segment unmapped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;000000001000&lt;/td&gt;
      &lt;td&gt;0x8&lt;/td&gt;
      &lt;td&gt;next segment in the template unmapped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;000000010000&lt;/td&gt;
      &lt;td&gt;0x10&lt;/td&gt;
      &lt;td&gt;SEQ being reverse complemented&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;000000100000&lt;/td&gt;
      &lt;td&gt;0x20&lt;/td&gt;
      &lt;td&gt;SEQ of the next segment in the template being reverse complemented&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;000001000000&lt;/td&gt;
      &lt;td&gt;0x40&lt;/td&gt;
      &lt;td&gt;the first segment in the template&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;128&lt;/td&gt;
      &lt;td&gt;000010000000&lt;/td&gt;
      &lt;td&gt;0x80&lt;/td&gt;
      &lt;td&gt;the last segment in the template&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td&gt;000100000000&lt;/td&gt;
      &lt;td&gt;0x100&lt;/td&gt;
      &lt;td&gt;secondary alignment&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;512&lt;/td&gt;
      &lt;td&gt;001000000000&lt;/td&gt;
      &lt;td&gt;0x200&lt;/td&gt;
      &lt;td&gt;not passing filters, such as platform/vendor quality controls&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td&gt;010000000000&lt;/td&gt;
      &lt;td&gt;0x400&lt;/td&gt;
      &lt;td&gt;PCR or optical duplicate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2048&lt;/td&gt;
      &lt;td&gt;100000000000&lt;/td&gt;
      &lt;td&gt;0x800&lt;/td&gt;
      &lt;td&gt;supplementary alignment&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그러면 1032 라는 flag 는 무엇을 뜻할까요?&lt;br /&gt;
아까 말씀드렸듯, 이 read alignment 는 12가지 특성 중 3번째 / 4번째 / 11번째 특성을 가지고 있다는 뜻이므로&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;segment unmapped: 이 read 는 alignment 가 되지 않은 read 라는 뜻입니다.&lt;/li&gt;
  &lt;li&gt;next segment in the template unmapped: 이 read 는 paired-end 인데, pair 를 이루는 다른 한쪽의 read 도 alignment 가 되지 않았다는 뜻입니다.&lt;/li&gt;
  &lt;li&gt;PCR or optical duplicate: 이 read 는 PCR 과정에서 만들어진 중복 read 라는 뜻입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서, &lt;strong&gt;flag 가 1032 라는 것은 이 read 가 1) unmapped 이고 2) pair 역시 unmapped 이며 3) duplicate read 라는것&lt;/strong&gt;을 뜻해요.&lt;br /&gt;
이렇게 flag 로 read 의 특성을 알 수 있답니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;samtools-의-flagstat-보는-방법&quot;&gt;samtools 의 flagstat 보는 방법&lt;/h3&gt;
&lt;p&gt;이전 포스트에서 설명드렸듯, samtools 의 여러 기능 중 하나는 flagstat 이라는 명령어로 특정 read 들의 요약된 정보를 보는거에요.&lt;br /&gt;
&lt;a href=&quot;https://hhj6212.github.io/biology/tech/2020/10/18/samtools.html&quot;&gt;(이전 samtools 명령어에 대한 링크 참조)&lt;/a&gt;&lt;br /&gt;
다음 예시를 보세요.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools flagstat example.bam
4579959 + 0 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;total &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;QC-passed reads + QC-failed reads&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0 + 0 secondary
0 + 0 supplementary
371078 + 0 duplicates
4532991 + 0 mapped &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;98.97% : N/A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
4569463 + 0 paired &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;sequencing
2284756 + 0 read1
2284707 + 0 read2
4413160 + 0 properly paired &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;96.58% : N/A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
4475527 + 0 with itself and mate mapped
46968 + 0 singletons &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1.03% : N/A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
21515 + 0 with mate mapped to a different chr
15292 + 0 with mate mapped to a different chr &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mapQ&amp;gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예시로 만든 bam 파일의 flagstat 결과에요.&lt;br /&gt;
여기 나온 특성들은 위의 flag 에 설명드린 특성이랑 맞는것도 있는것 같고, 아닌것도 있는 것 같죠?&lt;br /&gt;
samtools 문서를 보면 아래처럼 나와있습니다. &lt;a href=&quot;http://www.htslib.org/doc/samtools-flagstat.html&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;결과 이름&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;secondary&lt;/td&gt;
      &lt;td&gt;0x100 bit set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;supplementary&lt;/td&gt;
      &lt;td&gt;0x800 bit set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;duplicates&lt;/td&gt;
      &lt;td&gt;0x400 bit set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapped&lt;/td&gt;
      &lt;td&gt;0x4 bit not set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;paired in sequencing&lt;/td&gt;
      &lt;td&gt;0x1 bit set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read1&lt;/td&gt;
      &lt;td&gt;both 0x1 and 0x40 bits set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read2&lt;/td&gt;
      &lt;td&gt;both 0x1 and 0x80 bits set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;properly paired&lt;/td&gt;
      &lt;td&gt;both 0x1 and 0x2 bits set and 0x4 bit not set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;with itself and mate mapped&lt;/td&gt;
      &lt;td&gt;0x1 bit set and neither 0x4 nor 0x8 bits set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;singletons&lt;/td&gt;
      &lt;td&gt;both 0x1 and 0x8 bits set and bit 0x4 not set&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;with mate mapped to a different chr&lt;/td&gt;
      &lt;td&gt;0x1 bit set and neither 0x4 nor 0x8 bits set and MRNM not equal to RNAME&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;with mate mapped to a different chr (mapQ&amp;gt;=5)&lt;/td&gt;
      &lt;td&gt;0x1 bit set and neither 0x4 nor 0x8 bits set and MRNM not equal to RNAME and MAPQ &amp;gt;= 5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;왜인지 몰라도 16진수로 써놨어요.&lt;br /&gt;
밑에는 16진수 표기가 아닌 bit 와 2진수에 따라서 좀 더 보기 편하게 표를 정리해봤어요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;결과 이름&lt;/th&gt;
      &lt;th&gt;bit&lt;/th&gt;
      &lt;th&gt;2진수&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;secondary&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td&gt;000100000000&lt;/td&gt;
      &lt;td&gt;secondary alignment&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;supplementary&lt;/td&gt;
      &lt;td&gt;2048&lt;/td&gt;
      &lt;td&gt;100000000000&lt;/td&gt;
      &lt;td&gt;supplementary alignment&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;duplicates&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td&gt;010000000000&lt;/td&gt;
      &lt;td&gt;PCR or optical duplicate&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapped&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;000000000100&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;NOT&lt;/strong&gt; segment unmapped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;paired in sequencing&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;000000000001&lt;/td&gt;
      &lt;td&gt;template having multiple segments in sequencing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read1&lt;/td&gt;
      &lt;td&gt;1 AND 64&lt;/td&gt;
      &lt;td&gt;000000000001&lt;br /&gt;000001000000&lt;/td&gt;
      &lt;td&gt;- template having multiple segments in sequencing&lt;br /&gt;- the first segment in the template&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read2&lt;/td&gt;
      &lt;td&gt;1 AND 128&lt;/td&gt;
      &lt;td&gt;000000000001&lt;br /&gt;000010000000&lt;/td&gt;
      &lt;td&gt;- template having multiple segments in sequencing&lt;br /&gt;- the last segment in the template&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;properly paired&lt;/td&gt;
      &lt;td&gt;1 AND 2 AND &lt;strong&gt;NOT&lt;/strong&gt; 4&lt;/td&gt;
      &lt;td&gt;000000000001&lt;br /&gt;000000000010&lt;br /&gt;000000000100&lt;/td&gt;
      &lt;td&gt;- template having multiple segments in sequencing&lt;br /&gt;- each segment properly aligned according to the aligner&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; segment unmapped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;with itself and mate mapped&lt;/td&gt;
      &lt;td&gt;1 AND &lt;strong&gt;NOT&lt;/strong&gt; 4 AND &lt;strong&gt;NOT&lt;/strong&gt; 8&lt;/td&gt;
      &lt;td&gt;000000000001&lt;br /&gt;000000000100&lt;br /&gt;000000001000&lt;/td&gt;
      &lt;td&gt;- template having multiple segments in sequencing&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; segment unmapped&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; next segment in the template unmapped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;singletons&lt;/td&gt;
      &lt;td&gt;1 AND 8 AND &lt;strong&gt;NOT&lt;/strong&gt; 4&lt;/td&gt;
      &lt;td&gt;000000000001&lt;br /&gt;000000001000&lt;br /&gt;000000000100&lt;/td&gt;
      &lt;td&gt;- template having multiple segments in sequencing&lt;br /&gt;- next segment in the template unmapped&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; segment unmapped&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;with mate mapped to a different chr&lt;/td&gt;
      &lt;td&gt;1 AND &lt;strong&gt;NOT&lt;/strong&gt; 4 AND &lt;strong&gt;NOT&lt;/strong&gt; 8&lt;br /&gt;AND MRNM not equal to RNAME&lt;/td&gt;
      &lt;td&gt;000000000001&lt;br /&gt;000000000100&lt;br /&gt;000000001000&lt;/td&gt;
      &lt;td&gt;- template having multiple segments in sequencing&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; segment unmapped&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; next segment in the template unmapped&lt;br /&gt;- mate reference name != references sequence name&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;with mate mapped to a different chr (mapQ&amp;gt;=5)&lt;/td&gt;
      &lt;td&gt;1 AND &lt;strong&gt;NOT&lt;/strong&gt; 4 AND &lt;strong&gt;NOT&lt;/strong&gt; 8&lt;br /&gt;AND MRNM not equal to RNAME&lt;br /&gt;AND MAPQ &amp;gt;= 5&lt;/td&gt;
      &lt;td&gt;000000000001&lt;br /&gt;000000000100&lt;br /&gt;000000001000&lt;/td&gt;
      &lt;td&gt;- template having multiple segments in sequencing&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; segment unmapped&lt;br /&gt;- &lt;strong&gt;NOT&lt;/strong&gt; next segment in the template unmapped&lt;br /&gt;- mate reference name != references sequence name&lt;br /&gt;- mapping quality &amp;gt;= 5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;저도 각 결과값이 뭔지 세세히는 알지 못했는데, 이렇게 정리하고 나니 어떤 flag 를 사용해 만들어진 결과인지 알 수 있었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘은 bam/sam 에 있는 flag 에 대한 설명과, flagstat 결과가 ‘실제로’ 무엇을 의미하는지 살펴봤습니다.&lt;br /&gt;
표로 정리해봤는데 더 복잡해 보이기도 하네요 ^^;&lt;br /&gt;
그러나 그냥 결과를 보고 ‘그런가보다’ 하는것보다, 실제로 어떤 걸 가리키는 값인지 이해하면 더 좋겠죠?&lt;/p&gt;

&lt;p&gt;그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Jun 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2021/06/13/samtools-flagstat.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2021/06/13/samtools-flagstat.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>Human reference genome - GRCh37 과 GRCh38 에 대하여</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
오늘은 사람의 reference genome 에 대해 이야기하려 해요.&lt;br /&gt;
그리고 가장 널리 쓰이는 GRCh37 와 GRCh38 이 어떻게 다른지 이야기해보려 합니다.&lt;br /&gt;
이 내용은 다음 논문의 내용을 요약한 것입니다: &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0888754317300058?via%3Dihub&quot;&gt;Guo et al., Genomics, 2017&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;reference genome 을 간단히 설명하자면,&lt;br /&gt;
어떤 개체의 genome 서열을 대표하는 뉴클레오티드 서열 데이터를 말합니다.&lt;br /&gt;
이중 사람의 reference genome 도 존재하죠.&lt;br /&gt;
그런데, 사람마다 서열이 조금씩 다르기 때문에 사람의 reference genome 서열과 나의 서열은 약간 다를 것입니다.&lt;br /&gt;
사람의 reference genome 은 ‘대표’되는 서열을 만들기 위해 여러명이 기증한 샘플로 만들어낸 거죠.&lt;/p&gt;

&lt;p&gt;reference genome 을 만드는 기관은 &lt;strong&gt;GRC (Genome Reference Consortium)&lt;/strong&gt; 입니다.&lt;br /&gt;
그리고 여기서 만든 reference genome 중 &lt;strong&gt;사람 (h)&lt;/strong&gt; 의 &lt;strong&gt;버전 38&lt;/strong&gt; 에 해당하는 것이 바로 우리가 흔히 보는 &lt;strong&gt;GRCh38&lt;/strong&gt; 인 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그럼 reference genome 은 어떻게 만들까요?&lt;/strong&gt;&lt;br /&gt;
genome 을 알아내기 위해서는 ‘genome assembly’ 라는 과정을 거쳐야 합니다.&lt;br /&gt;
이는 짧은 서열인 read 들을 서로 공통된 부분끼리 붙여서 점점 길게 붙여나가는 과정이죠.&lt;br /&gt;
아래 그림에 간단히 설명되어 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210530/figure1.jpeg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;출처: Guo et al., Genomics (2017)&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그림을 보시면 Reads 를 붙여서 contig 를 만들고, 다시 contig 들을 붙여서 scaffold 를 만들고,&lt;br /&gt;
마지막으로 이 scaffold 들을 붙여 염색체 하나를 이루게 되는 것입니다.&lt;/p&gt;

&lt;p&gt;현재 기술로는 ‘완벽하게 정확한’ genome sequence 를 알아내는 것이 힘듭니다.&lt;br /&gt;
그래서 계속 수정에 수정을 거쳐 더 정확한 reference genome 버전이 만들어지는 것이죠.&lt;br /&gt;
완벽한 genome sequence 를 만들기 힘든 이유를 간단히 말하자면, &lt;br /&gt;
&lt;strong&gt;Error-prone short reads 를 통해 error-prone repeat 을 가진 large sequence 를 조립하는 것이 매우 힘들기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
그래서 가장 최신 버전인 GRCh38 조차도 아직 서열을 알 수 없는 Gap 부분이 많이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;최근 GRC 에서 이런 에러와 gap 을 해결한 human reference genome 을 만들었다고 하네요.&lt;/strong&gt;&lt;br /&gt;
얼마전까지만 해도 완벽하게 만들 수 없다고 생각했는데 말이죠.&lt;br /&gt;
관심 있으신 분들은 이 논문을 참고해보세요: &lt;a href=&quot;https://www.biorxiv.org/content/10.1101/2021.05.26.445798v1&quot;&gt;링크&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;grch37-과-grch38-의-차이점&quot;&gt;GRCh37 과 GRCh38 의 차이점&lt;/h3&gt;
&lt;p&gt;이제 본론으로 돌아와서, GRCh37 과 GRCh38 이 어떻게 다른지 이야기 해볼게요.&lt;br /&gt;
2009 년, GRC 는 HG19 라고도 불리는 새로운 버전의 human reference genome GRCh37 을 발표합니다.&lt;br /&gt;
이 때는 일루미나의 high-throughput sequencing 기술을 사용했습니다.&lt;br /&gt;
몇년 뒤인 2013년, GRC 는 또 다른 reference genome 인 GRCh38 을 발표하게 됩니다.&lt;br /&gt;
이 때는 &lt;strong&gt;더 많은 donor sample&lt;/strong&gt; 을 사용했으며, &lt;strong&gt;Sanger sequencing&lt;/strong&gt; 기술을 사용해 더 길고 정확한 reads 를 만들었습니다.&lt;br /&gt;
당연히 더 정확한 서열을 만들어냈겠죠?&lt;br /&gt;
실제로 GRCh37 이 가지고 있던 문제들을 1000개 이상 해결했다고 합니다.&lt;/p&gt;

&lt;p&gt;그럼 이 두 가지 reference genome 이 실제 분석상으로 어떤 차이가 있을까요?&lt;br /&gt;
논문에서 언급한 두 reference genome 의 차이점을 아래 표에 간단히 정리해보았어요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature&lt;/th&gt;
      &lt;th&gt;GRCh37&lt;/th&gt;
      &lt;th&gt;GRCh38&lt;/th&gt;
      &lt;th&gt;change&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Total nucleotides&lt;/td&gt;
      &lt;td&gt;3,095,677,412&lt;/td&gt;
      &lt;td&gt;3,088,269,832&lt;/td&gt;
      &lt;td&gt;7,407,580 ▼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;# of “N” (gap / unannotated regions)&lt;/td&gt;
      &lt;td&gt;234,350,281&lt;/td&gt;
      &lt;td&gt;150,630,719&lt;/td&gt;
      &lt;td&gt;83,719,562 ▼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GC contents&lt;/td&gt;
      &lt;td&gt;1,170,371,008&lt;/td&gt;
      &lt;td&gt;1,200,551,672&lt;/td&gt;
      &lt;td&gt;30,180,664 ▲&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Exome size&lt;/td&gt;
      &lt;td&gt;75,231,228&lt;/td&gt;
      &lt;td&gt;95,505,476&lt;/td&gt;
      &lt;td&gt;20,274,248 ▲&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;# of total exon&lt;/td&gt;
      &lt;td&gt;327,058&lt;/td&gt;
      &lt;td&gt;457,748&lt;/td&gt;
      &lt;td&gt;130,690▲&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;median # of exons per gene&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;6▲&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;median # of nucleotides per exon&lt;/td&gt;
      &lt;td&gt;140&lt;/td&gt;
      &lt;td&gt;146&lt;/td&gt;
      &lt;td&gt;6▲&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결과를 보시면, 먼저 전체 nucleotide 수는 0.2% 정도 줄어들었습니다.&lt;br /&gt;
그런데 이보다 더 중요한 건, 바로 “N” 으로 표시된 &lt;strong&gt;gap 이 줄어들었다는 겁니다.&lt;/strong&gt;&lt;br /&gt;
gap 은 centromere 나 telomere 같이 알아내기 힘든 영역을 일단 N 이라고 표시한 부분인데요,&lt;br /&gt;
GRCh37 보다 GRCh38 에서는 이런 N 의 수가 8천만개 이상 줄었다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;여기서 또 주목할 점은 바로 &lt;strong&gt;늘어난 Exome 의 크기&lt;/strong&gt;입니다.&lt;br /&gt;
GRCh37 에 비해 GRCh38 에서 2천만 base pair 만큼, 약 26% 나 늘어난 것을 알 수 있습니다.&lt;br /&gt;
Exon 의 개수도 32만 개에서 45만 개로 40% 정도 늘어났습니다.&lt;br /&gt;
Exome 영역은 genome annotation 에 큰 영향을 주기 때문에, 이렇게 Exome 영역이 늘어났다는 것은 우리가 genome 에서 더 많은 정보를 얻을 수 있게 되었다는 뜻입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;실제-분석에-사용했을-때도-좋을까&quot;&gt;실제 분석에 사용했을 때도 좋을까?&lt;/h3&gt;
&lt;p&gt;위의 정리된 표만 봐서는 아직 GRCh38 이 얼마나 더 좋은건지 알기 힘들 수 있습니다.&lt;br /&gt;
그래서 위 논문에서는 실제 Alignment, Variant call 등의 분석을 진행했을 때 얼마나 좋아지는지도 연구해놓았어요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Alignment rate 비교&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;먼저 해본 것은 30개 샘플에서 얻은 WES 데이터를 각 reference genome 에 alignment 해본 거에요.&lt;br /&gt;
아래 그림에는 이 샘플들의 Mapping rate, Capture efficiency 등을 비교한 결과가 정리되어 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210530/figure2.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;출처: Guo et al., Genomics (2017)&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 결과를 보시면, 먼저 mapping 자체는 두 reference genome 에서 큰 차이가 없는 걸 알 수 있어요.&lt;br /&gt;
&lt;strong&gt;대신, Capture efficiency, 즉 Exome 에 mapping 된 read 비율이 3.2 % 정도 증가했습니다 (그림 B).&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;또한, Intron mapping rate 의 비율은 2.7 % 정도 줄어들었다고 하는군요 (그림 D).&lt;/strong&gt;&lt;br /&gt;
이는 GRCh38 에서 exome 이 더 잘 정의되어 있기 때문에 생긴 결과라고 볼 수 있습니다.&lt;br /&gt;
mapping rate 가 높아지면 더 정확한 분석을 할 수 있으니, GRCh38 을 사용하는게 더 좋을 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Variant calling 비교&lt;/strong&gt;&lt;br /&gt;
alignment 를 진행한 뒤, 논문에서는 30 샘플의 WES 데이터에 어떤 변이가 각각 얼마나 있는지를 알아봤다고 합니다.&lt;br /&gt;
alignment 결과를 보고 reference genome 과 비교해서 변이를 찾는 과정을 &lt;strong&gt;variant calling&lt;/strong&gt; 이라고 합니다.&lt;br /&gt;
과연 GRCh37 을 썼을 때와 GRCh38 을 썼을 때 결과가 어떻게 달라졌을까요?&lt;br /&gt;
아래 표는 30개 WES 샘플에서 발견한 SNV 변이의 종류와 그 수를 나타낸 거에요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Categories&lt;/th&gt;
      &lt;th&gt;Grch37&lt;/th&gt;
      &lt;th&gt;Grch38&lt;/th&gt;
      &lt;th&gt;Difference&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Downstream&lt;/td&gt;
      &lt;td&gt;29,647&lt;/td&gt;
      &lt;td&gt;29,841&lt;/td&gt;
      &lt;td&gt;194&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Exonic&lt;/td&gt;
      &lt;td&gt;46,524&lt;/td&gt;
      &lt;td&gt;46,363&lt;/td&gt;
      &lt;td&gt;− 161&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Exonic; splicing&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Intergenic&lt;/td&gt;
      &lt;td&gt;2,627,378&lt;/td&gt;
      &lt;td&gt;2,585,510&lt;/td&gt;
      &lt;td&gt;− 41,868&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Intronic&lt;/td&gt;
      &lt;td&gt;1,651,974&lt;/td&gt;
      &lt;td&gt;1,642,466&lt;/td&gt;
      &lt;td&gt;− 9508&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ncrna_exonic&lt;/td&gt;
      &lt;td&gt;14,881&lt;/td&gt;
      &lt;td&gt;15,107&lt;/td&gt;
      &lt;td&gt;226&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ncrna_exonic; splicing&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ncrna_intronic&lt;/td&gt;
      &lt;td&gt;215,486&lt;/td&gt;
      &lt;td&gt;228,021&lt;/td&gt;
      &lt;td&gt;12,535&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ncrna_splicing&lt;/td&gt;
      &lt;td&gt;77&lt;/td&gt;
      &lt;td&gt;76&lt;/td&gt;
      &lt;td&gt;− 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Splicing&lt;/td&gt;
      &lt;td&gt;146&lt;/td&gt;
      &lt;td&gt;138&lt;/td&gt;
      &lt;td&gt;− 8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Upstream&lt;/td&gt;
      &lt;td&gt;26,203&lt;/td&gt;
      &lt;td&gt;25,884&lt;/td&gt;
      &lt;td&gt;− 319&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Upstream; downstream&lt;/td&gt;
      &lt;td&gt;971&lt;/td&gt;
      &lt;td&gt;1213&lt;/td&gt;
      &lt;td&gt;242&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Utr3&lt;/td&gt;
      &lt;td&gt;36,065&lt;/td&gt;
      &lt;td&gt;36,031&lt;/td&gt;
      &lt;td&gt;− 34&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Utr5&lt;/td&gt;
      &lt;td&gt;7076&lt;/td&gt;
      &lt;td&gt;7176&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Utr5; Utr3&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Total&lt;/td&gt;
      &lt;td&gt;4,656,461&lt;/td&gt;
      &lt;td&gt;4,617,859&lt;/td&gt;
      &lt;td&gt;− 38,602&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;가장 마지막에 있는 Total 을 보시면, 발견한 SNV 변이의 수가 GRCh38 에서 38,602 개 만큼 줄었어요.&lt;br /&gt;
그리고 Exonic, 즉 exon 영역에 발생한 변이의 수 역시 161 개 줄었네요.&lt;br /&gt;
이렇게만 보면 “GRCh38 을 써서 더 적은 변이를 발견했으니 안좋은 거 아닐까?” 라고 생각할 수 있어요.&lt;/p&gt;

&lt;p&gt;하지만 다음 표를 보시면, GRCh38 에서 더 많은 정보를 얻을 수 있었다는 걸 알 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Categories&lt;/th&gt;
      &lt;th&gt;GRCh37&lt;/th&gt;
      &lt;th&gt;GRCh38&lt;/th&gt;
      &lt;th&gt;Difference&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Nonsynonymous&lt;/td&gt;
      &lt;td&gt;22,372&lt;/td&gt;
      &lt;td&gt;22,538&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stopgain&lt;/td&gt;
      &lt;td&gt;223&lt;/td&gt;
      &lt;td&gt;231&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stoploss&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Synonymous&lt;/td&gt;
      &lt;td&gt;23,178&lt;/td&gt;
      &lt;td&gt;23,270&lt;/td&gt;
      &lt;td&gt;92&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unknown&lt;/td&gt;
      &lt;td&gt;735&lt;/td&gt;
      &lt;td&gt;308&lt;/td&gt;
      &lt;td&gt;− 427&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;total&lt;/td&gt;
      &lt;td&gt;46,535&lt;/td&gt;
      &lt;td&gt;46,374&lt;/td&gt;
      &lt;td&gt;− 161&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 표는 exon 영역 및 splicing 영역에서 일어난 SNV 들의 종류를 보여주고 있습니다.&lt;br /&gt;
GRCh38 을 사용했을 때 전체 SNV 개수는 줄었지만, &lt;strong&gt;nonsynonymous 변이는 늘고 unknown 변이는 줄었어요.&lt;/strong&gt;&lt;br /&gt;
즉, 아미노산 변화를 일으키는 변이를 더 찾을 수 있었고, 뭔지 알 수 없는 변이의 수가 줄었다는 거죠.&lt;br /&gt;
이렇게 GRCh38 을 사용했을 때 더 많은 정보를 얻을 수 있게 되었다는 것을 논문을 통해 알 수 있었습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;결론-grch38-을-사용하는-것이-더-좋다&quot;&gt;결론: GRCh38 을 사용하는 것이 더 좋다&lt;/h3&gt;
&lt;p&gt;논문의 결론 부분에서는 다음과 같이 언급하고 있습니다.&lt;br /&gt;
“… we can safely conclude that GRCh38 is an improvement over GRCh37 and these improvements resulted in more accurate genomic analysis results. …”&lt;br /&gt;
유전체 분석을 더 정확히 할 수 있다는 관점에서 GRCh38 이 GRCh37 보다 더 향상되었다는 것입니다.&lt;br /&gt;
물론 아직 많은 연구기관에서 GRCh37 데이터를 생산 및 분석하고 있지만, 결국에는 GRCh38 혹은 그보다 더 발전된 버전의 reference genome 을 사용해야 하고, 머지않아 그렇게 될 겁니다.&lt;/p&gt;

&lt;p&gt;이렇게 human reference genome 두 종류와, 그들이 어떻게 다른지, 그리고 분석에 어떤 영향을 미칠 수 있는지를 간단히 알아보았어요.&lt;br /&gt;
더 자세한 내용은 논문에 있으니 한번 참고해보세요! 링크: &lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0888754317300058?via%3Dihub&quot;&gt;Guo et al., Genomics, 2017&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 30 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2021/05/30/grch37-grch38.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2021/05/30/grch37-grch38.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>pytest - 효율적인 테스트 코드 작성을 위한 모듈</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
오늘은 python 에서 테스트 코드를 작성할 때 자주 쓰이는 pytest 를 정리해볼 거에요.&lt;br /&gt;
간단한 예제들을 위주로 설명해보도록 할게요.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;pytest-가-뭔가요&quot;&gt;pytest 가 뭔가요?&lt;/h3&gt;
&lt;p&gt;pytest 는 테스트 코드를 효율적으로 작성할 수 있게 해주는 모듈입니다.&lt;br /&gt;
테스트에 필요한 여러가지 다양한 기능들이 있어서 저도 애용하고 있는 모듈이죠.&lt;br /&gt;
테스트에 쓰이는 다른 모듈로는 unittest 같은 모듈도 좋지만 pytest 는 좀더 쉽고 다양한 기능을 제공합니다.&lt;/p&gt;

&lt;p&gt;pytest 는 다음과 같이 설치할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; pip &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;pytest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;pytest-로는-어떤걸-할-수-있나요&quot;&gt;pytest 로는 어떤걸 할 수 있나요?&lt;/h3&gt;
&lt;p&gt;pytest 는 기본적인 테스트 기능에 추가적으로 다음 기능들이 제공됩니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;parametrization 을 통한 여러 테스트 케이스 관리&lt;/li&gt;
  &lt;li&gt;exception 에 대한 테스트&lt;/li&gt;
  &lt;li&gt;fixture 를 사용한 object 제공으로 dependency 해결 및 간단한 코드 작성&lt;/li&gt;
  &lt;li&gt;mark 를 통한 테스트 함수 관리&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래에서 어떤 기능들인지, 뭐가 가능하다는 건지 하나씩 확인해볼게요.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;간단한-테스트-코드&quot;&gt;간단한 테스트 코드&lt;/h3&gt;
&lt;p&gt;먼저 pytest 로 어떻게 파이썬 코드를 테스트 할 수 있는지 알아볼게요.&lt;br /&gt;
test_1.py 라는 코드를 작성해볼까요?&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_1.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;먼저 테스트하고자 하는 함수 get_sum 을 만들었습니다.&lt;br /&gt;
두 숫자를 받아서 이들의 합을 반환하는 아주 간단한 함수죠.&lt;br /&gt;
이 함수가 제대로 작동하는지 테스트하는게 목표입니다.&lt;/p&gt;

&lt;p&gt;그 위에는 이 함수를 테스트할 수 있는 테스트 함수인 test_get_sum 을 만들었어요.&lt;br /&gt;
pytest 를 사용할 때, 테스트 함수는 꼭 앞에 test_ 로 시작하거나 뒤에 _test 로 끝나야 합니다. (그래야 pytest 가 테스트 함수라고 인식해요)&lt;br /&gt;
테스트 코드 안에서는 assert 를 사용해서 실제 함수의 반환값이 예상되는 값과 같은지를 확인합니다.&lt;/p&gt;

&lt;p&gt;위 코드를 작성하고 아래와 같이 코드를 실행하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pytest test_1.py
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/.../temp_pytest
collected 1 item                                                      

test_1.py &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                                    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt; 1 passed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.01s &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;꽤 간단하게 테스트 코드를 짤 수 있었습니다.&lt;br /&gt;
결과를 보면 test_1.py 라는 함수에 “.” 점 하나가 나왔죠?&lt;br /&gt;
이는 이 테스트 코드에서 테스트 하나를 발견했고, 그게 통과(“.”) 했다는 뜻입니다.&lt;br /&gt;
100% 는 해당 코드의 모든 테스트 함수를 실행했다는 뜻이에요.&lt;br /&gt;
그리고 테스트 1개가 pass 즉 통과했고, 0.01초가 걸렸다고 나오고 있군요.&lt;/p&gt;

&lt;p&gt;위에서는 pytest [테스트 코드 이름] 으로 실행했는데, 사실 다른 방법으로도 실행할 수 있어요.&lt;br /&gt;
아래처럼 python -m pytest [테스트 코드 이름] 으로 실행 가능하죠.&lt;br /&gt;
만약 테스트 코드의 이름이 test_~~~.py 혹은 ~~~_test.py 라는 식으로 지었다면, 코드 이름이 아니라 ‘위치’ 만 지정해줘도 됩니다.&lt;br /&gt;
그러면 해당 ‘위치’에 있는 모든 테스트 코드가 다 실행됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; pytest test_1.py 
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/.../temp_pytest
collected 1 item                                                      

test_1.py &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                                     &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt; 1 passed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.01s &lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pytest &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/.../temp_pytest
collected 2 items                                                     

some_test.py &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                                  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 50%]
test_1.py &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                                     &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt; 2 passed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.01s &lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;parametrize-여러-테스트-케이스를-한번에-작성하는-방법&quot;&gt;parametrize: 여러 테스트 케이스를 한번에 작성하는 방법&lt;/h3&gt;
&lt;p&gt;parametrize 라는 기능을 살펴볼까요?&lt;br /&gt;
여기서 만든 get_sum 이라는 함수를 예로 들어볼게요.&lt;br /&gt;
get_sum 함수가 잘 작동하는지 여러가지 경우의 수를 테스트해보고 싶은 상황이에요.&lt;br /&gt;
만약 위와 같은 식으로 테스트 코드를 작성한다고 하면, 각 케이스마다 함수를 하나씩 다 작성해야 할까요?&lt;br /&gt;
그럼 너무 비효율적이겠죠.&lt;/p&gt;

&lt;p&gt;pytest 에는 parametrize 라는 기능이 있어서, 테스트 케이스를 여러번 쓸 필요 없이 한 함수에 여러 테스트 케이스를 적용해볼 수 있답니다.&lt;br /&gt;
다음과 같이 작성하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_2.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parametrize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;num1,num2,expected&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 함수 위에 &lt;strong&gt;@pytest.mark.parametrize&lt;/strong&gt; 라는 데코레이터를 사용하면 됩니다.&lt;br /&gt;
그리고 내부에는 두 가지 인자를 넣으면 되는데요,&lt;br /&gt;
첫 번째 인자를 보면 num1, num2, expected 라는 이름들로, 테스트 함수 내에서 쓰이게 될 변수의 이름이 적혀 있어요.&lt;br /&gt;
두 번째 인자는 “테스트 케이스” 들이 리스트로 들어가 있는 것입니다.&lt;br /&gt;
마지막으로, test_get_sum 의 인자로 해당 num1, num2, expected 를 넣어주면 됩니다.&lt;/p&gt;

&lt;p&gt;이 코드를 해석해보자면 다음과 같습니다.&lt;br /&gt;
&lt;em&gt;첫 번째 테스트에는 num1 = 1, num2 = 2, expected = 3 으로 테스트하고,&lt;br /&gt;
두 번째 테스트에는 num1 = 2, num2 = 3, expected = 5 으로 테스트하고,&lt;br /&gt;
세 번째 테스트에는 num1 = 10, num2 = 15, expected = 25 으로 테스트하고,&lt;br /&gt;
네 번째 테스트에는 num1 = “1”, num2 = “2”, expected = 3 으로 테스트하자.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이를 실행해보면 다음과 같은 결과가 나옵니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pytest test_2.py
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/.../temp_pytest
collected 4 items                                                     

test_2.py ...F                                                  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;==============================&lt;/span&gt; FAILURES &lt;span class=&quot;o&quot;&gt;===============================&lt;/span&gt;
________________________ test_get_sum[1-2-31] _________________________

num1 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;, num2 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2'&lt;/span&gt;, expected &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 3

    @pytest.mark.parametrize&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;num1,num2,expected&quot;&lt;/span&gt;,
        &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1, 2, 3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
            &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2, 3, 5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
            &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;10, 15, 25&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
            &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt;, 3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
        &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
    &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    def test_get_sum&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;num1, num2, expected&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;       assert expected &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; get_sum&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;num1, num2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
E       AssertionError: assert 3 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'12'&lt;/span&gt;
E        +  where &lt;span class=&quot;s1&quot;&gt;'12'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; get_sum&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'2'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

test_2.py:14: AssertionError
&lt;span class=&quot;o&quot;&gt;=======================&lt;/span&gt; short &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;summary info &lt;span class=&quot;o&quot;&gt;=======================&lt;/span&gt;
FAILED test_2.py::test_get_sum[1-2-31] - AssertionError: assert 3 &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;...
&lt;span class=&quot;o&quot;&gt;=====================&lt;/span&gt; 1 failed, 3 passed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.16s &lt;span class=&quot;o&quot;&gt;=====================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;테스트 결과를 보면 “…F” 라고 되어 있죠?&lt;br /&gt;
이는 테스트 네 개 중 세개는 통과 (“.”) 되었고, 하나는 실패 (“F”) 했다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;그리고 아래쪽에는 실패한 케이스에 대한 설명이 나오고 있네요.&lt;br /&gt;
인자로 “1” 과 “2” 를 넣었더니, 당연하게도 문자로 인식되어서 “+” 의 결과가 “12” 가 되었고, 이는 기대하고 있는 값인 3 과는 다르다~ 라는 설명이 나와있습니다.&lt;/p&gt;

&lt;p&gt;이런식으로 함수 하나에 대해 여러 테스트 케이스를 실행할 때는 parametrize 를 사용하면 훨씬 간편하답니다.&lt;br /&gt;
테스트 케이스가 몇십 개가 되더라도 효율적으로 테스트 함수를 작성할 수 있겠죠?&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;pytestraises-exception-에-대한-테스트를-작성하는-방법&quot;&gt;pytest.raises: exception 에 대한 테스트를 작성하는 방법&lt;/h3&gt;
&lt;p&gt;테스트를 하다 보면 exception 에 대한 테스트를 해야 할 때가 있습니다.&lt;br /&gt;
위의 get_sum 을 예로 들면, “숫자” 가 아닌 경우에는 exception 을 제기해야 하는 바로 그 경우죠.&lt;br /&gt;
이런 경우 우리가 원하는 exception이 제대로 나오는지 확인할 수 있을까요?&lt;/p&gt;

&lt;p&gt;pytest 는 이를 테스트할 수 있는 간단한 방법을 제공합니다.&lt;br /&gt;
다음 코드를 보시죠:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_3.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;raises&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;새로 만든 get_sum 함수는 두 인자가 모두 int 타입인지 확인하는 단계가 추가됐어요.&lt;br /&gt;
만약 두 인자 중 하나라도 int 타입이 아니라면 TypeError 를 내게 되어 있죠.&lt;br /&gt;
이 TypeError 가 제대로 나는지 확인하기 위해 test_get_sum_raise_type_error 를 작성했습니다.&lt;br /&gt;
&lt;strong&gt;with pytest.raises([exception 종류]):&lt;/strong&gt; 라는 구문은 이 구문 안의 함수가 지정해준 exception 을 내는지를 확인해줍니다.&lt;br /&gt;
만약 지정해준 exception 이 아닌 다른 exception 을 낸다면 fail 이 뜰겁니다.&lt;/p&gt;

&lt;p&gt;한번 확인해볼까요?&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pytest test_3.py       
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/.../temp_pytest
collected 1 item                                                      

test_3.py &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                                     &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt; 1 passed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.01s &lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 다른 종류의 exception 을 기대한다면 어떻게 될까요?&lt;br /&gt;
다음 코드로 테스트 해볼게요.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_4.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;raises&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;KeyError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 코드는 KeyError 가 나는지 확인하도록 되어있죠?&lt;br /&gt;
코드를 실행해보면 다음과 같이 나올 거에요:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pytest test_4.py
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/.../temp_pytest
collected 1 item                                                      

test_4.py F                                                     &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;==============================&lt;/span&gt; FAILURES &lt;span class=&quot;o&quot;&gt;===============================&lt;/span&gt;
____________________________ test_get_sum _____________________________

    def test_get_sum&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;:
        num1 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;
        num2 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 2
        expected &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 3
        with pytest.raises&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;KeyError&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;           assert expected &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; get_sum&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;num1, num2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

test_4.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

num1 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;, num2 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 2

    def get_sum&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;num1: int, num2: int&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; -&amp;gt; int:
        &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;not isinstance&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;num1, int&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; or not isinstance&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;num2, int&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;           raise TypeError
E           TypeError

test_4.py:15: TypeError
&lt;span class=&quot;o&quot;&gt;=======================&lt;/span&gt; short &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;summary info &lt;span class=&quot;o&quot;&gt;=======================&lt;/span&gt;
FAILED test_4.py::test_get_sum - TypeError
&lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt; 1 failed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.14s &lt;span class=&quot;o&quot;&gt;==========================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;코드에 적어놓은 KeyError 가 아니라 TypeError 가 났다고 하네요.&lt;br /&gt;
이렇게 pytest.raises 를 사용하면 원하는 함수의 exception 을 실제로 확인해볼 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;fixture-여러-테스트-함수에서-반복적으로-쓰이는-데이터를-관리하는-방법&quot;&gt;fixture: 여러 테스트 함수에서 반복적으로 쓰이는 데이터를 관리하는 방법&lt;/h3&gt;
&lt;p&gt;여러 테스트 함수에 특정 데이터가 반복적으로 쓰이는 경우가 있죠?&lt;br /&gt;
이렇게 반복적으로 쓰이는 걸 매번 테스트 함수에서 정의하려면 번거로울 수 있어요.&lt;/p&gt;

&lt;p&gt;pytest 에서는 이를 관리할 수 있는 &lt;strong&gt;fixture&lt;/strong&gt; 라는 기능을 제공합니다.&lt;br /&gt;
fixture 를 사용하면 여러 테스트 함수에서 사용되는 공통된 인자를 관리할 수 있습니다.&lt;br /&gt;
(parametrize 가 ‘공통된 테스트 함수에서 사용되는 여러 인자’ 를 관리하는 기능인 것과 대조되는군요)&lt;br /&gt;
fixture 를 사용하면 데이터 간의 dependency 도 쉽게 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 예제로 쉽게 설명해볼게요.&lt;br /&gt;
나이 정보를 담고있는 dictionary 형태의 데이터를 반복적으로 쓰는 함수들을 테스트하는 상황입니다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_5.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_sum_age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Will&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Kay&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Derrick&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ken&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;122&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum_age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_age_by_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Will&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Kay&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Derrick&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ken&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ken&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_age_by_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum_age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()])&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_age_by_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 보면, sum_age 함수와 get_age_by_name 함수 모두 age_data 를 공통적으로 쓰고 있군요.&lt;br /&gt;
그런데 만약 age_data 가 매우 크다면 반복적으로 쓰는게 번거로울 수 있겠죠? 코드도 길어지구요.&lt;br /&gt;
그리고 혹시나 반복적으로 작성하면서 실수가 생길 수도 있구요.&lt;/p&gt;

&lt;p&gt;이를 fixture 로 한번 해결해봅시다. 다음 코드를 한번 보세요.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_6.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fixture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Will&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Kay&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Derrick&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ken&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_sum_age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;122&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum_age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_age_by_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Ken&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_age_by_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum_age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()])&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_age_by_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;age_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;맨 위 함수를 보면, &lt;strong&gt;@pytest.fixture&lt;/strong&gt; 라는 데코레이터를 써서 age_data 를 만들었습니다.&lt;br /&gt;
이 함수의 반환값은 이 함수의 이름으로 접근할 수 있게 됩니다.&lt;br /&gt;
이제 이 코드의 모든 테스트 함수들은 age_data 를 인자로 받아서 쓰면 되는 거죠. (마치 global 변수처럼요)&lt;br /&gt;
한번만 만들어 두면 여러 함수에서 쓰일 수 있고, 이렇게 만든 데이터는 어디에서나 동일할 것이기 때문에 안심하고 효율적으로 테스트를 작성할 수 있게 된 거에요.&lt;br /&gt;
또한, 만약 이렇게 만들어야 하는 데이터가 오랜 시간이 걸리는 것이라면, 한 번만 만들어두는게 여러 테스트에서 사용하기에 효율적이겠죠?&lt;br /&gt;
fixture 를 사용하면 이렇게 여러 방면에서 효율적으로 쓸 수 있습니다!&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;mark-테스트-함수에-표시를-남겨서-테스트할-함수를-지정하는-방법&quot;&gt;mark: 테스트 함수에 표시를 남겨서 테스트할 함수를 지정하는 방법&lt;/h3&gt;
&lt;p&gt;여러 테스트 함수를 작성하다 보면, 이중 특정 테스트 함수만 확인하고 싶을 때가 있습니다.&lt;br /&gt;
pytest.mark 를 사용하면 이런 과정을 좀 더 효율적으로 할 수 있습니다.&lt;br /&gt;
다음 코드를 한번 확인해보세요:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_7.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;raises&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;group2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum_4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;raises&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 보면 테스트 함수가 4개 있습니다.&lt;br /&gt;
각 테스트 함수의 위에는 &lt;strong&gt;@pytest.mark.[마크 이름]&lt;/strong&gt; 이 적혀있구요.&lt;br /&gt;
이 mark 를 지정해두면 테스트 코드를 실행시킬 때 특정 mark 에 해당하는 것들만 진행할 수 있습니다.&lt;br /&gt;
다음과 같이 실행합니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;pytest test_7.py &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; group1
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/.../temp_pytest, configfile: pytest.ini
collected 4 items / 2 deselected / 2 selected                         

test_7.py ..                                                    &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;===================&lt;/span&gt; 2 passed, 2 deselected &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.01s &lt;span class=&quot;o&quot;&gt;===================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;pytest 를 실행할 때 -m 옵션을 주고 특정 mark “group1” 을 지정했어요.&lt;br /&gt;
이렇게 하면 group1 이라는 mark 가 있는 테스트 함수만 실행됩니다.&lt;br /&gt;
결과를 보시면 4 개의 테스트를 찾았는데, 이 중 2 개만 선택되었다는 알림이 나옵니다.&lt;br /&gt;
이런식으로 특정 테스트 함수만 실행하는 것이 가능한거죠!&lt;/p&gt;

&lt;p&gt;또한, 특정 함수를 &lt;strong&gt;스킵&lt;/strong&gt;하는 것도 가능합니다.&lt;br /&gt;
&lt;strong&gt;@pytest.mark.skip&lt;/strong&gt; 을 데코레이터로 쓰면 됩니다.&lt;br /&gt;
다음 코드를 보시죠.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# test_8.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pytest&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pytest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;skip&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_get_sum_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;총 3 개의 테스트 함수가 있는데, 이 중 세 번째 함수 위에 @pytest.mark.skip 을 달아놨어요.&lt;br /&gt;
이제 이 함수는 테스트에서 빠질 거고, 나머지 두 개만 실행될겁니다.&lt;br /&gt;
실행 장면을 한번 확인해보세요:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pytest test_8.py
&lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test &lt;/span&gt;session starts &lt;span class=&quot;o&quot;&gt;=========================&lt;/span&gt;
platform darwin &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Python 3.7.3, pytest-6.1.1, py-1.9.0, pluggy-0.13.1
rootdir: /Users/hanheonjong/Documents/Study/temp_pytest, configfile: pytest.ini
collected 3 items                                                     

test_8.py ..s                                                   &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]

&lt;span class=&quot;o&quot;&gt;====================&lt;/span&gt; 2 passed, 1 skipped &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0.01s &lt;span class=&quot;o&quot;&gt;=====================&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과를 보시면, 세 개의 테스트를 찾았고, 이 중 1 개는 skipped 했다고 나오죠?&lt;br /&gt;
이런식으로 mark 를 잘 사용하면 효율적으로 테스트 코드를 사용하는게 가능합니다!&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;네, 오늘은 pytest 를 사용한 테스트 코드 작성하는 것을 아주 간단하게 알아봤습니다.&lt;br /&gt;
좀 더 깊이 들어가면 pytest 를 사용해 훨씬 복잡한 테스트를 작성하는 게 가능합니다.&lt;br /&gt;
pytest 문서를 한번 확인해보시면 더욱 이해가 잘 되실 거에요!&lt;/p&gt;

&lt;p&gt;제가 작성한 글을 통해 pytest 에 수월하게 입문하셨길 바랍니다.&lt;br /&gt;
그럼 다음시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/python/2021/05/09/pytest1.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/python/2021/05/09/pytest1.html</guid>
        
        
        <category>programming</category>
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Python 의 multithreading 과 multiprocessing 알아보기</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
오늘은 python 에서의 병렬 처리에 대해 공부해보려 해요.&lt;br /&gt;
사실 업무에서 병렬처리를 해야 할 일이 생겼는데, 처음 해보는 거라 잘 모르겠더라구요.&lt;br /&gt;
이번 기회에 공부하면서 정리해보려 하니, 관심 있으신 분들은 참고해 보시면 좋을 것 같아요!&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;이번 글은 많은 글들을 참조해서 작성했습니다.&lt;br /&gt;
주로 Gennaro S. Rodrigues 가 작년에 작성한 글에서 따와서 번역해가며 적어보려 해요: &lt;a href=&quot;https://towardsdatascience.com/multithreading-vs-multiprocessing-in-python-3afeb73e105f&quot;&gt;문서 링크&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 글은 먼저 두 개념을 비교합니다: &lt;strong&gt;multithreading&lt;/strong&gt; vs &lt;strong&gt;multiprocessing&lt;/strong&gt;&lt;br /&gt;
이 둘의 차이는 &lt;strong&gt;thread&lt;/strong&gt; 와 &lt;strong&gt;process&lt;/strong&gt; 의 차이에 기인합니다.&lt;br /&gt;
또한 이것이 &lt;strong&gt;concurrent execution&lt;/strong&gt; 와 &lt;strong&gt;paralle execution&lt;/strong&gt; 의 차이를 만듭니다.&lt;br /&gt;
병렬 처리란 건 다 똑같은 줄 알았는데, 대체 어떤 차이가 있는 걸까요?&lt;/p&gt;

&lt;h3 id=&quot;thread-vs-process&quot;&gt;Thread vs Process&lt;/h3&gt;
&lt;p&gt;이 개념을 이해할 때 원문의 CPU 그림이 매우 도움이 많이 됐습니다.&lt;br /&gt;
그대로 가져오긴 좀 그래서, 제가 이해한대로 다시 그려볼게요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210418/figure1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;Parallel 하게 처리되고 있는 process 들. thread 들은 concurrent 하게 실행되고 있습니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;즉, CPU 하나에서 진행되는 작업은 process 라 하며, 하나의 process 는 여러개의 thread 를 가질 수 있습니다.&lt;br /&gt;
한 process 의 thread 들은 서로 메모리를 공유합니다.&lt;/p&gt;

&lt;p&gt;한 process 가 여러 thread 를 실행하는 것을 &lt;strong&gt;Concurrent execution&lt;/strong&gt; 이라 하고,&lt;br /&gt;
여러 process 를 동시에 실행시키는 것을 &lt;strong&gt;Parallel execution&lt;/strong&gt; 이라 합니다.&lt;/p&gt;

&lt;p&gt;이에 따르면, &lt;strong&gt;multithreading&lt;/strong&gt; 은 여러 thread 를 동시에 실행하는 것을 말하구요 (concurrency),&lt;br /&gt;
&lt;strong&gt;multiprocessing&lt;/strong&gt; 은 여러 process 를 동시에 실행하는 것을 말합니다 (parallelism).&lt;/p&gt;

&lt;h3 id=&quot;둘-중-무엇을-써야-할까&quot;&gt;둘 중 무엇을 써야 할까?&lt;/h3&gt;
&lt;p&gt;이는 현재 작업이 어떤 것이냐에 따라 다릅니다.&lt;br /&gt;
본문에 따르면 multithreading 은 &lt;strong&gt;I/O intensive tasks&lt;/strong&gt; 에 써야 하고,&lt;br /&gt;
그리고 multiprocessing 은 &lt;strong&gt;CPU intensive tasks&lt;/strong&gt; 에 써야 한다고 하네요.&lt;br /&gt;
그 이유가 뭔지 한번 공부해봅시다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Case 1. 여러 작업을 실행하고 싶은데, 이들이 CPU 를 많이 잡아먹지는 않는데 I/O, 즉 읽고 쓰는 작업이 많을 때&lt;/strong&gt;&lt;br /&gt;
이런 경우에는 각 작업들을 thread 로 묶으면 됩니다.&lt;br /&gt;
아마 아래와 같은 작업이 될 거에요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210418/figure2.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예를 들어 읽어야 할 파일이 10개 쯤 되는데, 이를 빠르게 읽고 싶다면 multithreading 을 해야 합니다.&lt;br /&gt;
물론 multiprocessing 으로도 가능하겠지만, multithreading 이 더 유리합니다.&lt;br /&gt;
그리고 읽은 파일들의 데이터를 모두 모아 작업해야 한다면, memory 를 공유하는 multithreading 이 더 빠르고 안전하겠죠?&lt;br /&gt;
이 때, thread 를 2, 3, … 으로 계속 늘릴 수 있지만 속도가 항상 2배, 3배, … 로 늘어나지는 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Case 2. 여러 작업을 실행하고 싶은데, CPU 를 많이 잡아먹는 일, 즉 계산량이 많은 작업일 때&lt;/strong&gt;&lt;br /&gt;
어떤 게산을 여러번 해야할 때는 multiprocessing 에서 이득을 얻을 수 있습니다.&lt;br /&gt;
multiprocessing 은 말 그대로 새로운 process 를 만들어서 계산할 작업을 나누는 것인데요.&lt;br /&gt;
다음과 같은 방식으로 작업이 실행될 겁니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210418/figure3.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 때, process 를 2개, 3개 … 계속 늘릴 수 있는데요, 이 때도 역시 속도가 바로 2배, 3배 … 가 되지는 않습니다.&lt;br /&gt;
설명에 따르면 process 관리에 비용이 들어가기 때문이라고 하는데요, process 초기화 비용 등을 이야기하는 거겠죠?&lt;br /&gt;
그리고 아까 위에서 말한대로 메모리를 공유하지 않기 때문에 해당 데이터를 넘기고 다시 받는 데에 시간이 걸릴 것입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;*참고로 위 본문의 링크를 따라가면 multiprocessing 으로 I/O intensive tasks 를 할 수 있지 않을까? 라며 실험해본 결과가 있습니다.&lt;br /&gt;
결과는 multiprocessing 도 속도를 높여주긴 한다! 였습니다.&lt;br /&gt;
다만, &lt;strong&gt;여전히 multithreading 이 더욱 유리한 이유&lt;/strong&gt;가 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;multithreading 이 결과적으로 더 빠릅니다.&lt;/li&gt;
  &lt;li&gt;multiprocessing 은 초기화 비용이 많이 듭니다.&lt;/li&gt;
  &lt;li&gt;multiprocessing 은 기기의 코어 수 만큼만 병렬처리가 가능합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;간단한-예제들&quot;&gt;간단한 예제들&lt;/h3&gt;
&lt;p&gt;이제 아래에서는 정말 간단한 예제 몇개를 찾아보려 합니다.&lt;br /&gt;
어떻게 작동시키는지만 확인하는 코드라 실제 효율을 체크해보진 않았어요.&lt;br /&gt;
실제로 얼마나 효율이 좋은지는 원문의 jupyter notebook 으로 된 예제를 한번 살펴보시는걸 추천합니다! &lt;a href=&quot;https://github.com/gennsev/Python_MultiProc_Examples/blob/master/Example.ipynb&quot;&gt;해당 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;병렬 처리를 할 수 있는 python module 이 여러가지가 있습니다.&lt;br /&gt;
여기서는&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;concurrent.features 모듈의 Executor&lt;/li&gt;
  &lt;li&gt;multithreading 모듈&lt;/li&gt;
  &lt;li&gt;multiprocess 모듈&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 세 가지를 확인해보려 합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;예제-1-concurrentfeatures-모듈&quot;&gt;예제 1: concurrent.features 모듈&lt;/h3&gt;
&lt;p&gt;concurrent.features 모듈은 여러 작업을 비동기로 실행할 수 있는 인터페이스를 제공해줍니다.&lt;br /&gt;
이를 통해 multi-threading 및 multi-processing 을 진행할 수 있죠.&lt;br /&gt;
다음 문서를 참고해보세요: &lt;a href=&quot;https://docs.python.org/3/library/concurrent.futures.html&quot;&gt;문서 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;아래 예제는 3초 기다렸다가 두 숫자의 합을 출력하는 print_sum 이라는 함수를 병렬처리하는 예제입니다.&lt;br /&gt;
먼저 multi-threading 으로 진행 해보았습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;concurrent.futures&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_workers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;executor 라는 오브젝트를 만들고, 각 함수를 submit 이라는 메서드로 실행했습니다.&lt;br /&gt;
print_sum 함수를 세 번 실행하고, 각각의 실행마다 현재 시간을 같이 출력하게 했습니다.&lt;br /&gt;
만약 병렬처리가 정말로 잘 이루어졌다면 이 세 번의 함수 실행이 거의 동일한 시간을 출력해주겠죠?&lt;br /&gt;
병렬처리가 안되고 순서대로 출력된다면 서로 3초의 시간 간격이 있을 거에요.&lt;br /&gt;
결과는 이렇습니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 threading1.py
3 Sun Apr 18 14:30:27 2021
5 Sun Apr 18 14:30:27 2021
7 Sun Apr 18 14:30:27 2021
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;출력된 시간을 보니 초단위가 같군요. 함수가 병렬로 실행됐음을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;똑같은 작업을 multi-processing 으로 진행해봤습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;concurrent.futures&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessPoolExecutor&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ProcessPoolExecutor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_workers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 결과입니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 processing1.py
3 Sun Apr 18 14:35:48 2021
5 Sun Apr 18 14:35:48 2021
7 Sun Apr 18 14:35:48 2021
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;multiprocessing 역시 동시에 잘 진행되는 것을 확인했습니다.&lt;br /&gt;
이제 여러 작업이 있을 때 IO-bound tasks 인지 CPU-bound tasks 인지에 따라 선택해서 작업하면 되겠군요.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;예제-2-threading-모듈&quot;&gt;예제 2: threading 모듈&lt;/h3&gt;

&lt;p&gt;다음은 threading 이라는 모듈을 사용해 진행하는 예제입니다.&lt;br /&gt;
threading library 에 대한 원본 문서는 &lt;a href=&quot;https://docs.python.org/3.8/library/threading.html&quot;&gt;이 링크&lt;/a&gt; 를 참조하시면 되구요,&lt;br /&gt;
다음 링크에 훨씬 더 많은 예제와 설명이 되어 있으니 참조해보세요! &lt;a href=&quot;https://pymotw.com/2/threading/&quot;&gt;문서 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thread 오브젝트를 만든 뒤, start() 메서드를 사용하면 해당 작업이 실행됩니다.&lt;br /&gt;
이 역시 병렬처리가 제대로 되었는지 확인하기 위해 시간을 출력해보았습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;threading&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;실행 결과입니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 threading2.py
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
3 Sun Apr 18 15:15:59 2021
5 Sun Apr 18 15:15:59 2021
7 Sun Apr 18 15:15:59 2021
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;똑같은 시간이 출력된 걸 보니 병렬처리가 잘 이루어졌군요.&lt;br /&gt;
그리고 맨 아래에 출력하게 한 “done1” 부분이 가장 먼저 출력된 것을 보니, start()를 하면 thread 하나가 독립적으로 작업을 시작하나 봅니다.&lt;/p&gt;

&lt;p&gt;이 예제를 보시면 main thread 가 실행되고, 각각의 sub thread 가 실행되죠.&lt;br /&gt;
main thread 는 내부적으로 모든 thread 가 다 끝날때까지 기다립니다.&lt;br /&gt;
그래서 맨 아래의 “done” 이 출력됐지만 main 이 끝나지 않고 다른 thread 들의 작업을 기다린 걸 보실 수 있습니다.&lt;br /&gt;
이 thread 를 main 의 종료에 상관 없는 thread 로 만들 수도 있습니다. 이를 “daemon” 이라 합니다.&lt;br /&gt;
보통은 이럴 일이 잘 없지만, 만약 이렇게 되면 main 이 끝나기 전 반드시 join() 이라는 메서드로 종료될 때까지 기다려줘야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;main thread 가 끝나기 전, 병렬 처리로 진행된 모든 thread 가 잘 끝났는지 확인하려면 어떻게 해야할까요?&lt;/strong&gt;&lt;br /&gt;
이는 enumerate 메서드로 확인이 가능합니다.&lt;br /&gt;
각 thread 를 iterative 하게 받아서 join 으로 끝나기까지 기다리면 되는거죠.&lt;br /&gt;
이 때, main thread 자체는 join 할 수 없기 때문에 넘어가야 합니다.&lt;/p&gt;

&lt;p&gt;예제를 한번 살펴보겠습니다:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;threading&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;thread3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;main_thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_alive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_alive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;먼저 현재 가지고 있는 모든 thread 를 threading.enumerate() 로 얻어옵니다.&lt;br /&gt;
그 다음, 각 thread 작업을 join() 메서드로 종료를 기다립니다.&lt;br /&gt;
이 때, main thread 는 넘어가도록 합니다.&lt;br /&gt;
각 thread 의 이름을 확인하기 위해 thread.name 으로 출력하고, 각 thread 가 잘 종료되었는지 (아직 살아있는지) is_alive() 로 확인합니다.&lt;br /&gt;
마지막으로, join 으로 모두 끝낸 다음 (print(“done!”) 까지 한 다음) thread 가 어떤 것이 남아있는지 출력해서 확인했습니다.&lt;/p&gt;

&lt;p&gt;다음은 실행 결과입니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 threading3.py
3 Sun Apr 18 16:31:41 2021
5 Sun Apr 18 16:31:41 2021
7 Sun Apr 18 16:31:41 2021
Thread-1 False
Thread-2 False
Thread-3 False
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
MainThread True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;병렬처리는 잘 진행됐습니다.&lt;br /&gt;
join() 을 하고 나니 모든 thread 가 잘 종료되었군요.&lt;br /&gt;
그리고 “done!” 이 출력된 이후 나머지 thread 가 뭐가 있는지 확인해보니 MainThread 말고는 없군요.&lt;br /&gt;
이렇게 안전하게 multi-threading 을 진행하면 될 것 같습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;예제-3-multiprocessing-모듈&quot;&gt;예제 3: multiprocessing 모듈&lt;/h3&gt;
&lt;p&gt;이번엔 multiprocessing 모듈로 간단하게 병렬처리를 확인해보겠습니다.&lt;br /&gt;
원본 문서는 다음 링크를 참조해주세요: &lt;a href=&quot;https://docs.python.org/3.8/library/multiprocessing.html&quot;&gt;문서 링크&lt;/a&gt;&lt;br /&gt;
설명 글에는 대부분의 API 가 threading 모듈과 비슷하게 작성되었다고 하네요.&lt;/p&gt;

&lt;p&gt;multiprocessing 으로 작업하는 방법이 두 가지 있습니다.&lt;br /&gt;
하나는 Pool 이라는 클래스를 이용하는 것입니다.&lt;br /&gt;
Pool 은 a pool of worker processes 를 나타낸다고 하네요.&lt;br /&gt;
Pool 에 있는 다양한 메서드로 병렬처리가 가능합니다. map, apply 등등..&lt;br /&gt;
여기서는 starmap 이라는 걸 사용해서 진행해보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;starmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;starmap 은 해당 함수에 인자를 전달해주는데, map 과 다른 점은 여러 개의 인자를 한번에 전달할 수 있다는 것입니다.&lt;br /&gt;
여기서 Pool(3) 은 총 세 개 까지의 worker process 를 사용한다는 뜻입니다.&lt;br /&gt;
즉 process 를 최대 3개 까지만 사용한다는 거죠.&lt;br /&gt;
다음은 실행 결과입니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 processing1.py
3 Sun Apr 18 16:54:27 2021
5 Sun Apr 18 16:54:27 2021
7 Sun Apr 18 16:54:27 2021
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;동시에 잘 진행된 것 같네요.&lt;/p&gt;

&lt;p&gt;이번엔 Pool 이 아닌 &lt;strong&gt;Process&lt;/strong&gt; 클래스를 사용해볼게요.&lt;br /&gt;
이 작업에서는 위에서 봤던 threading 과 비슷한 메서드들이 많이 나옵니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;process1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아까 threading 에서 본 코드와 매우 유사하죠?&lt;br /&gt;
실행 결과도 다음과 같이 거의 같습니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 processing2.py
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
3 Sun Apr 18 16:59:00 2021
5 Sun Apr 18 16:59:00 2021
7 Sun Apr 18 16:59:00 2021
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;아까처럼 “done!” 이 가장 먼저 출력됐네요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;main process 가 끝나기 전, 병렬 처리로 진행된 모든 process 가 잘 끝났는지 확인하려면 어떻게 해야할까요?&lt;/strong&gt;&lt;br /&gt;
아까와 같은 식으로 확인해야 합니다.&lt;br /&gt;
다만 multiprocessing 에는 threading 의 enumerate 메서드 대신 active_children() 이 있습니다.&lt;br /&gt;
이걸로 아까처럼 모든 child process 를 join() 으로 종료해보도록 할게요.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;multiprocessing&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;process1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;active_children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_alive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;done!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiprocessing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;active_children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_alive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음은 실행 결과입니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;python3 processing3.py
5 Sun Apr 18 17:17:21 2021
3 Sun Apr 18 17:17:21 2021
7 Sun Apr 18 17:17:21 2021
Process-3 55166 False
Process-2 55165 False
Process-1 55164 False
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아까 threading 이랑의 차이점이라 하면, threading 은 ‘모든 thread’ 를 가져오는 메서드가 있다면 여기서는 ‘모든 active children process’ 를 가져오는 메서드라는 것이죠.&lt;br /&gt;
따라서 여기서 main process 인지 검사할 필요가 없습니다.&lt;br /&gt;
active_children 으로 가져오는 process 는 순서가 상관 없나 봅니다. process-3 부터 출력되네요.&lt;br /&gt;
이렇게 모든 process 를 정상적으로 종료할 수 있었습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;네, 오늘은 multithreading 과 multiprocessing 을 공부해봤습니다.&lt;br /&gt;
작성하고 나니 너무 겉핥기만 한 것 같긴 하네요.&lt;br /&gt;
해당 개념은 여기서 이렇게 짧게 다룬 것 외에도 무척 방대한 양의 개념이 있습니다.&lt;br /&gt;
또한 여기서 다룬 모듈에도 이 예제에 쓰인 것 말고도 무척 다양한 메서드가 있으니, 꼭 원본 문서를 참조해보세요.&lt;br /&gt;
이 글이 병렬 처리의 기본 개념을 쌓는 데 도움이 되시길 바랍니다.&lt;/p&gt;

&lt;p&gt;그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Apr 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/programming/python/2021/04/18/python-multi.html</link>
        <guid isPermaLink="true">http://localhost:4000/programming/python/2021/04/18/python-multi.html</guid>
        
        
        <category>programming</category>
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>CPM, RPKM, FPKM, TPM 알아보기</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
이번 글에서는 RNA-seq 데이터에서 볼 수 있는 Expression value 에 대해 알아보겠습니다.&lt;br /&gt;
RNA-seq 데이터에 써있는 CPM, FPKM 등의 값을 사용하시면서 정확히 어떤건지 모르셨다면 이번 글이 도움이 되실거에요.&lt;/p&gt;

&lt;h3 id=&quot;rna-seq-에서-발현량이란&quot;&gt;RNA-seq 에서 발현량이란?&lt;/h3&gt;

&lt;p&gt;RNA-seq 은 샘플에서 mRNA 를 추출하고 이를 cDNA library 로 만든 다음, 시퀀싱 기계로 읽어내는 실험방법 입니다.&lt;br /&gt;
시퀀싱 기계가 읽어낸 각 cDNA library 조각의 서열을 &lt;strong&gt;read&lt;/strong&gt; 라고 부릅니다.&lt;br /&gt;
이렇게 읽은 각 read 서열이 genome 의 어디에서 온건지 컴퓨터로 알아내는 과정이 바로 &lt;strong&gt;alignment&lt;/strong&gt; (혹은 mapping) 입니다.&lt;br /&gt;
이 과정을 간단히 그려보면 아래와 같아요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210410/figure1.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;RNA-seq 에서 &lt;strong&gt;발현량이란 결국 각 유전자에서 발견된 read 의 개수&lt;/strong&gt;를 의미합니다.&lt;br /&gt;
그림의 아래쪽을 보면 gene A, gene B, gene C 에 여러 개의 read 가 발견된 것을 보실 수 있죠?&lt;br /&gt;
여기서 중요한 질문이 나옵니다: &lt;strong&gt;어떤 유전자의 발현량이 가장 많을까?&lt;/strong&gt;&lt;br /&gt;
이는 계산법에 따라 다른 결과를 가져올 수 있습니다.&lt;br /&gt;
아래에서 CPM, RPKM, FPKM, TPM 을 알아본 뒤에 이 질문의 답을 알아보겠습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;cpm&quot;&gt;CPM&lt;/h3&gt;
&lt;p&gt;CPM 은 counts per million mapped reads 의 약자입니다.&lt;br /&gt;
가장 간단한 발현량 계산법으로, 각 유전자 (혹은 transcript) 에 발견된 read 개수로 발현량을 평가하는 거죠.&lt;/p&gt;

&lt;p&gt;이 때, 실험 결과로 나온 전체 read 개수가 애초에 많았다면 CPM 이 커지게 되므로, 이를 전체 read 개수로 나눠주는 ‘보정’을 해줍니다.&lt;br /&gt;
그런데 보통 전체 read 수가 매우 크니까 (보통 몇천만 개) read 개수를 이걸로 나눠버리면 너무 작은수가 될거에요.&lt;br /&gt;
그래서 million, 즉 백만이라는 숫자를 곱해서 “보기좋은 숫자”로 만들어주면 드디어 CPM 이 완성됩니다.&lt;/p&gt;

&lt;p&gt;어떤 유전자의 read count 를 &lt;em&gt;count&lt;/em&gt;, total read count 를 &lt;em&gt;total&lt;/em&gt; 이라 하면 CPM 은 아래와 같습니다.&lt;br /&gt;
&lt;strong&gt;CPM = count * 1,000,000 / total&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;유전자가 A, B, C 세 개 있고, 각각 read count 가 5, 5, 10 인 경우&lt;br /&gt;
CPM 은 다음과 같이 나타낼 수 있습니다:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Gene&lt;/th&gt;
      &lt;th&gt;read counts&lt;/th&gt;
      &lt;th&gt;CPM&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;(5 * 10&lt;sup&gt;6&lt;/sup&gt;) / 20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;(5 * 10&lt;sup&gt;6&lt;/sup&gt;) / 20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;(10 * 10&lt;sup&gt;6&lt;/sup&gt;) / 20&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(이건 유전자 3개짜리 예시라서 10&lt;sup&gt;6&lt;/sup&gt; 을 곱해주는 보정이 의미가 없네요)&lt;br /&gt;
즉, 발현량은 C 가 제일 많고, A 와 B 가 같네요.&lt;/p&gt;

&lt;p&gt;그런데 단순히 read count 로 세어버리면 오류가 생기지 않을까요?&lt;br /&gt;
그래서 나온 것이 RPKM, FPKM 입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;rpkm-fpkm&quot;&gt;RPKM, FPKM&lt;/h3&gt;
&lt;p&gt;RPKM 먼저 설명드리겠습니다.&lt;br /&gt;
RPKM 은 reads per kilobase of transcript per million mapped reads 의 약자입니다.&lt;br /&gt;
CPM 과 다른점은, 바로 &lt;strong&gt;transcript 의 길이로 보정&lt;/strong&gt;해준다는 점이죠.&lt;/p&gt;

&lt;p&gt;예를 들어 길이가 1,000 basepair 인 transcript A 있고, 길이가 100,000 basepair 인 transcript B 가 있다고 해봅시다.&lt;br /&gt;
두 transcript 에서 똑같이 reads 가 50개씩 발견되었다면, 과연 두 transcript 의 발현량이 똑같은 걸까요?&lt;br /&gt;
왠지 아닌 것 같죠?&lt;br /&gt;
transcript A 보다 B 가 훨씬 더 길기 때문에, B 에서 더 많은 read 가 발견되어야 발현량이 동등하다고 할 수 있겠죠.&lt;br /&gt;
이런 시각을 적용한 계산법이 바로 RPKM 입니다.&lt;br /&gt;
발현량을 구할 때 각 transcript 에서 발견된 read 개수를 &lt;strong&gt;transcript 길이로 나눠서 보정&lt;/strong&gt;해주는 작업이 추가된에요.&lt;br /&gt;
그리고 역시나 transcript 길이가 꽤 큰 값이니까 너무 작아지지 않게 1,000 을 곱해줘서 “보기좋은 숫자”로 만들어줍니다.&lt;/p&gt;

&lt;p&gt;transcript 의 길이를 &lt;em&gt;length&lt;/em&gt; 라고 했을 때, RPKM 은 다음과 같이 계산됩니다.&lt;br /&gt;
&lt;strong&gt;RPKM = (count * 1,000 * 1,000,000) / (length * total)&lt;/strong&gt;&lt;br /&gt;
결과적으로 길이와 전체 개수로 나눈 뒤 10&lt;sup&gt;9&lt;/sup&gt; 을 곱해주는 거에요.&lt;/p&gt;

&lt;p&gt;유전자가 A, B, C 세 개 있고, 각각의 길이가 10, 5, 20 인데 read count 가 각각 5, 5, 10 인 경우,&lt;br /&gt;
RPKM 은 아래처럼 표로 나타낼 수 있습니다:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Gene&lt;/th&gt;
      &lt;th&gt;Length&lt;/th&gt;
      &lt;th&gt;read counts&lt;/th&gt;
      &lt;th&gt;RPKM&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;(5 * 10&lt;sup&gt;9&lt;/sup&gt;) / (10 * 20)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;(5 * 10&lt;sup&gt;9&lt;/sup&gt;) / (5 * 20)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;(10 * 10&lt;sup&gt;9&lt;/sup&gt;) / (20 * 20)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 계산해보니, 발현량은 B 가 제일 많고, A 와 C 가 같군요.&lt;/p&gt;

&lt;p&gt;그렇다면 FPKM 은 뭘까요?&lt;br /&gt;
FPKM 은 RPKM 과 같다고 보시면 됩니다.&lt;br /&gt;
차이점은 RPKM 은 single-end data 에서 쓰이고, FPKM 은 paired-end data 에서 쓰인다는 점이죠.&lt;br /&gt;
paired-end data 에서는 하나의 cDNA library 를 양쪽에서 읽어 두 개의 read 가 만들어지고, 이 두 개의 read 가 한 쌍을 이룹니다.&lt;br /&gt;
이렇게 쌍을 이루는 reads 를 합쳐서 &lt;strong&gt;fragment&lt;/strong&gt; 라고 하죠.&lt;br /&gt;
즉 FPKM 은 read count 대신 fragment count 를 사용한 것 뿐입니다. 계산식도 같습니다.&lt;br /&gt;
약자도 거의 비슷합니다. FPKM = fragments per kilobase of transcript per million mapped reads&lt;/p&gt;

&lt;p&gt;이렇게 계산한 결과를 보면 꽤나 정교하게 보정된 값인 것처럼 보입니다.&lt;br /&gt;
그런데 이렇게 구해진 값이 과연 가장 정확한 발현량 값일까요?&lt;br /&gt;
이런 의문을 해결하기 위해 만들어진 단위가 바로 TPM 입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;tpm&quot;&gt;TPM&lt;/h3&gt;
&lt;p&gt;TPM 은 RPKM, FPKM 과 매우 유사하지만, 계산하는 순서가 조금 다릅니다.&lt;br /&gt;
그 목적이 “샘플 간 비교를 더 정확히 하기 위해서” 라는 것을 기억하세요.&lt;br /&gt;
(물론 그렇다고 RPKM, FPKM 으로 샘플간 비교를 하면 안된다는 뜻은 아닙니다)&lt;/p&gt;

&lt;p&gt;TPM 은 먼저 read count 를 길이로 보정한 뒤, (total read count가 아닌) 이렇게 보정된 값의 총 합으로 각각을 나누는 방법입니다.&lt;/p&gt;

&lt;p&gt;조금 복잡해지니 표로 한번 설명해볼게요.&lt;br /&gt;
먼저 3개의 유전자가 있다고 가정해봅시다: A, B, C&lt;br /&gt;
그리고 각각 길이가 10, 5, 20 이라고 가정합니다.&lt;br /&gt;
read count 가 각각 5, 5, 10 이라고 하면 RPKM 과 TPM 은 다음과 같습니다.&lt;br /&gt;
(비교를 위해서 10&lt;sup&gt;9&lt;/sup&gt; 로 보정해주는 건 잠깐 생략할게요.)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Gene&lt;/th&gt;
      &lt;th&gt;Length&lt;/th&gt;
      &lt;th&gt;read counts&lt;/th&gt;
      &lt;th&gt;RPKM&lt;/th&gt;
      &lt;th&gt;read counts / length&lt;/th&gt;
      &lt;th&gt;TPM&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5 / (10 * 20)&lt;br /&gt;= 0.025&lt;/td&gt;
      &lt;td&gt;0.5&lt;/td&gt;
      &lt;td&gt;5 / (10 * 2)&lt;br /&gt;= 0.25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5 / (5 * 20)&lt;br /&gt;= 0.05&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5 / (5 * 2)&lt;br /&gt;= 0.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10 / (20 * 20)&lt;br /&gt;= 0.025&lt;/td&gt;
      &lt;td&gt;0.5&lt;/td&gt;
      &lt;td&gt;10 / (20 * 2)&lt;br /&gt;= 0.25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;read count 를 length 로 나눈 값은 각각 0.5, 1, 0.5 이구요,&lt;br /&gt;
이를 모두 합하니 2가 되네요.&lt;br /&gt;
따라서 각각의 read count 를 길이 뿐 아니라 “2”로도 나누어주면 바로 TPM 이 되는 겁니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;rpkm-과-tpm-이-어떻게-다른가요&quot;&gt;RPKM 과 TPM 이 어떻게 다른가요?&lt;/h3&gt;

&lt;p&gt;이렇게 해놓고 보니, RPKM 과 10배 차이 난다는 것 빼고는 별다른 차이가 없어 보이죠.&lt;br /&gt;
하지만 TPM 의 목적이 “샘플 간 비교를 더 정확히 하기 위해서” 라고 했죠?&lt;br /&gt;
그러니 이번엔 두 샘플의 값을 비교해보도록 합시다.&lt;/p&gt;

&lt;p&gt;아까와 똑같이 유전자 A, B, C 가 있고, 각각 길이가 10, 5, 20 이라고 가정합시다.&lt;br /&gt;
그리고 sample 1 에서는 read count 가 각각 10, 5, 10 이고, sample 2 에서는 각각 10, 0, 30 이라고 가정해봅시다.&lt;br /&gt;
(여기서도 비교를 위해서 10&lt;sup&gt;9&lt;/sup&gt; 로 보정해주는 건 잠깐 생략할게요.)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Gene&lt;/th&gt;
      &lt;th&gt;Length&lt;/th&gt;
      &lt;th&gt;sample 1&lt;br /&gt;read count&lt;/th&gt;
      &lt;th&gt;sample 2&lt;br /&gt;read count&lt;/th&gt;
      &lt;th&gt;sample 1&lt;br /&gt;RPKM&lt;/th&gt;
      &lt;th&gt;sample 2&lt;br /&gt;RPKM&lt;/th&gt;
      &lt;th&gt;sample 1&lt;br /&gt;TPM&lt;/th&gt;
      &lt;th&gt;sample 2&lt;br /&gt;TPM&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;0.04&lt;/td&gt;
      &lt;td&gt;0.025&lt;/td&gt;
      &lt;td&gt;0.4&lt;/td&gt;
      &lt;td&gt;0.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.04&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;0.02&lt;/td&gt;
      &lt;td&gt;0.038&lt;/td&gt;
      &lt;td&gt;0.2&lt;/td&gt;
      &lt;td&gt;0.6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Count&lt;/strong&gt; 로 보면 gene A 는 sample 1 에서 10, sample 2 에서 10 으로 동일합니다.&lt;br /&gt;
gene C 의 경우 sample 1 에서 10, sample 2 에서 30 으로 세 배 증가했군요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RPKM&lt;/strong&gt; 으로 보면 gene A 는 sample 1 에서 0.04, sample 2 에서 0.025 가 되어서 줄어들었네요.&lt;br /&gt;
gene C 는 sample 1 에서 0.02, sample 2 에서 0.038 로 두배 좀 안되게 늘었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TPM&lt;/strong&gt; 으로 보면 gene A 는 sample 1 에서 0.4, sample 2 에서 0.4 로 동일합니다.&lt;br /&gt;
gene C 는 sample 1 에서 0.2, sample 2 에서 0.6 으로 세 배 늘어난 것으로 나오는군요.&lt;/p&gt;

&lt;p&gt;자, 과연 어떤게 정확한 비교일까요?&lt;br /&gt;
여기서 TPM 중요한 특징이 하나 나옵니다.&lt;br /&gt;
바로 &lt;strong&gt;각 샘플의 TPM 총 합이 모두 동일하다&lt;/strong&gt; 는 점이에요.&lt;br /&gt;
즉, sample 1 의 TPM 합 = 0.4 + 0.4 + 0.2 = 1 이고, sample 2 의 TPM 합 = 0.4 + 0 + 0.6 = 1 로써 동일하다는 겁니다.&lt;br /&gt;
‘샘플 간 비교를 더 정확히 하기 위해서’ 라는 말은 바로 이를 나타나는 것입니다.&lt;br /&gt;
각 샘플의 유전자 발현량의 총 합을 동일하게 만든 값이기 때문에, &lt;strong&gt;특정 샘플에서만 나타날 수 있는 편향을 제거&lt;/strong&gt;했다고 볼 수 있죠.&lt;/p&gt;

&lt;p&gt;요약하자면 “TPM 은 유전자 길이 및 값의 총 합으로 보정했을 뿐 아니라, 각 샘플의 총 합을 동일하게 해서 샘플 간 비교를 더 정확히 할 수 있는 값”이라고 할 수 있겠네요.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;네, 오늘은 CPM, RPKM, FPKM, TPM 에 대해서 알아봤습니다.&lt;br /&gt;
이중 어떤 값을 사용하셔도 무방합니다만, 더 정확히 알고 쓰면 좋겠죠?&lt;br /&gt;
생각보다 쉬운 수식이기 때문에, 여러분이 만약 수식을 정확히 알고 있고 데이터만 있다면 엑셀로 이를 계산하는 것도 불가능한 일은 아닙니다. (데이터가 너무 커서 문제지만…)&lt;br /&gt;
RNA-seq 분석하실 때 도움이 되시길 바랄게요.&lt;/p&gt;

&lt;p&gt;그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Apr 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/sequencing/informatics/2021/04/10/CPM-TPM.html</link>
        <guid isPermaLink="true">http://localhost:4000/sequencing/informatics/2021/04/10/CPM-TPM.html</guid>
        
        
        <category>sequencing</category>
        
        <category>informatics</category>
        
      </item>
    
      <item>
        <title>RNA-seq raw data 부터 분석하는 방법 - 서버 없이!</title>
        <description>&lt;p&gt;안녕하세요, 한헌종입니다.&lt;br /&gt;
오늘은 RNA-seq 데이터를 raw data 부터 분석하는 법을 설명해보고자 합니다.&lt;br /&gt;
RNA-seq 데이터는 GEO 같은 곳에 넘쳐나는데 분석하기 힘드신 분들 계실겁니다.&lt;br /&gt;
또한 실험을 통해 RNA-seq 데이터는 받았는데, raw 데이터만 제공받아서 ‘이걸 어떻게 해야하지’ 하는 분들 많으실 겁니다.&lt;br /&gt;
이런 경우는 리눅스를 다를 줄 모르시거나, 적절한 사양의 서버가 없거나, 다양한 이유가 있을 거에요.&lt;/p&gt;

&lt;p&gt;오늘은 간단하게, 리눅스 명령어 없이, 서버 없이 RNA-seq 데이터를 raw-data 부터 분석하는 법을 말씀드릴 겁니다!&lt;br /&gt;
조금 길더라도 천천히 따라해보시면 여러분도 쉽게 해보실 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;원래는 이런 까만 화면을 통해 리눅스 명령어를 입력해가며 분석해야 하는 일이지만, 오늘은 필요 없어요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;galaxy-서버를-소개합니다&quot;&gt;Galaxy 서버를 소개합니다.&lt;/h3&gt;

&lt;p&gt;자, 어떻게 서버 없이, 명령어 없이 시퀀싱 데이터 분석이 가능한 걸까요?&lt;br /&gt;
이는 Galaxy 라는 클라우드 사이트가 있기 때문에 가능합니다.&lt;br /&gt;
주소는 다음과 같습니다: &lt;a href=&quot;https://usegalaxy.org/&quot;&gt;https://usegalaxy.org/&lt;/a&gt;&lt;br /&gt;
이 Galaxy 라는 서버는, 사용자가 여러 시퀀싱 데이터 및 기타 데이터를 업로드해서 다양한 분석을 할 수 있는 곳입니다.&lt;br /&gt;
한번 접속해서 어떻게 생겼는지 확인해보세요!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;galaxy 홈페이지 입니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이제 이곳을 통해 여러분이 원하시는 분석을 할 수 있습니다.&lt;br /&gt;
사용하시기 전에 &lt;strong&gt;회원가입을 먼저 해주셔야 해요!&lt;/strong&gt;&lt;br /&gt;
이메일 주소로 1분 정도면 가입하실 수 있습니다.&lt;br /&gt;
가입하시고 나면, 여러분의 개인 저장소 약 30 GB 가 제공되고 그때부터 모든 분석이 가능합니다.&lt;/p&gt;

&lt;p&gt;잠깐 galaxy 서버의 외관을 설명드릴게요.&lt;br /&gt;
&lt;strong&gt;왼쪽은 여러분께서 사용하실 수 있는 여러 Tool 이 있습니다. (정말 많습니다)&lt;/strong&gt;&lt;br /&gt;
tool 이 너무 많아서, 종류에 따라 여러 카테고리로 나눠져 있군요.&lt;br /&gt;
데이터 업로드, 텍스트 조작, RNA-seq 분석 등… 나중에 하나씩 살펴보시면서 원하시는 분석 도구가 있는지 확인해보세요!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가운데는 각 Tool 을 선택했을 때 확인하실 수 있는 툴의 여러 parameter, 입력 데이터 등을 조작하는 곳입니다.&lt;/strong&gt;&lt;br /&gt;
왼쪽의 tool 을 하나하나 누를 때마다 가운데 화면이 바뀔 거에요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;오른쪽은 History 칸이 있습니다.&lt;/strong&gt;&lt;br /&gt;
여기에는 여러분께서 진행하시는 여러 분석 단계들 및 중간 결과물들이 기록되는 곳입니다.&lt;br /&gt;
히스토리를 여러개 만들어서 프로젝트마다 관리할 수도 있어요.&lt;/p&gt;

&lt;h3 id=&quot;그럼-분석을-시작해볼까요&quot;&gt;그럼 분석을 시작해볼까요?&lt;/h3&gt;

&lt;p&gt;가장 먼저 해야할 일은 히스토리를 만드는 것입니다.&lt;br /&gt;
(회원가입을 하셨을 테니) 오른쪽 히스토리의 ‘+’ 버튼을 눌러서 한번 만들어 봅시다.&lt;br /&gt;
히스토리의 제목은 프로젝트 이름으로 해놔야 나중에 기억하기 쉽겠죠?&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;저는 그냥 그날 날짜를 해당 히스토리의 제목으로 했습니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;쉽죠? 이제 업로드하는 데이터, 분석 결과 등은 이 히스토리에 쌓이게 될 겁니다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-업로드하기&quot;&gt;데이터 업로드하기&lt;/h3&gt;

&lt;p&gt;그 다음에는 원하는 데이터를 업로드하시면 됩니다.&lt;br /&gt;
그 전에! 그럼 항상 데이터를 컴퓨터에 받은 다음 업로드 해야할까요?&lt;br /&gt;
물론 꼭 그런것은 아닙니다. 지금 여러분의 외장하드에 데이터가 있다면 그렇게 하시면 되지만요.&lt;br /&gt;
&lt;strong&gt;오늘은 GEO 에 있는 public data 를 다운로드 없이 galaxy 에서 사용하는 방법을 보여드릴게요.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그럼 먼저 GEO 에서 데이터를 찾아야겠죠?&lt;br /&gt;
이전 블로그를 보시면, GEO 에서 데이터를 찾는 방법을 보실 수 있을 거에요.&lt;br /&gt;
이번에 찾아야 할 데이터는 특정 GEO series 에서 SRR 리스트를 받아오는 작업입니다.&lt;/p&gt;

&lt;p&gt;(* 잠깐. SRR 이 뭔가요?)&lt;br /&gt;
SRP, SRS, SRR 은 GEO sequence read archive (SRA) 라고 하는 저장소에 데이터들을 구분하기 위해 붙여둔 이름입니다.&lt;br /&gt;
SRP 는 GSE 에 해당합니다. 즉 각 연구 (study) 이고, 이는 여러 샘플의 묶음을 의미합니다.&lt;br /&gt;
SRS 은 GSM 에 해당합니다. 즉 각 샘플 (sample) 의 정보입니다.&lt;br /&gt;
SRX 는 각 실험 (Experiment) 에 대한 정보입니다.&lt;br /&gt;
SRR 은 각 Run 을 의미합니다. 한 개의 샘플을 여러 replicate 으로 시퀀싱을 진행했다면 한 샘플당 run 이 여러개가 있겠죠?&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;그림 출처: https://hbctraining.github.io/&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;우리에게 필요한 것은 한 연구에 포함된 sequencing run 목록, 그러니까 SRR 목록을 가져오는 것입니다.&lt;br /&gt;
원하시는 GEO series 페이지에 들어가시면, 페이지의 아래쪽에서 SRP 정보를 찾으실 수 있습니다.&lt;br /&gt;
이걸 클릭해서 들어가 봅시다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure5.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;이 시리즈는 이전 포스트에서 나왔던 Ovarian cancer study (GSE101108) 입니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;들어가보시면, SRA 사이트의 검색창이 나오고 아래에는 해당 SRP 에 관련된 샘플들이 결과로 나옵니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그런데 샘플이 96개나 되는군요. 한 페이지에 20개씩 밖에 안나오고 SRR 정보는 나오지도 않네요.&lt;br /&gt;
우리가 원하는건 모든 SRR 정보인데 말이죠.&lt;br /&gt;
이를 한번에 받을 수 있는 방법이 있습니다.&lt;br /&gt;
아래 그림처럼 ‘Send to’ 를 누르시고, 여기서 ‘File’ 그리고 ‘Accession list’ 를 누르신 뒤 ‘Create File’ 을 누르시면 됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure7.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 하시면 파일이 하나 다운로드 될 텐데요.&lt;br /&gt;
열어보시면 우리가 원하던 것처럼 SRR&lt;em&gt;**&lt;/em&gt; 라는 목록이 있을 겁니다!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure8.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;저는 예시로 만들고 싶어서 샘플을 3개만 남겨놨어요. 원래 96개가 다 있답니다. ^^;&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 하면 첫 단계가 끝납니다.&lt;/p&gt;

&lt;h3 id=&quot;이제-정말로-galaxy-에-데이터-업로드하기&quot;&gt;이제 정말로 Galaxy 에 데이터 업로드하기&lt;/h3&gt;

&lt;p&gt;SRR 목록을 만들었으니 galaxy 에 업로드 해볼까요?&lt;br /&gt;
왼쪽에 있는 Upload data 를 클릭해보세요.&lt;br /&gt;
그럼 창이 하나 뜨는데, 여기서 밑에 있는 Choose local files 를 누르고 아까 다운받은 SRR 목록 파일을 선택하세요.&lt;br /&gt;
그리고 오른쪽 아래의 ‘Start’ 를 누르시면 SRR 목록 업로드가 시작될 겁니다.&lt;br /&gt;
오른쪽 히스토리에 여러분의 첫 분석 단계가 시작된걸 보실 수 있습니다!&lt;br /&gt;
아래 그림에 과정을 나타내 보았습니다:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure9.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 하면 오른쪽 히스토리에 회색 (작업 전달) -&amp;gt; 주황색 (작업중) -&amp;gt; 초록색 (작업 완료) 순서로 나타날 거에요.&lt;br /&gt;
그리고 각 작업은 ‘번호’ 가 부여되니까, 나중에 이 번호를 참고해서 분석에 사용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 &lt;strong&gt;업로드된 ‘목록’ 을 사용해 ‘실제 파일’ 을 받아볼까요?&lt;/strong&gt;&lt;br /&gt;
왼쪽의 목록 중에 ‘Get Data’ 카테고리에서 ‘Faster Download and Extract Reads in FASTA/Q format from NCBI SRA’ 를 선택해보세요.&lt;br /&gt;
그럼 가운데에 여러 항목이 나오는데요, 여기서 다음 순서대로 진행하시면 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;select input type : List of SRA accession, one per line 선택&lt;/li&gt;
  &lt;li&gt;sra accession list : 방금 업로드한 SRA 목록 (히스토리의 번호 참조) 선택&lt;/li&gt;
  &lt;li&gt;Execute 클릭!&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure10.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 하시면 galaxy 서버가 해당 SRR 들의 데이터를 받고, 알아서 fastq 라는 read data 로 변환해 준답니다.&lt;br /&gt;
이 과정은, 미국 GEO 서버에서 한국 컴퓨터로 데이터 받은 다음 다시 미국 galaxy 서버로 업로드할 필요가 없으니 좀 더 빠른 방법이라고 할 수 있습니다.&lt;br /&gt;
또한, .sra 파일 형식을 분석에 필요한 .fastq 형식으로 알아서 변환해주니 정말 편하죠.&lt;/p&gt;

&lt;p&gt;파일이 업로드되는 시간은 꽤 오래 걸립니다.&lt;br /&gt;
엄청나게 많은 파일을 업로드하시는 거라면… 하루 이틀 기다리셔야 할지도 몰라요.&lt;br /&gt;
어쩔 수 없습니다. 시퀀싱 데이터들은 너무 크기가 커서 오래 걸릴 수밖에 없거든요.&lt;br /&gt;
저는 파일 3개 업로드 하는 데에 반나절 정도 걸렸습니다.&lt;br /&gt;
그러니 마음을 편히 가지시고, 하루에 한번 정도씩 galaxy 사이트에 들어가서 확인해보세요.&lt;/p&gt;

&lt;p&gt;업로드가 다 됐다면, 다음과 같이 3 개의 파일이 생겼을 겁니다!&lt;br /&gt;
여러분이 업로드한 SRR 목록 중 single-end data 모음, paired-end data 모음, other data, 그리고 로그 파일입니다.&lt;br /&gt;
GSE101108 의 데이터들은 모두 paired-end data 이므로 아마 모든 데이터는 paired-end data collection 에 받아져 있을 거에요.&lt;br /&gt;
클릭해보시면, 업로드하신 파일의 목록이 뜰거구요, 각 SRR 을 클릭해보시면 forward, reverse data (paired-end data 이니까) 가 있을 거에요.&lt;br /&gt;
그리고 이를 각각 클릭해보시면 해당 fastq 파일의 스냅샷을 보실 수 있어요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure11.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;그럼-분석을-시작해볼까요-1&quot;&gt;그럼 분석을 시작해볼까요?&lt;/h3&gt;

&lt;p&gt;RNA-seq 데이터를 분석하는 방법은 여러가지가 있습니다.&lt;br /&gt;
(* 여기서 ‘분석’ 이라고 말씀드렸는데, 사실은 raw data 에서 expression matrix 까지 만드는 과정을 말해요. ㅎㅎ)&lt;br /&gt;
기본적으로는, fastq 데이터를 reference genome 을 사용해 alignment 진행하고 이후 quantification 을 진행하는 거에요.&lt;br /&gt;
파일 형식으로 보면 fastq -&amp;gt; bam -&amp;gt; txt, tsv, 등등… 이 되는거죠.&lt;/p&gt;

&lt;p&gt;여기서는 좀 더 빠르게 분석할 수 있는 방법을 사용해볼 거에요!&lt;br /&gt;
fastq 데이터를 reference genome 대신, &lt;strong&gt;reference transcriptome&lt;/strong&gt; 을 사용해 mapping + quantification 을 한번에 하는 방법이죠.&lt;br /&gt;
커다란 genome 파일을 사용하지 않기 때문에 시간도 매우 적게 걸려요. (노트북 사양으로도 가능한 작업이라고 합니다)&lt;br /&gt;
그리고 결과 파일의 크기도 bam 이 아니기 때문에 매우 작답니다. cloud 에서 사용하기에 적절하죠.&lt;br /&gt;
이런 과정을 가능하게 해주는 tool 로는 여러가지가 있는데, 우리는 그 중 &lt;strong&gt;‘kallisto’&lt;/strong&gt; 라는 걸 써볼 겁니다.&lt;/p&gt;

&lt;h3 id=&quot;먼저-준비물을-가져와-볼게요&quot;&gt;먼저, 준비물을 가져와 볼게요.&lt;/h3&gt;
&lt;p&gt;위에서 말씀드린 ‘reference transcriptome’ 파일이 필요합니다.&lt;br /&gt;
우리가 위에서 사용하는 데이터는 human sample 의 데이터이므로, reference 도 역시 human (homo sapiens) 데이터를 가져와야겠죠?&lt;br /&gt;
만약 다른 종의 데이터라면 아래 설명에서 종 정보만 다르게 하시면 나머지는 똑같이 분석하시면 됩니다!&lt;/p&gt;

&lt;p&gt;reference transcriptome 는 RefSeq 이라는, NCBI database 를 사용해 받을거에요.&lt;br /&gt;
다음 링크로 가보시면 ftp 서버를 통해 여러 종의 다양한 시퀀스 정보를 제공하고 있습니다.&lt;br /&gt;
&lt;a href=&quot;https://ftp.ncbi.nlm.nih.gov/refseq/&quot;&gt;https://ftp.ncbi.nlm.nih.gov/refseq/&lt;/a&gt;&lt;br /&gt;
그리고 이 폴더구조에서 human reference transcriptome 정보는 다음 링크로 받으실 수 있어요.&lt;br /&gt;
&lt;strong&gt;https://ftp.ncbi.nlm.nih.gov/refseq/H_sapiens/annotation/GRCh37_latest/refseq_identifiers/GRCh37_latest_rna.fna.gz&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 파일을 직접 받아서 아까처럼 업로드 해도 되는데요, 이번엔 ftp 링크를 통해 파일을 업로드하는 걸 보여드릴게요.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;왼쪽의 Upload Data 를 누르고,&lt;/li&gt;
  &lt;li&gt;아래 메뉴 중 Paste/Fetch data 를 누른 뒤,&lt;/li&gt;
  &lt;li&gt;가운데 창에 위에 알려드린 reference transcriptome 파일의 링크를 복사해서 붙여넣으시면 됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure12.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;이 파일은 크기가 크지 않아서 몇분 내로 받아질 거에요.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 업로드가 다 끝났다면 준비물도 있으니 분석을 해봅시다.&lt;br /&gt;
왼쪽의 검색창에 ‘kallisto’ 를 검색해보세요.&lt;br /&gt;
그럼 아래에 관련된 tool 목록이 나올 겁니다.&lt;br /&gt;
우리는 이중에 ‘Kallisto quant’ 라는 툴을 사용할 겁니다.&lt;br /&gt;
원래 kallisto 진행하려면 reference transcript indexing 을 먼저 해야하는데, 여기선 필요 없습니다.&lt;br /&gt;
사용을 쉽게 하기 위해서 이 작업까지 알아서 진행해주거든요.&lt;/p&gt;

&lt;p&gt;아래와 같이 선택하시면 분석이 진행됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;kallisto 검색&lt;/li&gt;
  &lt;li&gt;Kallisto quant 선택&lt;/li&gt;
  &lt;li&gt;우리가 reference transcriptome 을 업로드 했으니, 이를 사용하도록 &lt;strong&gt;Use a transcriptome from history&lt;/strong&gt; 선택&lt;/li&gt;
  &lt;li&gt;아까 업로드한 transcriptome 파일을 선택 (히스토리 넘버를 잘 기억하세요!)&lt;/li&gt;
  &lt;li&gt;RNA-seq 데이터가 paired-end 데이터이므로 &lt;strong&gt;paired-end&lt;/strong&gt; 선택&lt;/li&gt;
  &lt;li&gt;여러 SRR 을 collection, 즉 묶음으로 업로드 했으니 &lt;strong&gt;Pair of list of pairs&lt;/strong&gt; 를 선택&lt;/li&gt;
  &lt;li&gt;위에서 SRR 목록으로 가져온 RNA-seq 데이터 선택 (히스토리 넘버를 잘 기억하세요!)&lt;/li&gt;
  &lt;li&gt;이제 Excute 를 누르면 분석이 시작됩니다!&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure13.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 분석은 생각보다 빠르게 될 겁니다. (빠르면 십분 이내로?)&lt;br /&gt;
결과는 두 가지가 나오는데요, 아래 tabular 형식이 우리가 흔히 아는 표 형태의 파일입니다.&lt;br /&gt;
각 SRR 마다 파일이 하나씩 나오고, 마지막 column 에 ‘TPM’ 값이 나온답니다.&lt;br /&gt;
우리가 자주 보던 expression level 을 나타내는 값 중 하나죠?&lt;br /&gt;
이제 이 정보를 활용하기만 하면, RNA-seq 분석을 하실 수 있는거에요!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/210307/figure14.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;결과 만들기 끝!&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;그런데-제가-생각한-형태가-아닌데요&quot;&gt;그런데, 제가 생각한 형태가 아닌데요.&lt;/h3&gt;

&lt;p&gt;맞습니다. 사실 이 결과는 분석에 사용하기 쉬운 형태는 아니죠.&lt;br /&gt;
지금 여러분께서 기대하는 형태는 expression matrix 와 다른 점이 몇 가지 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;expression level 이외의 데이터가 들어 있다는 것 (transcript length 등)&lt;/li&gt;
  &lt;li&gt;Gene name 이 아니라 NM.001234 처럼 알 수 없는 이름으로 되어있다는 것 (이건 transcript ID 에요.)&lt;/li&gt;
  &lt;li&gt;결과 파일이 하나가 아니라 각 샘플당 파일 하나씩 여러개 파일로 나누어져 있다는 것&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;사실 이런걸 해결하는 작업이 생명정보학 전공자의 업무의 대부분을 차지한답니다.&lt;br /&gt;
보통 이런 작업은 코딩을 해서 진행하는데, 맨 처음에 그런거 없이 분석할 수 있는 방법을 소개해드린다고 했죠?&lt;br /&gt;
다행히도, Galaxy 사이트에서도 이 작업을 진행하실 수 있습니다!&lt;/p&gt;

&lt;p&gt;먼저 준비물이 필요한데요, gff 라는 파일을 받아와야 해요.&lt;br /&gt;
gff 형식이 무엇인지는 제 블로그의 다른 포스트를 보시면 된답니다 ㅎㅎ &lt;a href=&quot;https://hhj6212.github.io/biology/tech/2020/09/13/bioinformatics-formats2.html&quot;&gt;설명 링크&lt;/a&gt;&lt;br /&gt;
이 gff 파일은 이번 작업에서 transcript 와 gene symbol 간의 관계를 만들 때 사용될 거에요.&lt;/p&gt;

&lt;p&gt;아래 URL 을 사용하셔서, 아까처럼 link 를 통해 데이터 업로드하시면 gff 가 진행됩니다.&lt;br /&gt;
Refseq GRCh37 GFF link: https://ftp.ncbi.nlm.nih.gov/refseq/H_sapiens/annotation/GRCh37_latest/refseq_identifiers/GRCh37_latest_genomic.gff.gz&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Upload data 선택&lt;/li&gt;
  &lt;li&gt;Paste/Fetch data 선택&lt;/li&gt;
  &lt;li&gt;URL 복사&lt;/li&gt;
  &lt;li&gt;‘Type’ 에서 gff3.gz 을 검색해서 선택&lt;/li&gt;
  &lt;li&gt;‘start’ 를 누르면 업로드가 시작됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure15.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 하고나면 gff 파일이 업로드 된답니다.&lt;br /&gt;
준비물이 있으니 다음 단계를 진행해볼까요?&lt;br /&gt;
우리가 이번에 사용할 tool 은 tximport 라는 거에요.&lt;br /&gt;
이것은 transcript 별로 되어있는 RNA-seq 데이터를 Gene 단위로 묶어주는 작업을 해줍니다.&lt;br /&gt;
아래 순서대로 진행하시면 됩니다!&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;왼쪽 tool 에서 tximport 검색&lt;/li&gt;
  &lt;li&gt;검색 결과 중 tximport 선택&lt;/li&gt;
  &lt;li&gt;‘Dataset collections’ 선택&lt;/li&gt;
  &lt;li&gt;아까 만든 Kallisto quant (tabular) 결과물 선택 (히스토리 넘버를 잘 기억하세요!)&lt;/li&gt;
  &lt;li&gt;quantification source 로 ‘Kallisto’ 선택&lt;/li&gt;
  &lt;li&gt;‘Use an external file to map transcript to gene ids’ 선택&lt;/li&gt;
  &lt;li&gt;‘Use one from history’ 를 선택&lt;/li&gt;
  &lt;li&gt;‘GTF/GFF’ 파일 선택&lt;/li&gt;
  &lt;li&gt;select your GFF file 에서 아까 업로드한 GFF 파일 선택 (히스토리 넘버를 잘 기억하세요!)&lt;/li&gt;
  &lt;li&gt;이후 아래쪽에 있는 ‘Execute’ 을 누르면 진행됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure16.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 이 작업을 완료하고 나면 ‘Gene level summarization’ 이라는 결과파일이 하나 생길겁니다.&lt;br /&gt;
이 파일이 여러분들께서 좀 더 작업하기 용이한 &lt;strong&gt;expression matrix&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;각 gene 의 expression level 이 sample 마다 TPM 으로 계산된 데이터입니다.&lt;/strong&gt;&lt;br /&gt;
이 데이터를 활용해서 heatmap 도 그려볼 수 있고, differential expression 도 게산해보실 수 있어요.&lt;br /&gt;
히스토리의 결과에서 디스크 모양을 클릭하시면 결과를 다운받으실 수 있답니다.&lt;br /&gt;
결과는 .txt 파일이지만 이를 엑셀로 열어보시면 됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210307/figure17.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;한 가지 주의해야 할 점이 있는데요, 이 파일을 받아서 엑셀로 열어보시면 맨 위쪽 샘플 이름칸이 하나씩 밀려있는 것을 볼 수 있을 거에요.&lt;br /&gt;
맨 오른쪽 열의 이름이 비어있죠?&lt;br /&gt;
이는 분석 결과가 R 을 사용해 만들어졌기 때문에 일어나는 어쩔 수 없는 일이에요.&lt;br /&gt;
받아보신 뒤 &lt;strong&gt;샘플 이름들을 하나씩 오른쪽으로 옮겨주시고, 첫 열의 이름을 Gene 으로 바꿔주세요.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;네, 오늘은 RNA-seq 데이터를 raw data 에서 expression matrix 까지, 서버 없이 만드는 방법을 말씀드렸어요.&lt;br /&gt;
많은 분들께 유용했으면 좋겠네요.&lt;br /&gt;
사실, 이렇게 RNA-seq 분석을 하는 방법은 매우 다양하고, 그 상황에 맞게 만들어야 정확한 분석이 된답니다.&lt;/p&gt;

&lt;p&gt;다음 시간에는 RNA-seq 결과를 통해서 Differentially Expressed Genes, 즉 DEG 을 찾아내는 방법과 찾아낸 DEG 을 사용해 어떤 분석이 가능한지를 보여드릴게요.&lt;br /&gt;
그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Mar 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/pipeline/informatics/2021/03/07/RNAseq-pipeline.html</link>
        <guid isPermaLink="true">http://localhost:4000/pipeline/informatics/2021/03/07/RNAseq-pipeline.html</guid>
        
        
        <category>pipeline</category>
        
        <category>informatics</category>
        
      </item>
    
      <item>
        <title>데이터 살펴보기 - GEO series 데이터 자세히 확인하는 법</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
이전 포스트에서는 GEO 에서 원하는 데이터를 어떻게 찾는지 설명드렸습니다.&lt;br /&gt;
오늘은 원하는 데이터를 찾은 뒤 이 데이터가 사용 가능한지 확인하는 방법을 설명드리겠습니다.&lt;/p&gt;

&lt;p&gt;물론 GEO 는 open source 이므로 업로드 되어있는 데이터는 모두 사용 가능합니다.&lt;br /&gt;
그럼 데이터가 사용 가능한지를 왜 체크해야 할까요?&lt;br /&gt;
이는 여러분들이 원하는 형태와 종류의 데이터가 있을수도, 없을수도 있기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;1-데이터-종류-확인&quot;&gt;1. 데이터 종류 확인&lt;/h3&gt;

&lt;p&gt;여러분이 먼저 확인해야 할 정보는 바로 데이터가 어떤 종류인지 확인하는 겁니다.&lt;br /&gt;
이 시리즈 데이터가 Microarray 데이터인지 bulk RNA-seq data 인지 single-cell RNA-seq 데이터인지 알아야 쓸지말지 결정할 수 있겠죠?&lt;br /&gt;
보통은 title 에도 나와있을 수 있지만, 더 자세히 확인하는 방법은&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- Experiment type 항목 확인&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;- Platform 항목 확인&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 두가지가 될것 같습니다.&lt;br /&gt;
예시로 GSE101108 샘플을 한번 살펴볼까요?&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210213/figure1.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 시리즈에서는 Experiment type 이 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Expression profiling by high throughput sequencing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 platform 정보는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GPL11154 Illumina HiSeq 2000 (Homo sapiens)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 이 시리즈에는 시퀀싱 플랫폼을 사용한 RNA-seq 데이터가 있는 것입니다.&lt;br /&gt;
더 자세한 내용은 나머지 experimental design 이나 summary, 그리고 나중에 말씀드릴 series matrix 를 살펴보시면 됩니다.&lt;br /&gt;
여러분이 원하는 데이터 종류가 맞는지 꼭 확인하세요!&lt;/p&gt;

&lt;h3 id=&quot;2-제공하는-데이터-형식-확인&quot;&gt;2. 제공하는 데이터 형식 확인&lt;/h3&gt;

&lt;p&gt;자, 원하는 데이터 종류가 맞다면 그 다음으로 해야할 것이 바로 원하는 형식의 데이터를 제공해주는가 입니다.&lt;br /&gt;
만약 여러분께서 각 sample 마다 각 유전자의 발현량이 적혀있는 expression matrix 를 원하신다면, 이 시리즈 데이터가 그것을 제공하는지 꼭 확인해봐야 합니다.&lt;br /&gt;
그 이유는, 보통 Microarray 를 사용한 expression data 는 발현량 intensity data 를 제공하지만, RNA-seq 데이터는 제공하지 않는 경우도 많거든요.&lt;br /&gt;
또한 여러분께서 RNA-seq raw data 인 fastq 파일을 원하신다면, 이 또한 제공되는지 확인해봐야 합니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 데이터를 제공하는지는 어떻게 알 수 있을까요?&lt;br /&gt;
바로 시리즈 데이터 아래쪽에 나온 &lt;strong&gt;Supplementary file&lt;/strong&gt; 부분을 확인하시면 됩니다.&lt;br /&gt;
각 파일마다 Download 컬럼이 있는데, 보시면 http, ftp, custom 등이 적혀있을 겁니다.&lt;br /&gt;
GSE101108 의 경우를 보시면 http, ftp 두개가 있군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210213/figure2.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;http 혹은 ftp 를 누르시면 그 파일이 바로 다운로드 받아질 겁니다.&lt;br /&gt;
custom 이 있는 경우 이를 눌러보면, 만약 그 파일이 여러 파일이 모여있는 거라면 어떤 파일들이 있는지 확인 가능합니다.&lt;br /&gt;
또한 그 파일들 중 일부만 선택해서 다운로드 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 사용 가능한 파일이 있는지 확인해볼까요?&lt;br /&gt;
다운로드 가능한 파일이 .txt.gz 형식이면서 크기는 3.4 Mb 이고, 제목에는 _count 라고 되어있군요.&lt;br /&gt;
아마도 이 데이터의 저자들이 이미 분석해놓은 expression matrix 인것 같습니다.&lt;br /&gt;
다만 FPKM, TPM 이 아닌 count 데이터이므로 normalization 과정이 필요하겠군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210213/figure3.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;맨 아래의 글귀를 확인해보셔도 제공되는 데이터를 확인하실 수 있습니다:&lt;br /&gt;
Raw data are available in SRA: SRA 라는 링크를 통해 fastq 와 같은 raw data 를 받을 수 있다는 뜻입니다.&lt;br /&gt;
Processed data are available on Series record: 어느정도 분석이 완료된 Expression matrix (여기서는 count 로 된 데이터) 가 제공된다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;어떤 시리즈에서는 이렇게 expression matrix, 즉 processed data가 제공되지 않는 경우도 있습니다.&lt;br /&gt;
raw data 만 제공되는 경우인데요, 이런 경우 직접 fastq 파일을 받아서 분석하시는 방법밖에는 없습니다.&lt;br /&gt;
데이터 분석에 익숙하지 않은 분이라면 이런 데이터는 사용하기 힘들 수 있을 거에요.&lt;br /&gt;
그렇기 때문에 이 방법으로 제공되는 데이터의 종류를 확인하시는게 무척 중요합니다!&lt;/p&gt;

&lt;h3 id=&quot;3-데이터를-더욱-자세히-확인하는-방법-series-matrix&quot;&gt;3. 데이터를 더욱 자세히 확인하는 방법: Series matrix&lt;/h3&gt;

&lt;p&gt;데이터가 어디에서 온 샘플이고, 어떻게 만들어졌으며, 어떤 방식으로 분석되었는지 자세히 알고 싶으신가요?&lt;br /&gt;
이런 자세한 정보는 바로 series matrix 라는 데이터에 잘 적혀 있습니다.&lt;/p&gt;

&lt;p&gt;사실 이 파일은 저자가 GEO 에 데이터를 업로드하기 위해 꼭 작성해야 하는 파일 중 하나입니다.&lt;br /&gt;
얼마나 자세히 적을지는 저자에게 달려있지만, 왠만한 정보는 다 적혀있다고 보시면 됩니다.&lt;br /&gt;
또한, Microarray 데이터의 경우에는 이 파일에 Expression matrix 까지 적혀있습니다!&lt;/p&gt;

&lt;p&gt;자, 그럼 series matrix 는 어디서 받을 수 있을까요?&lt;br /&gt;
바로 시리즈 데이터 아래쪽 Download family 중에 있습니다.&lt;br /&gt;
이중 &lt;strong&gt;Series Matrix File(s)&lt;/strong&gt; 를 선택하시면 이를 받을 수 있는 ftp site 로 넘어갑니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210213/figure4.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;다운로드 받으신 데이터는 txt 파일이긴 한데, 실제로는 tsv 파일 (탭으로 나누어진 파일) 입니다.&lt;br /&gt;
좀 더 편하게 보시려면 &lt;strong&gt;Excel 을 통해 열어보시는걸 추천드립니다.&lt;/strong&gt;&lt;br /&gt;
엑셀로 열어보시면, 다음과 같이 데이터의 자세한 정보가 표 형태로 적혀있을 겁니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210213/figure5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Series matrix 는 크게 두 부분으로 나눌 수 있습니다.&lt;br /&gt;
바로 &lt;strong&gt;시리즈에 대한 정보&lt;/strong&gt;와 &lt;strong&gt;샘플에 대한 정보&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;위쪽에는 시리즈에 대한 정보가 나타납니다.&lt;br /&gt;
아까 해당 시리즈 창에서 확인하셨던 데이터가 주로 여기에 그대로 나타날 겁니다.&lt;br /&gt;
GEO accession ID, Submission date, Summary 등이 바로 그 정보입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210213/figure6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그리고 아래쪽에는 각 샘플에 대한 정보가 적혀있습니다.&lt;br /&gt;
여기에는 샘플이 어디서 왔는지, 어떤 culture 조건으로 키웠는지, 사용한 media 는 무엇인지, treatment 는 언제 어떻게 했는지 등이 적혀 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/210213/figure7.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예를 들어 첫 번째 샘플을 볼까요? (GSM2699211)&lt;br /&gt;
다음 정보들이 적혀있습니다.&lt;br /&gt;
early-stage primary invasive ovarian carcinoma 조직에서 가져왔고, 환자 나이는 39세 인 것을 알 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_title&lt;/td&gt;
      &lt;td&gt;Tumor_OV106&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_geo_accession&lt;/td&gt;
      &lt;td&gt;GSM2699211&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_status&lt;/td&gt;
      &lt;td&gt;Public on Oct 04 2018&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_submission_date&lt;/td&gt;
      &lt;td&gt;Jul 10 2017&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_last_update_date&lt;/td&gt;
      &lt;td&gt;May 15 2019&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_type&lt;/td&gt;
      &lt;td&gt;SRA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_channel_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_source_name_ch1&lt;/td&gt;
      &lt;td&gt;Primary invasive ovarian carcinomas&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_organism_ch1&lt;/td&gt;
      &lt;td&gt;Homo sapiens&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_characteristics_ch1&lt;/td&gt;
      &lt;td&gt;tissue: early-stage primary invasive ovarian carcinoma&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_characteristics_ch1&lt;/td&gt;
      &lt;td&gt;figo stage: II&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_characteristics_ch1&lt;/td&gt;
      &lt;td&gt;age: 39&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_molecule_ch1&lt;/td&gt;
      &lt;td&gt;total RNA&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;또한 이 샘플의 데이터를 어떻게 분석했는지에 대한 정보도 매우 자세하게 나오고 있습니다.&lt;br /&gt;
첫 번째 샘플은 다음과 같이 분석되었군요.&lt;br /&gt;
STAR 툴을 사용해 read alignment 를 진행했고, HTSeq 툴을 써서 raw read count를 계산했다고 합니다.&lt;br /&gt;
그리고 Reference genome 은 hg19 를 사용했네요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_description&lt;/td&gt;
      &lt;td&gt;Paired-end strand-specific RNA libraries&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_data_processing&lt;/td&gt;
      &lt;td&gt;Quality control of FASTQ files using FastQC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_data_processing&lt;/td&gt;
      &lt;td&gt;Removal of adapter sequences using TrimGalore wrapper script&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_data_processing&lt;/td&gt;
      &lt;td&gt;FASTQ files were mapped to the human reference genome hg19 using the STAR aligner and the resulting BAM-file was name-sorted&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_data_processing&lt;/td&gt;
      &lt;td&gt;Raw read counts were calculated using htseq-count in htseq&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_data_processing&lt;/td&gt;
      &lt;td&gt;Genome_build: hg19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_data_processing&lt;/td&gt;
      &lt;td&gt;Supplementary_files_format_and_content: The processed data file “OV106-391_counts.txt” is given in text format&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그리고, 마지막으로 샘플을 분석한 기관 및 연락처가 나와있습니다.&lt;br /&gt;
스웨덴의 Sahlgrenska Cancer Center, University of Gothenburg 에서 만들어진 샘플이네요.&lt;br /&gt;
이 외에도 해당 샘플의 raw data 를 어디서 받을 수 있는지도 나와있군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_name&lt;/td&gt;
      &lt;td&gt;Hanna,,Engqvist&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_email&lt;/td&gt;
      &lt;td&gt;hanna.engqvist@gu.se&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_laboratory&lt;/td&gt;
      &lt;td&gt;Sahlgrenska Cancer Center&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_institute&lt;/td&gt;
      &lt;td&gt;University of Gothenburg&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_address&lt;/td&gt;
      &lt;td&gt;Medicinaregatan 1G&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_city&lt;/td&gt;
      &lt;td&gt;Gothenburg&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_zip/postal_code&lt;/td&gt;
      &lt;td&gt;41390&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_contact_country&lt;/td&gt;
      &lt;td&gt;Sweden&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!Sample_data_row_count&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이렇게 각 샘플의 정보를 자세히 살펴보면, 이 데이터가 지금 내가 원하는 조직의 샘플인지, 원하는 실험 조건으로 만들어진 샘플인지 확인할 수 있습니다.&lt;br /&gt;
또한 이 series matrix 의 정보를 통해 샘플들을 특정 조건으로 대조군, 비교군으로 나눌 수 있습니다.&lt;br /&gt;
Series matrix 는 길고 복잡하고 보기 어렵게 되어있지만, 유용한 정보가 많으니 시간이 된다면 확인해보시는게 좋아요.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;네, 오늘은 GEO series 데이터를 어떻게 자세히 살펴볼 수 있는지 설명해봤습니다.&lt;br /&gt;
이 글을 참고하셔서 GEO 데이터를 사용하실 때 좀 더 쉽고 효율적으로 원하는 데이터를 찾고 사용하시길 바랄게요.&lt;br /&gt;
그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Feb 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/database/2021/02/13/GEO2.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/database/2021/02/13/GEO2.html</guid>
        
        
        <category>biology</category>
        
        <category>database</category>
        
      </item>
    
      <item>
        <title>원하는 시퀀싱 데이터 찾기 - GEO 검색 방법</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
오늘은 연구자들이 원하는 데이터를 찾고 싶을 때 가장 많이 검색하게 되는 GEO에 대해 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;GEO 는 Gene Expression Omnibus 의 약자입니다.&lt;br /&gt;
NCBI에서 운영하는 공개 유전체 데이터베이스죠.&lt;br /&gt;
몇몇 연구자분들은 논문을 제출할 때, 이곳에 데이터를 업로드해야 하는 일이 있으셨을 겁니다.&lt;br /&gt;
그만큼 많은 연구자들이 데이터를 업로드하고 사용하는 곳이 바로 GEO입니다.&lt;br /&gt;
GEO 만 잘 사용할 수 있어도, 원하는 데이터를 손쉽게 얻어서 다른 연구에 활용할 수 있습니다!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/201229/figure1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;GEO 홈페이지는 이렇게 생겼습니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;geo-검색-전-알아둬야-할-3가지&quot;&gt;GEO 검색 전 알아둬야 할 3가지!&lt;/h3&gt;
&lt;p&gt;GEO 데이터는 크게 세 종류로 나눌 수 있습니다.&lt;br /&gt;
바로 GPL, GSE, GSM 이 그것입니다.&lt;br /&gt;
이 종류에 따라 데이터에 서로 다른 ID 가 부여되죠. (예를 들어 GSE12300 처럼 말이죠)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;GPL: Platform&lt;br /&gt;
 GPL 은 유전체 데이터의 플랫폼을 이야기합니다.&lt;br /&gt;
 microarray 실험의 경우, 사용된 Array chip 정보를 나타냅니다.&lt;br /&gt;
 제품을 만든 회사 (Affymetrix, Agilent, Illumina) 정보 및 chip 의 상품명도 알 수 있습니다.&lt;br /&gt;
 그러나, 더 중요한 것은 바로 chip 의 probe 정보입니다.&lt;br /&gt;
 microarray 의 각 well 이 어떤 유전자의 probe 를 담고있는지 gene-probe mapping 정보를 제공하기 때문에, microarray 데이터를 분석하기 위해서는 꼭 GPL 정보가 필요합니다.&lt;br /&gt;
 시퀀싱 데이터의 경우는 약간 다릅니다.&lt;br /&gt;
 이 경우 플랫폼은 데이터를 만들 때 사용된 시퀀싱 기기를 알려줍니다.&lt;br /&gt;
 예를 들어, Illumina NovaSeq 6000 인지 HiSeq X Ten 인지 등등을 알려주죠.&lt;/li&gt;
  &lt;li&gt;GSE: Series&lt;br /&gt;
 GSE 는 하나의 데이터 시리즈를 말합니다.&lt;br /&gt;
 즉 한 연구에서 나온 데이터라고 할 수 있죠.&lt;br /&gt;
 예를 들어, 어떤 연구자가 여러 폐암 환자의 RNA-seq 데이터를 GEO에 업로드하게 된다면, 그 데이터들은 하나의 GSE ID 로 묶여지게 됩니다.&lt;br /&gt;
 때문에 GSE 하나에는 해당 실험 디자인에 관한 정보 및 실험에 포함된 샘플들의 정보를 알 수 있죠.&lt;br /&gt;
 아마도 여러분들은 GSE 중심으로 데이터를 검색하시게 될 겁니다.&lt;/li&gt;
  &lt;li&gt;GSM: Sample&lt;br /&gt;
 GSM 은 샘플을 말합니다.&lt;br /&gt;
 하나의 GSM ID 는 하나의 데이터를 나타내죠.&lt;br /&gt;
 GSM 은 각 샘플의 세부 정보 및 개별 데이터를 포함하고 있습니다.&lt;br /&gt;
 이 GSM 여러개가 묶인 것이 바로 GSE 가 되는 것입니다.&lt;br /&gt;
자, 이제 GPL-GSE-GSM 구조를 좀 알 수 있겠죠?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;원하는-데이터를-geo-에서-찾고-싶어요&quot;&gt;원하는 데이터를 GEO 에서 찾고 싶어요!&lt;/h3&gt;
&lt;p&gt;예를 들어 여러분이 &lt;strong&gt;난소암 환자의 RNA-seq 데이터&lt;/strong&gt;를 찾고자 한다면 어떻게 찾아야 할까요?&lt;br /&gt;
아래 예제를 통해 보여드리겠습니다.&lt;/p&gt;

&lt;p&gt;물론 GEO 홈페이지의 검색기능을 사용해도 됩니다만, GEO 의 검색기능은 구글처럼 뛰어나지 않습니다.&lt;br /&gt;
여기서는 그보다 더 효율적인 방법을 말씀드리겠습니다.&lt;br /&gt;
바로 GEO browser 를 사용하는 것입니다.&lt;br /&gt;
아래 그림처럼, GEO 홈페이지에서 Series browser 로 검색해 들어가 보세요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/201229/figure2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;현재 GEO 에는 14만 개의 series 데이터가 있군요.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 부분을 클릭하면, GEO에 있는 모든 Series 정보가 다음 그림과 같이 나타납니다.&lt;br /&gt;
위에서 말씀 드렸듯이 각 series 는 각 연구별로 묶인 데이터 모음입니다.&lt;br /&gt;
GEO browser 에서는 이 series들의 title, series type 등을 구분해서 표 형태로 보여줍니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201229/figure3.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 그럼 &lt;strong&gt;난소암 환자의 RNA-seq 데이터&lt;/strong&gt; 를 찾아볼까요?&lt;br /&gt;
표에 나타난 정보 중 원하는 종류가 있을 때, 이를 클릭하면 ‘필터’ 기능으로 해당 종류만 표에 남게 됩니다.&lt;br /&gt;
먼저 RNA-seq 데이터이므로 ‘Expression profiling by high throughput sequencing’ 데이터만 남겨볼까요?&lt;br /&gt;
표에서 ‘Expression profiling by high throughput sequencing’ 글자를 클릭해보세요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/201229/figure4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;표에서 원하는 데이터 종류를 발견해 클릭하면 …&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/201229/figure5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;해당 종류의 데이터만 표에 남게 됩니다!&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;기존에 14만개나 있었던 시리즈 데이터 중에, 우리가 원하는 RNA-seq 데이터는 약 4만개정도 있군요.&lt;br /&gt;
이런식으로 우리가 원하는 데이터를 좁혀나갈 수 있습니다.&lt;br /&gt;
&lt;strong&gt;난소암 환자의 RNA-seq 데이터&lt;/strong&gt; 를 찾아야 하므로 Homo sapiens 데이터만 남도록 필터링 해볼까요?&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201229/figure6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 그럼 이제 검색 기능도 같이 활용해 봅시다.&lt;br /&gt;
왼쪽 위에 있는 검색 창에 원하는 검색어를 넣어보세요.&lt;br /&gt;
팁을 드리자면, 연구자마다 title 을 적는 방식이 다르기 때문에, 여러 검색어로 해보시는게 좋습니다.&lt;br /&gt;
또 다른 팁은, 연구자들이 title에 넣었을 법한 간단한 단어 위주로 검색하셔야 해요.&lt;br /&gt;
&lt;strong&gt;난소암 환자의 RNA-seq 데이터&lt;/strong&gt; 를 찾는다면 ovary, ovarian 등 몇몇 간단한 검색어를 활용하시면 좋아요.&lt;br /&gt;
ovarian 으로 한번 검색해 볼까요?&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201229/figure7.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이제 133개 시리즈 데이터만 남았군요. &lt;br /&gt;
하지만 아직 끝이 아닙니다.&lt;br /&gt;
여러분들은 아마도 ‘적당한 수의 샘플이 있는’ 데이터를 찾고 싶을 수도 있고, ‘그나마 최신 데이터’ 를 원하실 수도 있어요.&lt;br /&gt;
이를 위해서는 표의 ‘정렬’ 기능을 활용하시면 됩니다.&lt;br /&gt;
표의 헤더 부분을 클릭하시면 오름차순, 내림차순 으로 정렬이 가능해요.&lt;br /&gt;
아, 참고로 오른쪽 위의 page size는 한 페이지에 보이는 시리즈 개수입니다.&lt;br /&gt;
최대 500개까지 가능하니 크게 크게 보세요 ^^&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/201229/figure8.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;저는 샘플 수 내림차순으로 정렬해 보았습니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 이제 거의 다 왔습니다.&lt;br /&gt;
맨 위의 샘플 10,906개 짜리 데이터가 보이는군요.&lt;br /&gt;
보통 이렇게 샘플 수가 큰 경우는 single-cell RNA-seq 데이터인 경우입니다.&lt;br /&gt;
이를 분석 가능하신 분이라면 선택하시면 되겠습니다.&lt;br /&gt;
저희가 찾고자 하는 건 &lt;strong&gt;난소암 환자의 RNA-seq 데이터&lt;/strong&gt; 이므로 이는 제외하구요.&lt;br /&gt;
이제 제목을 찬찬히 읽어보시면서 원하는 데이터인지 확인해보시고, 맞다면 series ID (GSE*****) 를 클릭하시면 됩니다.&lt;/p&gt;

&lt;p&gt;팁을 한가지 더 드리자면, Supplementary 열을 잘 확인해보시는게 좋습니다.&lt;br /&gt;
만약 여러분께서 raw data (fastq) 부터 분석하려고 하신다면, 이는 SRA 데이터베이스에 저장되어 있으므로 ‘SRA Run Selector’ 로 필터해서 찾아보시면 됩니다.&lt;br /&gt;
그러나, 직접 분석하기는 좀 어렵고 이미 만들어져 있는 expression matrix 를 활용하실 분들은 ‘tsv’ 혹은 ‘txt’ 정보가 있는 시리즈만 선택해서 들어가셔야 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201229/figure9.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예시로 GSE101109 라는 시리즈를 들어가 보았습니다.&lt;br /&gt;
Early-stage ovarian cancer 데이터이고, overall survival data 까지 제공하는군요.&lt;br /&gt;
중간에 Experimental design 을 통해 실험이 어떻게 디자인 되었는지 확인할 수 있죠.&lt;br /&gt;
그리고 어떤 논문에서 쓰였는지도 나와있기 때문에, 이 논문을 참고하면 어떤 데이터인지 더 자세하게 들여다볼 수 있겠군요!&lt;br /&gt;
아래에는 사용된 플랫폼, 그리고 샘플들 정보가 나와있습니다. 샘플이 105개나 되는군요!&lt;br /&gt;
이렇게 시리즈의 정보를 읽어보며 여러분께서 찾고자 하는 데이터가 맞는지 확인해보시면 됩니다.&lt;br /&gt;
만약 아니라면, 아까 필터해놓은 여러 시리즈 중 다른 시리즈도 확인해보면 되겠죠.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;네, 오늘은 GEO 에서 원하는 데이터를 찾아가는 과정을 설명해 보았습니다.&lt;br /&gt;
GEO는 전 세계에서 가장 많은 시퀀싱 데이터를 보유하고 있지만, 실제로 원하는 데이터를 찾는 것이 쉽지만은 않습니다.&lt;br /&gt;
여러분이 원하는 특정 디자인의 실험 데이터는 없는 경우가 다반사죠.&lt;br /&gt;
그래도 제가 설명한 방법을 통해 여러분의 연구에 도움되는 자료를 좀더 수월하게 찾아가시길 바랍니다.&lt;br /&gt;
다음에는 데이터를 실제로 활용하는 내용으로 찾아오겠습니다.&lt;br /&gt;
그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/database/2020/12/29/GEO1.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/database/2020/12/29/GEO1.html</guid>
        
        
        <category>biology</category>
        
        <category>database</category>
        
      </item>
    
      <item>
        <title>NGS 가 적용된 다양한 기술들을 알아봅시다!</title>
        <description>&lt;p&gt;안녕하세요. 한헌종입니다.&lt;br /&gt;
오늘은 NGS (Next generation sequencing) 가 적용된 다양한 기술들을 알아보고자 합니다.&lt;br /&gt;
특히 NGS 자체의 설명보다도, 어떤 종류의 데이터들이 있고 어떻게 활용되는지를 정리해봤습니다.&lt;/p&gt;

&lt;h3 id=&quot;ngs가-적용된-기술에는-어떤-종류가-있나요&quot;&gt;NGS가 적용된 기술에는 어떤 종류가 있나요?&lt;/h3&gt;
&lt;p&gt;오늘 다루게 될 데이터를 아래와 같이 정리해봤습니다.&lt;br /&gt;
각 기술들이 어떤 결과를 볼 수 있고, 어떤 target molecule 들을 검출해내는지 한번 알아볼까요?&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Technologies&lt;/th&gt;
      &lt;th&gt;Result&lt;/th&gt;
      &lt;th&gt;Target molecule&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Whole Genome Sequencing (WGS)&lt;/td&gt;
      &lt;td&gt;Genome sequence&lt;/td&gt;
      &lt;td&gt;Genomic DNA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Whole Exome Sequencing (WES)&lt;/td&gt;
      &lt;td&gt;Exome sequence&lt;/td&gt;
      &lt;td&gt;DNA around exon regions&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Chromatin Immunoprecipitation Sequencing (ChIP-seq)&lt;/td&gt;
      &lt;td&gt;Protein-DNA interaction profiles&lt;/td&gt;
      &lt;td&gt;Protein-bound DNA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Methylated DNA Immunoprecipitation Sequencing (MeDIP-seq)&lt;/td&gt;
      &lt;td&gt;CpG methylation profiles&lt;/td&gt;
      &lt;td&gt;Methylated DNA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Reduced Representation Bisulfite Sequencing (RRBS-seq)&lt;/td&gt;
      &lt;td&gt;CpG methylation profiles&lt;/td&gt;
      &lt;td&gt;Methylated DNA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Whole Genome Bisulfite Sequencing (WGBS)&lt;/td&gt;
      &lt;td&gt;CpG methylation profiles&lt;/td&gt;
      &lt;td&gt;Methylated DNA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;High-throughput Chromatin Conformation Capture (Hi-C)&lt;/td&gt;
      &lt;td&gt;Long-range chromatin interaction profiles&lt;/td&gt;
      &lt;td&gt;DNA-bound DNA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DNase I hypersensitive sites sequencing (DNase-seq)&lt;/td&gt;
      &lt;td&gt;Chromatin accesibility profiles&lt;/td&gt;
      &lt;td&gt;DNA around open chromatin regions&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Assay for Transposase-Accessible Chromatin using sequencing (ATAC-seq)&lt;/td&gt;
      &lt;td&gt;Chromatin accesibility profiles&lt;/td&gt;
      &lt;td&gt;DNA around open chromatin regions&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RNA Sequencing (RNA-seq)&lt;/td&gt;
      &lt;td&gt;Transcriptome profiles&lt;/td&gt;
      &lt;td&gt;mRNA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RNA-Immunoprecipitation Sequencing (RIP-seq)&lt;/td&gt;
      &lt;td&gt;Protein-RNA interaction profiles&lt;/td&gt;
      &lt;td&gt;protein-bound mRNA&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;1-dna-염기서열을-알아내고-싶을-때-wes-wgs&quot;&gt;1. DNA 염기서열을 알아내고 싶을 때: WES, WGS&lt;/h3&gt;
&lt;p&gt;WES, WGS 기술은 흔히 말하는 DNA 염기서열을 알아내기 위해 사용됩니다.&lt;br /&gt;
새로운 종의 유전체 정보를 알아낼 때나, 환자의 염기서열에서 돌연변이를 발견하고자 할 때 쓰이죠.&lt;/p&gt;

&lt;p&gt;이 기술에서는 샘플의 DNA 를 추출해서 cDNA library 로 만들고, 이를 NGS 기술을 통해 읽어냅니다.&lt;br /&gt;
WGS 는 모든 유전체 서열을 얻을 때 쓰이지만, WES 는 Exome 영역, 즉 coding region 에 있는 DNA 만을 추출해냅니다.&lt;br /&gt;
Exome 을 추출하기 위해서는 특정 region에만 붙는 probes 를 사용하고, 이후에 이 probes 들에게 붙어있는 bead 를 끌어당겨서 원하는 region의 DNA만 얻어내는 겁니다.&lt;/p&gt;

&lt;p&gt;결과로 나온 fastq files 은 reference genome에 대한 alignment 단계를 거쳐 bam file 을 만들어냅니다.&lt;br /&gt;
보통 이런 데이터는 돌연변이를 찾기 위해서 variant calling을 진행해 vcf 파일이 만들어지죠.&lt;br /&gt;
혹은, 새로운 종의 데이터라면 De novo alignment 로 새로운 genome sequence를 만들 수도 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-단백질-dna-상호작용을-알아내고-싶을-때-chip-seq&quot;&gt;2. 단백질-DNA 상호작용을 알아내고 싶을 때: ChIP-seq&lt;/h3&gt;
&lt;p&gt;ChIP-seq 기술은 특정 단백질이 붙어있는 DNA 영역을 알아낼 때 쓰입니다.&lt;br /&gt;
구체적인 적용은 두가지인데요, 첫째로는 Transcription factor 와 같은 DNA-binding 단백질들이 어디에서 조절작용을 하는지 알아낼 때 입니다&lt;br /&gt;
두번째로는 histone modification (H3K4me3, H3K27ac) 와 같은 Epigenetic modification 이 어디에 일어났는지 알아낼 때 입니다.&lt;br /&gt;
중요한 건 둘 모두 regulatory elements 를 알아낼 때 사용하는 기술이라는 점이죠.&lt;/p&gt;

&lt;p&gt;이 기술에서는, 먼저 Protein-DNA binding 을 고정하기 위해 formaldehyde 를 사용합니다. 이를 cross-linking 단계라고 하죠.&lt;br /&gt;
이후 target protein을 특정 antibody 를 사용해 침전시킵니다. 이 단계가 immuno-precipitation 인거죠.&lt;br /&gt;
이렇게 원하는 protein-bound DNA 조각들이 나오면 이를 NGS 기술로 읽어냅니다.&lt;/p&gt;

&lt;p&gt;결과로 나온 fastq files 은 마찬가지로 reference genome에 대한 alignment 단계를 거쳐 bam file 을 만들어냅니다.&lt;br /&gt;
이 다음으로는 peak-calling algorithm을 사용해서 어떤 영역에 단백질이 붙어있는지 알아냅니다.&lt;br /&gt;
그 결과로 bed 파일이 나오게 되죠.&lt;/p&gt;

&lt;h3 id=&quot;3-methylation-profile-을-알아내고-싶을-때-medip-seq-rrbs-seq-wgbs&quot;&gt;3. Methylation profile 을 알아내고 싶을 때: MeDIP-seq, RRBS-seq, WGBS&lt;/h3&gt;
&lt;p&gt;다음으로 설명드릴 기술은 DNA-methylation profile 을 알아내는 기술들입니다.&lt;br /&gt;
DNA 의 cytosine 서열의 경우 methyl기가 붙기도 하는데요, 이런 부분들은 보통 DNA가 서로 엉겨서 inactive region 이 됩니다.&lt;br /&gt;
즉 주변의 유전자들이 repression, 비활성화 된다는 뜻인데요.&lt;br /&gt;
이렇게 DNA-methylation 작용은 유전자 조절에 중요하기 때문에, methylated sites 를 알아내기 위한 연구가 계속되어 왔습니다.&lt;br /&gt;
작성해놓은 기술보다 더 다양한 기술들이 많은데요, 관심있으신 분들은 &lt;a href=&quot;https://dx.doi.org/10.1186%2Fs13072-016-0075-3&quot;&gt;링크&lt;/a&gt;를 참조해보세요!&lt;/p&gt;

&lt;p&gt;각 기술들의 차이를 간단히 살펴보면 다음과 같습니다.&lt;br /&gt;
MeDIP-seq 은 ChIP-seq 과 유사하게, anti-methylcytosine antibody 를 사용해 methylated DNA를 침전시켜 얻어냅니다.&lt;br /&gt;
가격이 저렴하지만, resolution 이 약 100bp 로 어떤 cytosine 이 methyl기를 가지고 있는지는 알기 힘듭니다.&lt;br /&gt;
RRBS-seq 의 경우, MSP1 이라는 제한효소로 DNA fragment 를 만드는데, 이러면 각 끝부분이 CpG를 갖게 됩니다.&lt;br /&gt;
이후 bisulfite conversion 을 통해 unmethylated C 가 Uracil 로 바뀌게 되고, 이후 cytosine 으로 남아있는 fragments를 골라 sequencing을 진행합니다.&lt;br /&gt;
RRBS 는 비교적 저렴하고 민감도가 높은 기술로 알려져 있지만, intergenic 부분이나 distal element region의 경우는 잘 알아내지 못할 수 있다고 하네요.&lt;br /&gt;
WGBS 는 Whole-genome scale 로 모든 methylated C 를 알아내는 기술입니다.&lt;br /&gt;
비싸다는게 흠이지만, 거의 모든 CpG site 의 methylation 상태를 알아낼 수 있다는 장점이 있죠.&lt;/p&gt;

&lt;h3 id=&quot;4-염색체의-구조를-알아내고-싶을-때-hi-c&quot;&gt;4. 염색체의 구조를 알아내고 싶을 때: Hi-C&lt;/h3&gt;
&lt;p&gt;Hi-C 는 Chromatin Conformation Capture 기술에서 발전된 기술입니다.&lt;br /&gt;
이 기술을 사용하면, genome 상에서 어떤 DNA region이 또다른 DNA region과 붙어있다는 정보를 알아낼 수 있습니다.&lt;br /&gt;
이를 통해 염색체가 전체적으로 어떤 구조를 가지고 있는지, 조절 작용이 어떻게 일어나고 있는지를 알 수 있죠.&lt;br /&gt;
ChIP-seq 에서와 마찬가지로, DNA-DNA interaction 이 일어나는 부분을 formaldehyde로 고정하고 (cross-linking) 염기서열을 시퀀싱으로 알아냅니다.&lt;/p&gt;

&lt;p&gt;이 기술은 대신, genome 상의 모든 chromatin interaction 을 얻으려 하다보니 resolution이나 depth가 좀 모자라긴 합니다.&lt;br /&gt;
여기서 조금 더 진보한 CHi-C 혹은 PCHi-C 는 promoter 와의 상호작용만 뽑아낸 기술입니다.&lt;br /&gt;
대부분의 중요한 유전자 조절이 promoter 와 작용하기 때문에, 이 부분에 집중해서 좀 더 높은 resolution 과 depth 를 얻어낼 수 있는 거죠.&lt;/p&gt;

&lt;h3 id=&quot;5-open-chromatin-region-을-알고-싶을-떄-dnase-seq-atac-seq&quot;&gt;5. Open chromatin region 을 알고 싶을 떄: DNase-seq, ATAC-seq&lt;/h3&gt;
&lt;p&gt;Chromatin accesibility 는 유전자 조절에서 중요한 역할을 합니다.&lt;br /&gt;
DNA 는 평소에 histone 단백질들을 감싸고 밀집된 구조로 존재하지만, 어떤 부분은 느슨하게 풀려 있습니다.&lt;br /&gt;
이런 부분을 open chromatin region 이라고 하는데요, 이런 영역에는 다양한 단백질들이 조절작용을 위해 몰려듭니다.&lt;br /&gt;
때문에 이런 영역을 알아내기 위해 DNase-seq, ATAC-seq 과 같은 기술들이 발전해왔죠.&lt;/p&gt;

&lt;p&gt;DNase-seq 의 경우, DNase I 이라는 endonuclease 를 사용합니다.&lt;br /&gt;
이 때, DNase I 효소는 밀집된 지역보다 느슨한 지역에 더 쉽게 접근해 DNA 조각을 만들어냅니다. (이런 영역을 DNase I hypersensitive region 이라고도 합니다.)&lt;br /&gt;
이후 얻어진 조각들을 cDNA library 로 만들고 읽어내면 open chromatin region 을 알아낼 수 있는거죠.&lt;br /&gt;
ATAC-seq 에서는 ‘변형된’ Tn5 라는 Transposase 를 사용합니다. &lt;br /&gt;
기존 Tn5 효소와 달리, 변형된 Tn5 는 hyperactive transposase 로써 DNA 를 조각내고 adaptor 를 붙여줍니다. (tagmentation 이라는 과정입니다.)&lt;br /&gt;
이 기술 역시 accessible region 의 DNA 조각들을 얻어낼 수 있고, 결과적으로 open chromatin region 을 알아내게 됩니다.&lt;/p&gt;

&lt;p&gt;결과로 나온 fastq files 은 마찬가지로 reference genome에 대한 alignment 단계를 거쳐 bam file 을 만들어냅니다.&lt;br /&gt;
그리고 ChIP-seq 기술과 비슷하게, peak calling algorithm을 통해 region 정보를 알아냅니다.&lt;/p&gt;

&lt;p&gt;최근에는 ATAC-seq 기술이 더 발전되어 single-cell ATAC-seq 기술이 나타났습니다.&lt;br /&gt;
이 기술을 이용하면, 약 10,000개 이상의 세포가 각각 가지고 있는 open chromatin region을 알아낼 수 있게 됩니다.&lt;br /&gt;
정말 single cell 기술의 발전이 대단하네요…&lt;/p&gt;

&lt;h3 id=&quot;6-유전자-발현량을-알고-싶을-때-rna-seq&quot;&gt;6. 유전자 발현량을 알고 싶을 때: RNA-seq&lt;/h3&gt;
&lt;p&gt;RNA-seq 은 많은 연구자들이 사용하고 있는 기술이죠.&lt;br /&gt;
주로 유전자들의 발현량을 알고자 할 때 이 기술을 씁니다.&lt;br /&gt;
먼저 세포에서 mRNA 를 추출해 내는데요, 1) poly-A tail 이 있는 서열만 뽑는 방법과 2) rRNA 를 제거하는 방법 두가지가 있습니다.&lt;br /&gt;
이렇게 뽑힌 RNA 들을 cDNA library 로 만들고 NGS 기술로 읽어내게 됩니다.&lt;/p&gt;

&lt;p&gt;결과로 나온 fastq files 은 마찬가지로 reference genome에 대한 alignment 단계를 거쳐 bam file 을 만들어냅니다.&lt;br /&gt;
이후 quantification 과정을 거치는데요, 여러 알고리즘을 통해 유전자 발현량을 FPKM, TPM, CPM 등의 숫자로 나타내게 됩니다.&lt;/p&gt;

&lt;p&gt;최근에는 전 세계적으로 single-cell RNA-seq (scRNAseq) 기술이 유행하고 있죠.&lt;br /&gt;
각 세포마다 유전자의 발현량을 알아내는 기술로써, 주로 면역 항암제 발굴을 위한 연구에 쓰이고 있습니다.&lt;br /&gt;
적게는 몇백 개, 많게는 십만개 정도의 세포 발현량을 한번에 알아낼 수 있는 기술입니다.&lt;br /&gt;
이 기술을 통해 기존에는 알지 못했던 cell subtype 들과 그들의 새로운 marker를 알아낼 수 있고, cell subtype 간의 분화 과정을 관찰할 수 있게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;7-단백질-rna-상호작용을-알고-싶을-때-rip-seq&quot;&gt;7. 단백질-RNA 상호작용을 알고 싶을 때: RIP-seq&lt;/h3&gt;
&lt;p&gt;RIP-seq 은 ChIP-seq 과 비슷하지만, 이번에는 DNA 가 아니라 RNA 를 target molecule 로 씁니다.&lt;br /&gt;
RNA에 붙는 protein은 post-transcriptional modification에 매우 중요하게 작용합니다.&lt;br /&gt;
때문에 연구자들은 이런 상호작용을 관찰하기 위해 RIP-seq 과 같은 기술을 개발해왔습니다.&lt;br /&gt;
전체적인 분석 방법은 ChIP-seq 과 동일하다고 보시면 됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기까지 NGS 를 적용시킨 다양한 기술들 및 활용을 알아보았습니다.&lt;br /&gt;
물론 여기서 다루지 않은 기술도 매우 많습니다만, 이 글을 통해 전체적인 그림을 얻으셨길 바랍니다.&lt;br /&gt;
특히 관심있으신 연구에 어떤 기술을 사용할 수 있을지 고민하실 때 도움이 될거라 생각합니다.&lt;br /&gt;
그럼, 다음에 더 좋은 내용으로 돌아오겠습니다!&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Dec 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2020/12/06/various_sequencing_tech.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2020/12/06/various_sequencing_tech.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>mysql 로 데이터 관리하기 - 설치부터 사용법까지</title>
        <description>&lt;p&gt;최근에 mysql data를 사용할 일이 있어서, 공부를 한번 해봤습니다.&lt;br /&gt;
생각보다 배워야 할 내용들이 많아서, 아래처럼 정리를 일단 해보았습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;설치는-어떻게-하나요&quot;&gt;설치는 어떻게 하나요?&lt;/h3&gt;
&lt;p&gt;맥에는 homebrew 라는 패키지 관리 앱이 거의 표준으로 쓰이고 있다고 합니다.&lt;br /&gt;
제 컴퓨터는 Mac 인데요, 오늘은 이 homebrew를 사용해서 설치해보도록 하겠습니다.&lt;br /&gt;
명령어는 다음 블로그에 무척 자세하게 정리되어 있어서 참고했습니다: &lt;a href=&quot;https://www.44bits.io/ko/keyword/homebrew&quot;&gt;블로그 링크&lt;/a&gt;&lt;br /&gt;
아래에는 관련 명령어들을 모두 요약해보았는데요, 이중에서 필요한 부분만 사용해 mysql 을 설치했습니다.&lt;br /&gt;
(brew 설치, 업데이트, mysql 검색 및 설치)&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sh &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# brew 설치&lt;/span&gt;
brew update             &lt;span class=&quot;c&quot;&gt;# brew 앱 업데이트&lt;/span&gt;
brew search mysql       &lt;span class=&quot;c&quot;&gt;# mysql 관련 패키지 검색&lt;/span&gt;
brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;mysql      &lt;span class=&quot;c&quot;&gt;# mysql 패키지 설치&lt;/span&gt;
brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;mysql@5.5  &lt;span class=&quot;c&quot;&gt;# mysql 을 특정 버전으로 설치&lt;/span&gt;
brew list               &lt;span class=&quot;c&quot;&gt;# 설치된 패키지 목록 보기&lt;/span&gt;
brew list mysql         &lt;span class=&quot;c&quot;&gt;# 설치된 mysql 관련 패키지 목록 보기&lt;/span&gt;
brew info mysql         &lt;span class=&quot;c&quot;&gt;# 설치된 mysql 패키지의 정보 보기&lt;/span&gt;
brew upgrade mysql      &lt;span class=&quot;c&quot;&gt;# mysql 버전 업그레이드&lt;/span&gt;
brew upgrade            &lt;span class=&quot;c&quot;&gt;# 모든 패키지의 버전 업그레이드&lt;/span&gt;
brew remove mysql       &lt;span class=&quot;c&quot;&gt;# mysql 패키지 삭제&lt;/span&gt;
brew uninstall mysql    &lt;span class=&quot;c&quot;&gt;# mysql 패키지 삭제 - 위와 동일한 결과&lt;/span&gt;
brew cleanup mysql      &lt;span class=&quot;c&quot;&gt;# mysql 의 최신버전을 제외한 outdated 버전 삭제&lt;/span&gt;
ruby &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/Homebrew/install/master/uninstall&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# brew 삭제 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;mysql-설치-후-설정하고-시작하기&quot;&gt;mysql 설치 후 설정하고 시작하기&lt;/h3&gt;
&lt;p&gt;mysql 을 설치하신 뒤에는, 몇가지 설정을 해야 mysql 을 사용할 수 있게 됩니다.&lt;br /&gt;
mysql 설정 또한 무척 잘 설명된 블로그가 있으니 한번 참고해보세요! &lt;a href=&quot;https://whitepaek.tistory.com/16&quot;&gt;블로그 링크&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql.server start          &lt;span class=&quot;c&quot;&gt;# mysql 서버 실행하기&lt;/span&gt;
mysql_sequre_installation   &lt;span class=&quot;c&quot;&gt;# mysql 서버 설정하기 (아래 참조)&lt;/span&gt;
mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;# root 게정으로 mysql 접속, 비밀번호 필요&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;                        &lt;span class=&quot;c&quot;&gt;# mysql 로그아웃&lt;/span&gt;
quit                        &lt;span class=&quot;c&quot;&gt;# mysql 로그아웃&lt;/span&gt;
mysql.server stop           &lt;span class=&quot;c&quot;&gt;# mysql 서버 중지&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;mysql_sequre_installation 명령어를 입력하면, 몇가지 질문에 대해 yes/no 선택 혹은 설정이 필요합니다.&lt;br /&gt;
아래를 참고해서 각자 원하시는 방법대로 설정해보세요!&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Would you like to setup VALIDATE PASSWORD component?: yes 인 경우 비밀번호를 어렵게 (숫자문자 조합) 만들어야 함&lt;/li&gt;
  &lt;li&gt;Please set the password for root here. : 비밀번호를 만들어주세요&lt;/li&gt;
  &lt;li&gt;Remove anonymous users? : yes 인 경우 접속 시 -u 옵션으로 유저를 지정해야 함&lt;/li&gt;
  &lt;li&gt;Disallow root login remotely? : yes 인 경우 원격 접속 불가능&lt;/li&gt;
  &lt;li&gt;Remove test database and access to it?: yes 인 경우 테스트로 미리 만들어져 있는 데이터베이스를 삭제함&lt;/li&gt;
  &lt;li&gt;Reload privilege tables now?: yes 인 경우 위의 설정을 테이블에 적용.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;설정을 다 하고나면 mysql 접속이 가능해집니다!&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;mysql-에-접속해-데이터베이스-생성-및-삭제하기&quot;&gt;mysql 에 접속해 데이터베이스 생성 및 삭제하기&lt;/h3&gt;

&lt;p&gt;아래에 기본적인 명령어들을 모아보았습니다.&lt;br /&gt;
mysql 접속한 뒤에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mysql&amp;gt;&lt;/code&gt; 와 같은 콘솔로 바뀝니다.&lt;br /&gt;
명령어는 대/소문자를 구분하지 않는 것 같고, semi-colon (;) 으로 끝내야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;                    &lt;span class=&quot;c&quot;&gt;# root 게정으로 mysql 접속, 비밀번호 필요&lt;/span&gt;
show databases&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                     &lt;span class=&quot;c&quot;&gt;# 어떤 databases 들이 있는지 확인&lt;/span&gt;
create database example_db&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;# example_db 라는 데이터베이스 생성&lt;/span&gt;
remove database example_db&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;# example_db 라는 데이터베이스 삭제&lt;/span&gt;
use example_db&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                     &lt;span class=&quot;c&quot;&gt;# example_db 라는 데이터베이스 사용하기&lt;/span&gt;
show tables&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                        &lt;span class=&quot;c&quot;&gt;# example_db 에 있는 테이블 목록 보기&lt;/span&gt;
desc example_table&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;# example_table 테이블의 구조 확인&lt;/span&gt;
show columns from example_table&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;# example_table 테이블의 구조 확인&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;mysql-테이블-만들기&quot;&gt;mysql 테이블 만들기&lt;/h3&gt;
&lt;p&gt;테이블을 만들 때는 기본적으로 다음 형식으로 작성합니다.&lt;br /&gt;
테이블 이름 다음에는 괄호 안에 필요한 컬럼 이름과 형태를 적어줘야 합니다.&lt;br /&gt;
comma(,) 로 구분하고, 마지막엔 comma 가 없습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table example_table &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    name char,
    weight tinyint,
    height int,
    birthday &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컬럼에 대한 형태 및 설정은 다음과 같이 하면 됩니다. &lt;a href=&quot;https://www.mysqltutorial.org/mysql-create-table/&quot;&gt;링크 참조&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;column_name data_type&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;length&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;NOT NULL] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;DEFAULT value] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;AUTO_INCREMENT] column_constraint&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;데이터 타입은 numeric, date and time, string, spatial, JSON 등 다양합니다. 다음 링크에서 확인할 수 있습니다: &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/data-types.html&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;데이터의 길이 등을 괄호 안에 지정해줄 수 있는데요, 예를 들어 char(3) 은 최대 3글자 까지 허용해준다는 뜻입니다. &lt;a href=&quot;https://www.w3schools.com/sql/sql_datatypes.asp&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;NOT NULL 이라고 쓰면, 해당 컬럼에는 NULL 값이 들어갈 수 없게 됩니다.&lt;/li&gt;
  &lt;li&gt;DEFAULT value 부분에는 입력안했을 때의 기본값을 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;AUTO_INCREMENT 는 새로운 row가 추가될 때마다 자동으로 1씩 증가한다는 뜻입니다. 각 테이블에는 최대 1개의 AUTO_INCREMENT 컬럼을 만들 수 있습니다. 또한 이 값은 항상 key로 설정해 줘야 합니다.&lt;/li&gt;
  &lt;li&gt;column constraint 에는 UNIQUE, CHECK, primary key 등을 추가할 수 있습니다. 예를 들어, UNIQUE 는 해당 컬럼 값들이 서로 달라야 한다는 뜻입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 항목을 참고하면 다음과 같이 테이블을 만들 수 있습니다:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table example_table &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    name char&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;12&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
    sex char&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;6&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;,
    &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;char&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;20&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; not null unique,
    number int AUTO_INCREMENT,
    weight tinyint,
    height int,
    birthday &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;,
    primary key&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;number&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;mysql-table-을-써보자&quot;&gt;mysql table 을 써보자!&lt;/h3&gt;
&lt;p&gt;이제 테이블을 만들었으니 사용을 해볼까요?&lt;br /&gt;
다음 명령어들을 통해 테이블 내용을 수정, 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;show tables&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                                              &lt;span class=&quot;c&quot;&gt;# example_db 에 있는 테이블 목록 조회&lt;/span&gt;
desc example_table&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                                       &lt;span class=&quot;c&quot;&gt;# example_table 테이블의 구조 확인&lt;/span&gt;
show columns from example_table&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                          &lt;span class=&quot;c&quot;&gt;# example_table 테이블의 구조 확인&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;name from example_table&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                           &lt;span class=&quot;c&quot;&gt;# example_table 에서 'name' 컬럼 내용 조회&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;name, birthday from example_table&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;# example_table 에서 'name,birthday' 컬럼 내용 조회&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; from example_table&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                              &lt;span class=&quot;c&quot;&gt;# example_table 에서 모든 컬럼 내용 조회&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; from example_table limit 5&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                      &lt;span class=&quot;c&quot;&gt;# 모든 컬럼 내용 중 '5개'만 조회&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;name from example_table where weight &amp;lt; 60&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;# weight 가 60 보다 작은 항목의 name 조회&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;height from example_table where name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Joey'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;# name 이 'Joey' 인 항목의 height 조회&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;sex from example_table group by sex&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;# 'sex' 컬럼의 내용을 sex 별로 조회하기&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;sex, avg&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;height&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; from example_table group by sex&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# 'sex 와 'height'의 평균값을 sex 별로 조회하기&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; from example_table order by weight asc&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;# 모든 컬럼을 'weight' 오름차순으로 나열해 조회하기&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; from example_table order by weight desc&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;# 모든 컬럼을 'weight' 내림차순으로 나열해 조회하기&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한, 다음 명령어들을 사용해서 컬럼의 추가/삭제가 가능합니다.&lt;br /&gt;
insert 의 경우, NOT NULL 인 컬럼을 제외하고는 모든 값을 추가해줘야 합니다.&lt;br /&gt;
Update 의 경우 set 명령어 뒤에 바꿀 내용을 작성해주는데요, where 뒤의 조건에 맞는 모든 row에 대해 수정을 진행합니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insert into example_table&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name,id&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; values&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Ross'&lt;/span&gt;,&lt;span class=&quot;s1&quot;&gt;'RG123'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;# name, id 컬럼이 각각 Ross, RG123 이라는 row 추가하기&lt;/span&gt;
update example_table &lt;span class=&quot;nb&quot;&gt;set id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'RG1004'&lt;/span&gt; where name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Ross'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# name 이 'Ross'인 row의 id값을 RG1004로 교체&lt;/span&gt;
delete from example_table where name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Ross'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;# name 이 'Ross'인 row 삭제&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일단 기본적인 명령어들을 모아서 정리해보았습니다.&lt;br /&gt;
생각보다 공부해야 할 내용들이 많은 것 같습니다.&lt;br /&gt;
다음엔 좀 더 재밌는 내용을 찾아봐야겠군요.&lt;/p&gt;

&lt;p&gt;그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/tech/programming/2020/10/20/brew-mysql.html</link>
        <guid isPermaLink="true">http://localhost:4000/tech/programming/2020/10/20/brew-mysql.html</guid>
        
        
        <category>tech</category>
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>Samtools 사용법 총정리!</title>
        <description>&lt;p&gt;안녕하세요 한헌종입니다!&lt;br /&gt;
오늘은 sequencing data 분석에 굉장히 많이 쓰이는 samtools 라는 툴을 사용하는 예제를 적어보고자 합니다.&lt;br /&gt;
samtools 는 BAM, SAM 형태의 파일을 읽고, 쓰고, 조작할 수 있게 해줍니다.&lt;br /&gt;
영어로 된 설명은 여기서 찾아볼 수 있습니다: &lt;a href=&quot;http://www.htslib.org/&quot;&gt;Samtools 사이트 링크&lt;/a&gt;&lt;br /&gt;
내용이 매우 길어서, 아직 미완성이라 계속 보충해 나갈 예정입니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;부연설명을 하자면, Samtools 는 BCFtools, HTSLib 와 관계가 있습니다.&lt;br /&gt;
HTSLib 은 high-throughput sequencing 데이터를 읽고 쓰게 해주는 라이브러리 이구요,&lt;br /&gt;
이를 Samtools, BCFtools 내부에서 사용하고 있습니다.&lt;br /&gt;
Samtools 는 BAM/SAM 을 다루는 툴이고, BCFtools는 BCF/VCF 파일을 다루는 툴입니다.&lt;br /&gt;
(BCF는 VCF의 binary 형태입니다. BCF-VCF 관계는 BAM-SAM 관계와 비슷하죠.)&lt;br /&gt;
Samtools, BCFtools 는 서로 다른 repository 로 각각 설치 가능하고, 이 때 HTSLib이 자동으로 같이 설치됩니다.&lt;br /&gt;
물론 HTSLib은 따로 설치할 수도 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;samtools-설치부터-알려주세요&quot;&gt;samtools 설치부터 알려주세요&lt;/h3&gt;
&lt;p&gt;samtools 를 설치하는 방법은 다양합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;source code 를 사용해서 설치:&lt;br /&gt;
 다음 링크에서 samtools source code 를 받을 수 있습니다: &lt;a href=&quot;http://www.htslib.org/download/&quot;&gt;다운로드 링크&lt;/a&gt;&lt;br /&gt;
 다운로드 한 뒤 압축을 풀고, 다음 명령어로 설치 가능합니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;samtools-1.x    
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/where/to/install
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;github 를 통해서 설치:&lt;br /&gt;
 다음 링크에 samtool github repository 가 있습니다. &lt;a href=&quot;https://github.com/samtools&quot;&gt;samtools github&lt;/a&gt;&lt;br /&gt;
 (samtools github에는 이것 말고도 bcftools, htslib 등 다양한 repository 가 있군요.)&lt;br /&gt;
 clone으로 저장소를 불러온 다음 설치하면 되겠습니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/samtools/samtools.git
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;samtools
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./configure
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;conda 를 사용해 설치&lt;br /&gt;
 만약 anaconda 를 사용하고 계시다면, 더 쉽게 설치가 가능합니다.&lt;br /&gt;
 다음 명령어를 사용해보세요 &lt;a href=&quot;https://anaconda.org/bioconda/samtools&quot;&gt;(링크 참조)&lt;/a&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; bioconda samtools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;다양한-samtools-명령어들&quot;&gt;다양한 samtools 명령어들&lt;/h3&gt;
&lt;p&gt;설치가 끝나셨다면 samtools 명령어를 실행해볼까요?&lt;br /&gt;
터미널에서 samtools라고 작성하면 다음과 같이 나옵니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools

Program: samtools &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Tools &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;alignments &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the SAM format&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Version: 1.11 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;using htslib 1.11&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

Usage:   samtools &amp;lt;&lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options]

Commands:
  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Indexing
     dict           create a sequence dictionary file
     faidx          index/extract FASTA
     fqidx          index/extract FASTQ
     index          index alignment

  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Editing
     calmd          recalculate MD/NM tags and &lt;span class=&quot;s1&quot;&gt;'='&lt;/span&gt; bases
     fixmate        fix mate information
     reheader       replace BAM header
     targetcut      &lt;span class=&quot;nb&quot;&gt;cut &lt;/span&gt;fosmid regions &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;fosmid pool only&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     addreplacerg   adds or replaces RG tags
     markdup        mark duplicates
     ampliconclip   clip oligos from the end of reads

  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; File operations
     collate        shuffle and group alignments by name
     &lt;span class=&quot;nb&quot;&gt;cat            &lt;/span&gt;concatenate BAMs
     merge          merge sorted alignments
     mpileup        multi-way pileup
     &lt;span class=&quot;nb&quot;&gt;sort           sort &lt;/span&gt;alignment file
     &lt;span class=&quot;nb&quot;&gt;split          &lt;/span&gt;splits a file by &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;group
     quickcheck     quickly check &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;SAM/BAM/CRAM file appears intact
     fastq          converts a BAM to a FASTQ
     fasta          converts a BAM to a FASTA

  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Statistics
     bedcov         &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;depth per BED region
     coverage       alignment depth and percent coverage
     depth          compute the depth
     flagstat       simple stats
     idxstats       BAM index stats
     phase          phase heterozygotes
     stats          generate stats &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;former bamcheck&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     ampliconstats  generate amplicon specific stats

  &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Viewing
     flags          explain BAM flags
     tview          text alignment viewer
     view           SAM&amp;lt;-&amp;gt;BAM&amp;lt;-&amp;gt;CRAM conversion
     depad          convert padded BAM to unpadded BAM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;명령어가 굉장히 많군요!&lt;br /&gt;
이 명령어들을 하나씩 살펴보기로 하죠.&lt;br /&gt;
그 전에! BAM/SAM 파일 형식을 잘 숙지하고 계셔야 쉽게 이해가 될 것입니다. &lt;a href=&quot;https://hhj6212.github.io/biology/tech/2020/08/26/Bioinformatics-fileformats.html&quot;&gt;(참고링크)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;*참고로 데이터는 1000 genome project 에서 NA12878 샘플의 chromosome 20번 데이터를 골라봤습니다. &lt;a href=&quot;https://www.internationalgenome.org/data&quot;&gt;(링크)&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;indexing-fastafastqbam-파일의-index-를-만들고-싶을-때&quot;&gt;Indexing: fasta/fastq/bam 파일의 index 를 만들고 싶을 때&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;dict&lt;br /&gt;
 fasta 파일에서 sequence dictionary 를 만들 때 쓰입니다.&lt;br /&gt;
 이를 통해 SAM 형식의 header 가 나오게 되는데, 여기에는 fasta 파일의 contig 수, 길이 등이 나오게 됩니다.&lt;br /&gt;
 다음 명령어를 통해 진행합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools dict chr20.fa
@HD	VN:1.0	SO:unsorted
@SQ	SN:20	LN:63025520	M5:0dec9660ec1efaaf33281c0d5ea2560f	UR:file:/path/to/fasta/chr20.fa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;faidx&lt;br /&gt;
 faidx는 fasta 파일을 indexing 할 때 씁니다.&lt;br /&gt;
 이 indexing 과정은, read data (fastq) 를 reference 에 빠르게 mapping 할 때 쓰입니다.&lt;br /&gt;
 reference fasta 파일을 활용해서 무언가 작업을 하고 싶을 땐, fasta index를 먼저 만들어놓아야 합니다.&lt;br /&gt;
 다음 명령어를 실행하면 fasta index file 인 reference.fa.fai 파일이 만들어 집니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools faidx reference.fa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;fqidx&lt;br /&gt;
 fqidx 는 fastq 로 되어있는 reference sequence 의 index를 만들 때 쓰입니다.&lt;br /&gt;
 fastq 형태로 된 reference sequence는 전 아직 본적 없지만요…&lt;br /&gt;
 이 명령어의 경우, short reads 가 많은 fastq를 사용하면 거의 원본만큼의 크기를 가진 큰 idx 파일이 나오고, 이를 통해 연산할 경우 메모리를 매우 많이 잡아먹는다고 합니다.&lt;br /&gt;
 그래서 input으로는 적은 수의 sequence 를 가진 fastq 파일을 쓰는 것이 좋습니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools fqidx reference.fq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;index&lt;br /&gt;
 여기서의 indexing 은 bam file indexing 을 말합니다.&lt;br /&gt;
 이 과정은 bam 파일에서 특정 영역의 alignment 정보를 빨리 불러올 수 있게 만드는 bai 파일을 만들어 줍니다.&lt;br /&gt;
 bam 파일에서 어떤 작업을 하고싶을 땐 이 index 파일이 있어야 합니다.&lt;br /&gt;
 사용법은 다음과 같습니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools index example.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;editing-bam-파일을-수정하고-싶을-때&quot;&gt;Editing: bam 파일을 수정하고 싶을 때&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;calmd&lt;br /&gt;
 BAM 파일의 MD tag 와 NM tag 를 다시 계산하고자 할 때 사용하는 명령어입니다.&lt;br /&gt;
 MD tag 는 reference sequence 와 얼마나 일치하는지를 표현하는 방법입니다. &lt;a href=&quot;https://oktopbang.tistory.com/entry/MD-tag-and-cigar&quot;&gt;링크 참조&lt;/a&gt;&lt;br /&gt;
 NM tag 는 edit distance to reference 라는건데요, 쉽게 말해서 number of mismatches 입니다.&lt;br /&gt;
 사용법은 다음과 같습니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools calmd &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; example.bam reference.fa &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; result.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;결과물이 standard output으로 나오므로, output file 을 지정해주는 것이 좋습니다.&lt;br /&gt;
 또한, default output 형식은 sam 파일이므로, -b 옵션을 설정해주면 bam 결과물을 얻을 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;fixmate&lt;br /&gt;
 read alignment 를 수행하는 툴은 여러가지인데요, 어떤 툴은 가끔 FLAG (2nd column) 값을 이상하게 만드는 경우가 있습니다.&lt;br /&gt;
 paired-end reads 분석을 위해서는 fragment 를 이루는 read pair 정보를 정확히 가지고 있는것이 중요합니다.&lt;br /&gt;
 때문에 fixmate 기능으로 FLAG 값을 수정해주는 작업이 필요할 때가 있습니다.&lt;br /&gt;
 fixmate 를 사용하려면 먼저 read 들이 genomic coordinate 가 아닌, 이름순으로 나열되어 있어야 합니다.&lt;br /&gt;
 다음과 같이 실행하시면 됩니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; example.bam | samtools fixmate - example.fixmate.sam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;(‘-‘ 표시는 이전 명령어의 standard output을 현재 명령어의 input으로 받는다는 뜻입니다.)&lt;br /&gt;
 만약 이름으로 이미 나열되어 있다면 다음과 같이 실행하시면 됩니다.&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools fixmate &lt;span class=&quot;nt&quot;&gt;-O&lt;/span&gt; bam example.bam example.fixmate.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;input 은 sam, bam 아무거나 상관이 없는데, output 형태가 bam 파일이 되려면 -O bam 이라는 옵션을 추가해줘야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;reheader&lt;br /&gt;
 bam 파일에 header 가 없거나, header 가 이상해서 이를 수정하고 싶을 때가 있습니다.&lt;br /&gt;
 그런 경우에는 header sam 파일을 만들어 놓고, 다음과 같은 명령어를 수행하시면 됩니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools reheader new_header.sam example.bam &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; result.sam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;!-- 1. targetcut --&gt;
  &lt;/li&gt;
  &lt;li&gt;addreplacerg&lt;br /&gt;
 이 명령어는 read group 명을 더하거나 바꾸고 싶을 때 사용합니다.&lt;br /&gt;
 bam header 에 @RG 로 표현된 부분이 바로 read group 에 대한 정보이며, 각 read 들은 이런 read group ID 중 하나를 가지고 있습니다.&lt;br /&gt;
 read group 에 대한 자세한 설명은 다음 링크에서 보실 수 있습니다. &lt;a href=&quot;https://gatk.broadinstitute.org/hc/en-us/articles/360035890671-Read-groups&quot;&gt;링크&lt;/a&gt;&lt;br /&gt;
 -r 옵션으로 @RG 전체 string을 지정해줄 수도 있으며, -R 옵션으로 이미 있는 RG ID 를 지정해줄 수도 있습니다.&lt;br /&gt;
 -m 옵션으로 덮어쓸지 추가할지를 결정할 수 있는데요, -m orphan_only 옵션으로는 추가, -m overwrite_all 으로는 덮어쓰기가 가능합니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools addreplacerg &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'@RG\tID:NG01G\tLB:NG01G\tPL:ILLUMINA\tSM:NG01G'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; orphan_only example.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example.addrg.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위 명령어를 통해 ‘@RG\tID:NG01G\tLB:NG01G\tPL:ILLUMINA\tSM:NG01G’ 라는 read group 이 bam file에 추가됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;markdup&lt;br /&gt;
 markdup 은 duplicated alignments 를 표시하기 위한 기능입니다.&lt;br /&gt;
 먼저 input bam file 은 coordinate 순서대로 나열되어 있어야 합니다.&lt;br /&gt;
 또한 위에서 언급한 fixmate 를 -m option 추가한 상태로 돌린 뒤에 가능합니다.&lt;br /&gt;
 그래서 1) name sort 진행 후 2) fixmate -m 진행하고 3) coordinate sort 를 진행한 뒤에 4) markdup 기능을 사용할 수 있습니다.&lt;br /&gt;
 다음 명령어로 진행합니다: (‘-‘ 표시는 이전 명령어의 standard output을 현재 명령어의 input으로 받는다는 뜻입니다.)
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools &lt;span class=&quot;nb&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; example.bam | samtools fixmate &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; - example.fixmate.bam
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools &lt;span class=&quot;nb&quot;&gt;sort &lt;/span&gt;example.fixmate.bam | samtools markdup - example.markdup.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 때, duplicated alignments를 없애고 싶다면 markdup 에 -r 옵션을 사용하면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;file-operations-bam-파일을-합치고-나누고-나열하는-방법&quot;&gt;File operations: bam 파일을 합치고 나누고, 나열하는 방법&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;collate&lt;br /&gt;
 collate read 들을 read group 별로 나열해주는 작업입니다.&lt;br /&gt;
 이 작업은 ‘read groups’ 를 알고나면 이해하기 쉽습니다. &lt;a href=&quot;https://gatk.broadinstitute.org/hc/en-us/articles/360035890671-Read-groups&quot;&gt;(관련 링크)&lt;/a&gt;&lt;br /&gt;
 요약하면, read group 이란 각 single lane 마다 부여되는 이름입니다.&lt;br /&gt;
 최근 시퀀싱 기술은 여러 sample libraries 들을 pooling 해서 한번에 분석하는 경우가 많은데요,&lt;br /&gt;
 이런 경우 sample 들을 여러 lane 에 나누어서 분석하는 것을 바로 multiplexed sequencing 이라고 합니다. 더 빠르고, 효율적인 방법이죠.&lt;br /&gt;
 결과로 나온 reads 에는 어떤 lane에서 분석된 것인지를 이름으로 구분해주는데요, 우리는 이 정보를 활용해서 각 lane 에서 오는 영향(bias 등)을 관찰하고 활용할 수 있습니다.&lt;br /&gt;
 collate 는 read 들을 이런 read group 별로, 즉 sequencing lane 별로 묶어서 나열해주는 작업을 진행합니다.&lt;br /&gt;
 다음 명령어로 진행합니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools collate example.bam &lt;span class=&quot;nt&quot;&gt;--output-fmt&lt;/span&gt; sam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example.collate.sam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;output 형식은 –output-fmt 옵션으로 지정해주시고, output 파일은 -o 옵션으로 지정해주시면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;cat&lt;br /&gt;
 cat 은 concatenate 의 약자입니다. 이름대로 여러개의 bam 파일을 합칠 때 사용합니다.&lt;br /&gt;
 합치는 방식은 정말 간단하게 각 파일을 이전 파일의 맨 뒤에 붙이는 방식으로 진행합니다.&lt;br /&gt;
 단, 조건이 있습니다. 먼저 파일들의 형식이 모두 같아야 하고, 파일들은 모두 똑같은 sequence dictionary 를 가져야 합니다.&lt;br /&gt;
 사용법은 간단합니다. -o 옵션으로 결과를 저장합니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools &lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;example_1.bam example_2.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example_cat.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;합칠 파일들을 특정 텍스트파일에 적어놓고 사용할 수도 있습니다. 한 줄에 파일이름 하나씩 적어놓은 file_list.txt 를 만들고, -b 옵션으로 다음과 같이 쓰시면 됩니다:&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools &lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; file_list.txt &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example_cat.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;header 는 default 로 첫번째 파일의 header 를 사용하나, 이를 -h 옵션으로 다른 파일의 헤더를 사용할 수도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;merge&lt;br /&gt;
 merge 역시 여러개의 bam 파일을 합칠 때 사용합니다.&lt;br /&gt;
 cat 명령어와 같다고 생각하실 수 있으나, 한 가지 차이점이 있습니다.&lt;br /&gt;
 바로 ‘sorted output’을 결과물로 준다는 것인데요.&lt;br /&gt;
 그러기 위해서는 input 파일들이 모두 같은 알고리즘으로 나열되어 있어야 합니다.&lt;br /&gt;
 즉, 한 파일을 samtools sort -n 옵션으로 나열했다면, merge 하려는 다른 파일들 역시 -n 옵션으로 나열되어 있어야 합니다.&lt;br /&gt;
 사용법은 다음과 같습니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools merge example_1.bam example_2.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example_cat.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;여기서도 -h 옵션으로 헤더를 지정해줄 수 있는데요, 지정하지 않는 경우엔 input header 들이 모두 합쳐집니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;mpileup&lt;br /&gt;
 bam 파일을 사용해 pileup 형식의 파일을 만들어내는 명령어입니다.&lt;br /&gt;
 pileup 형식이란? SNP/indel 등의 variant 정보를 한눈에 확인할 수 있는 파일 형식입니다.&lt;br /&gt;
 자세한 설명은 다음 링크에서 확인하실 수 있어요! &lt;a href=&quot;http://samtools.sourceforge.net/pileup.shtml&quot;&gt;(링크)&lt;/a&gt;&lt;br /&gt;
 간단한 사용법은 다음과 같습니다. -o 로 output 파일을 만들어 줍니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools mpileup example.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example.pileup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;옵션을 살펴보니 몇가지 알아두면 좋을 항목이 있었습니다:&lt;br /&gt;
 -f [fasta 파일]: indexing 되어있는 reference fasta 파일을 사용할 수 있습니다.&lt;br /&gt;
 -l [bed 파일]: 지정해준 bed 파일에 나타난 영역에 대해서만 mpileup 을 진행합니다.&lt;br /&gt;
 -b [bam 파일 목록이 적힌 텍스트 파일]: 여러 bam 파일에 대해 작업할 때, 파일 목록을 만들어서 줄 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;sort&lt;br /&gt;
 bam 파일에 있는 read 들을 나열할 때 사용합니다.&lt;br /&gt;
 간단한 사용법은 다음과 같습니다. -o 옵션으로 ouput 파일을 지정해 줍니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools &lt;span class=&quot;nb&quot;&gt;sort &lt;/span&gt;example.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example_sorted.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;sort 에는 여러 유용한 옵션들이 있으니 한번 참고해볼까요?&lt;br /&gt;
 -n: read 를 나열할 때 read name 순으로 나열합니다.&lt;br /&gt;
 -t: read 를 나열할 때 TAG 숫자 순으로 나열합니다.&lt;br /&gt;
 -T [prefix]: sort 를 진행하면 temporary 파일들이 많이 사용되는데요, 이 때 temporary 파일의 이름을 지정해서 prefix.nnnn.bam 으로 만들도록 합니다.&lt;br /&gt;
 -@ [thread 수]: 나열할 때 사용할 thread 를 지정해줍니다.&lt;br /&gt;
 -m [memory]: 나열할 때 사용할 thread 별 최대 메모리를 지정해줍니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;split&lt;br /&gt;
 bam 파일에 있는 reads 들을 read group 별 독립된 파일들로 나눠줍니다.&lt;br /&gt;
 이 작업은 ‘read groups’ 를 알고나면 이해하기 쉽습니다. &lt;a href=&quot;https://gatk.broadinstitute.org/hc/en-us/articles/360035890671-Read-groups&quot;&gt;(관련 링크)&lt;/a&gt;&lt;br /&gt;
 사용법은 다음과 같습니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools &lt;span class=&quot;nb&quot;&gt;split &lt;/span&gt;example.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;결과물로는 read group 마다 example_0.bam, example_1.bam … 으로 나옵니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;quickcheck&lt;br /&gt;
 이름 그대로 bam 파일이 온전한지를 빠르게 체크하는 명령어입니다.&lt;br /&gt;
 설명에 따르면 header 를 제대로 가지고 있는지, target sequnece를 최소한 하나 가지고 있는지, 그리고 파일 끝 부분이 EOF (end-of-file) 을 제대로 가지고 있는지를 확인한다고 하는군요.&lt;br /&gt;
 파일 하나씩 체크할 수도 있지만, 매뉴얼에는 여러 파일을 한번에 체크하는 방법을 추천하고 있습니다.&lt;br /&gt;
 다음 명령어 입니다. 한번 확인해볼까요?
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools quickcheck example.bam
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools quickcheck &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.bam &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'all ok'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'fail!'&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools quickcheck &lt;span class=&quot;nt&quot;&gt;-qv&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.bam &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; bad_bams.fofn &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'all ok'&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'some files failed check, see bad_bams.fofn'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;첫 번째 명령어는 파일 하나만 체크하는 방법입니다.&lt;br /&gt;
 두 번째 명령어는 모든 bam 파일 확인 후, 정상이라면 ‘all ok’를 출력하고, 그렇지 않으면 ‘fail!’을 출력합니다.&lt;br /&gt;
 세 번째 명령어는 모든 bam 파일 확인 후, 비정상 bam 파일 목록은 bad_bams.fofn 에 저장하며, 모두 정상이라면 ‘all ok’를 출력하고, 그렇지 않으면 ‘fail!’을 출력합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;fastq&lt;br /&gt;
 bam 파일을 fastq 로 바꿔주는 명령어입니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools fastq example.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example.fastq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;만약 paired-end sequencing 데이터라면 read1, read2 파일을 따로 지정해주면 됩니다.&lt;br /&gt;
 이 때, 두 개의 fastq 파일에 같은 read 순서로 만들고 싶다면 먼저 collate 혹은 sort -n 으로 나열되어 있어야 합니다.&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools fastq example.bam &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt; example_1.fastq &lt;span class=&quot;nt&quot;&gt;-2&lt;/span&gt; example_2.fastq &lt;span class=&quot;nt&quot;&gt;-0&lt;/span&gt; example_0.fastq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 때, read1, read2 이외의 read 들은 standard out으로 출력이 될 겁니다. &lt;br /&gt;
 어마어마한 수의 reads 정보가 출력될 것이기 때문에, 만약 출력하고 싶지 않다면 위 예시처럼 숫자 ‘0’ 옵션을 사용해서 -0 [파일이름] 으로 지정해주셔야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;fasta&lt;br /&gt;
 bam 파일을 fasta 로 바꿔주는 명령어입니다.&lt;br /&gt;
 매뉴얼에서는 samtools fastq 와 samtools fasta 를 같이 설명하고 있군요!&lt;br /&gt;
 fastq 에서와 마찬가지로 read1, read2, other reads 를 구분해서 쓰시면 되겠습니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools fasta example.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example.fasta
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools fasta example.bam &lt;span class=&quot;nt&quot;&gt;-1&lt;/span&gt; example_1.fasta &lt;span class=&quot;nt&quot;&gt;-2&lt;/span&gt; example_2.fasta &lt;span class=&quot;nt&quot;&gt;-0&lt;/span&gt; example_0.fasta
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;statistics-bam-파일의-통계치를-확인하고-싶을-때&quot;&gt;Statistics: bam 파일의 통계치를 확인하고 싶을 때&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;bedcov&lt;br /&gt;
 특정 영역에 대해서 read base count 를 세어주는 명령어 입니다.&lt;br /&gt;
 read base count 는 the sum of per base read depths, 즉 mapping 된 총 base 수를 합친 값입니다.&lt;br /&gt;
 영역은 bed 파일로 지정해주면 되고, 각 영역별 read base count 를 세어줍니다.&lt;br /&gt;
 다음 명령어로 실행합니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;example.bed &lt;span class=&quot;c&quot;&gt;# 이 형태의 bed 파일을 사용한다고 하면...&lt;/span&gt;
20	60000	70000
20	70000	80000
20	80000	100000
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools bedcov example.bed example.bam &lt;span class=&quot;c&quot;&gt;# 이 명령어로 아래와 같은 결과가 나옵니다.&lt;/span&gt;
20	60000	70000	51006
20	70000	80000	163986
20	80000	100000	51060
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;coverage&lt;br /&gt;
 특정 영역에 대해서 read coverage 를 표시한 histogram 을 만들어주는 명령어 입니다.&lt;br /&gt;
 아래 명령어로 실행합니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools coverage &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; 20:100000-200000 example.bam
&lt;span class=&quot;c&quot;&gt;#rname	startpos	endpos	numreads	covbases	coverage	meandepth	meanbaseq	meanmapq&lt;/span&gt;
20	100000	200000	7577	87538	87.5371	5.32686	33.7	54.3
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools coverage &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; 20:100000-200000 &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; example.bam
20 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;63.03Mbp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  88.57% │ ▆▃  ▄▂▄     ▄▃▁▄▆     ▃█ ▃▁  ▆▅▂▃     ▄ ▃▃  ▄▃  ▄  ▁  ▂▄  █▂│ Number of reads: 7577
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  78.73% │▅███▁███▅▆ ▇▂█████▂▂  ▃██▆██ █████▇▅▆▅▅████▆███▄▄█▂▃█  ██ ▂██│     &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;887 filtered&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  68.89% │██████████ █████████▄▇███████████████████████████████▅▄██▄███│ Covered bases:   87.5Kbp
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  59.05% │█████████████████████████████████████████████████████████████│ Percent covered: 87.54%
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  49.21% │█████████████████████████████████████████████████████████████│ Mean coverage:   5.33x
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  39.37% │█████████████████████████████████████████████████████████████│ Mean baseQ:      33.7
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  29.52% │█████████████████████████████████████████████████████████████│ Mean mapQ:       54.3
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  19.68% │█████████████████████████████████████████████████████████████│
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;   9.84% │█████████████████████████████████████████████████████████████│ Histo bin width: 1.6Kbp
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;   0.00% │█████████████████████████████████████████████████████████████│ Histo max bin:   98.414%
     100.0K    116.4K    132.8K    149.2K    165.6K    181.9K     200.0K
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;어떤 옵션이 있는지 살펴볼까요?&lt;br /&gt;
 -r [chromosome:start-end]: -r 옵션으로 영역을 지정해줄 수 있고, 영역을 지정해주지 않으면 모든 chromosome 에 대한 결과를 각각 만들어서 제공해줍니다.&lt;br /&gt;
 -m : table 형태의 결과 대신 histogram 을 보여줍니다.&lt;br /&gt;
 -w [bin 개수]: historgram 을 몇 개의 bin 으로 나눠서 보여줄지 결정합니다. &lt;br /&gt;
 -o [output 파일]: 결과를 output 파일에 저장합니다.&lt;br /&gt;
 -b [bam 목록 파일]: 여러 bam 파일을 사용할 때, bam 파일들의 이름이 적힌 목록 파일을 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;depth&lt;br /&gt;
 지정해준 영역 혹은 position 에 대해 read depth 를 계산해줍니다.&lt;br /&gt;
 영역은 bed 파일로 제시해주면 되는데요, 만약 제공하지 않으면 bam 파일이 걸친 모든 영역의 &lt;strong&gt;position 마다&lt;/strong&gt; 결과를 제공합니다.&lt;br /&gt;
 그럼 매우 큰 결과가 나오게 되니 주의해주세요!&lt;br /&gt;
 다음 명령어를 사용합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools depth &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; example.bed example.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example_depth.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;옵션들을 한번 살펴보시죠.&lt;br /&gt;
 -a : 모든 position 에 대해 결과를 제공합니다. 이는 depth 가 0 인 position 도 포함합니다.&lt;br /&gt;
 -aa : 사용하지 않은 reference sequence에 있는 영역까지, 정말 전체 영역에 대한 결과를 모두 제공합니다.&lt;br /&gt;
 -b [bed 파일]: 결과를 만들 영역을 bed 파일로 제시해줍니다.&lt;br /&gt;
 -f [bam 목록파일]: 여러 bam 파일을 사용할 때, 파일 이름을 목록으로 만들어 제시합니다.&lt;br /&gt;
 -o [output 파일]: 결과를 output 파일에 저장합니다.&lt;br /&gt;
 -g [flags]: 특정 flag 를 가진 read 는 제외합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;flagstat&lt;br /&gt;
 bam 파일의 기본적인 상태를 보여줍니다.&lt;br /&gt;
 주로 몇 개의 read 중 몇 개가 mapping 되었는지 등의 결과를 확인하고자 할 때 쓰입니다.&lt;br /&gt;
 &lt;strong&gt;flagstat 에 대한 더 자세한 설명은 &lt;a href=&quot;https://hhj6212.github.io/biology/tech/2021/06/13/samtools-flagstat.html&quot;&gt;이 포스트&lt;/a&gt; 를 참고해보세요!&lt;/strong&gt;&lt;br /&gt;
 아래 결과를 보시면 더욱 이해가 쉬우실 겁니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools flagstat example.bam
4579959 + 0 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;total &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;QC-passed reads + QC-failed reads&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
0 + 0 secondary
0 + 0 supplementary
371078 + 0 duplicates
4532991 + 0 mapped &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;98.97% : N/A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
4569463 + 0 paired &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;sequencing
2284756 + 0 read1
2284707 + 0 read2
4413160 + 0 properly paired &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;96.58% : N/A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
4475527 + 0 with itself and mate mapped
46968 + 0 singletons &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1.03% : N/A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
21515 + 0 with mate mapped to a different chr
15292 + 0 with mate mapped to a different chr &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;mapQ&amp;gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;결과를 살펴보면, 약 450만 개의 read 가 bam 파일에서 발견되었군요.&lt;br /&gt;
그 중 371078 개는 duplicate 으로 밝혀졌구요, 대부분의 reads (98.97%) 가 reference genome 에 mapping 된 것을 알 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;idxstats&lt;br /&gt;
 bam 파일의 통계 결과를 index 파일에서 찾아 출력해줍니다.&lt;br /&gt;
 즉, 이 명령어를 쓰기 위해서는 samtools index 가 선행되어야 합니다.&lt;br /&gt;
 결과는 다음 네 개의 컬럼으로 나옵니다.&lt;br /&gt;
 1) reference sequence name, 2)sequence length, 3) # mapped read-segments, 4)# unmapped read-segments&lt;br /&gt;
 다음 명령어로 실행합니다.
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools idxstats example.bam
1	249250621	0	0
2	243199373	0	0
...
19	59128983	0	0
20	63025520	4532991	46968
21	48129895	0	0
22	51304566	0	0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;제 예시 파일에는 20번 염색체에 대한 정보밖에 없어서 결과가 하나밖에 안나오는군요. ^^&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;phase&lt;br /&gt;
 이 기능에 대해서 알려면, 먼저 phasing 을 이해하고 있어야 합니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Haplotype_estimation&quot;&gt;Wikipedia 링크&lt;/a&gt;&lt;br /&gt;
 간단히 말하면, 우리가 얻은 genotype 이 두 상동염색체 중 어느쪽에서 왔는지 알아내는 과정을 phasing (혹은 haplotype estimation) 이라고 합니다.&lt;br /&gt;
 일반적인 시퀀싱 정보로는, 각 reads 들이 두 상동염색체 중 어느쪽에서 온건지 알 수 없습니다.&lt;br /&gt;
 그런데 특정 시퀀싱 기술을 통해서, 각 염색체에서 온 reads 들을 서로 다른 barcode 를 달아주면 reads 들을 두 그룹으로 나눌 수 있습니다.&lt;br /&gt;
 이 정보를 haplotype이라고 하는데요, 이런 실험기법을 통해 reads 들의 haplotype 정보를 알 수 있게 되는거죠. (이 과정을 phasing 이라고 합니다.)&lt;br /&gt;
 samtools phase 명령어는, 만약 우리가 가진 bam 파일이 phasing 되어 있는 파일이라면, bam 파일에서 변이를 찾아주고 이 중 heterozygous SNPs 에 대해서 haplotype 을 표시해주는 기능입니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools phase example.bam &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; example.phase
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;만약 우리가 가지고 있는 bam 파일의 2,3,8번째에 heterozygous SNPs 들이 존재하고, 한쪽 allele (0번) 은 각각 A,C,T 이며 다른쪽 allele (1번) 은 각각 T,A,C 라면 결과물은 다음과 같이 나옵니다.&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CC  M?   chr    PS     pos  allele0 allele1 hetIndex &lt;span class=&quot;c&quot;&gt;#supports0 #errors0 #supp1 #err1&lt;/span&gt;
CC
CC
PS      frame-1   2    9
M1      frame-1  60    2      A       T       1       3       0       23      0
M1      frame-1  60    3      C       A       2       35      1       24      0
M1      frame-1  60    8      T       C       3       46      0       30      0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;stats&lt;br /&gt;
 stats 명령어는 bam 파일의 통계치를 텍스트 파일로 제공해줍니다.&lt;br /&gt;
 위의 flagstat 가 alignment 관련 정보를 제공했다면, stats 명령어는 checksum, read quality, ATGC contents 등의 정보를 보여줍니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools stats example.bam &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; example.stats
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;output 은 텍스트 파일로 나오므로, 이를 “&amp;gt;” 로 저장해주는 것이 좋습니다.&lt;br /&gt;
 결과로 나오는 항목은 매우 많습니다. &lt;a href=&quot;http://www.htslib.org/doc/samtools-stats.html&quot;&gt;링크&lt;/a&gt;를 참조해보세요.&lt;br /&gt;
 몇가지를 확인해보면 다음과 같습니다:&lt;br /&gt;
 CHK:    파일 checksum&lt;br /&gt;
 SN:     Summary numbers&lt;br /&gt;
 FFQ:	First fragment qualities&lt;br /&gt;
 LFQ:   	Last fragment qualities&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;viewing-bam-파일을-실제로-읽어보고-싶을-때&quot;&gt;Viewing: bam 파일을 실제로 읽어보고 싶을 때&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;flags&lt;br /&gt;
 flags 는 bam 파일의 FLAG 정보를 설명해줍니다.&lt;br /&gt;
 bam 파일에 존재하는 두번째 column 은 flag 값인데요, 숫자 하나로 되어있지만 사실은 2진법 정보의 합으로 되어있는 것입니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/SAM_(file_format)#Bitwise_flags&quot;&gt;(링크 참조)&lt;/a&gt;&lt;br /&gt;
 예를 들어, 어떤 read 가 pair 되어 있고, read1 이 unmapped 상태라는 두 가지 상태에 있다고 가정합시다.&lt;br /&gt;
 그러면 해당 read 는 1 + 4 = 5 라는 값을 가지게 됩니다.&lt;br /&gt;
 이런 FLAG 에 어떤 이진법 조건이 있는지 samtools flags 를 통해 알 수 있습니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools flags
Flags:
0x1	PAIRED        .. paired-end &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;or multiple-segment&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; sequencing technology
0x2	PROPER_PAIR   .. each segment properly aligned according to the aligner
0x4	UNMAP         .. segment unmapped
0x8	MUNMAP        .. next segment &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the template unmapped
0x10	REVERSE       .. SEQ is reverse complemented
0x20	MREVERSE      .. SEQ of the next segment &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the template is reversed
0x40	READ1         .. the first segment &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the template
0x80	READ2         .. the last segment &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;the template
0x100	SECONDARY     .. secondary alignment
0x200	QCFAIL        .. not passing quality controls
0x400	DUP           .. PCR or optical duplicate
0x800	SUPPLEMENTARY .. supplementary alignment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;tview&lt;br /&gt;
 tview 명령어는 interactive mode 로 특정 genomic region 에서 reads 들의 상태를 볼 수 있게 해줍니다.&lt;br /&gt;
 특정 위치를 지정하고 upstream, downstream 으로 이동하면서 reads 들이 어느 위치에 mapping 되어 있는지, 변이가 있는지, read quality는 어떤지 등을 직접 확인할 수 있죠.&lt;br /&gt;
 일반적으로는 genome 이 너무 크기도 하고, bam 파일에 있는 read 수도 매우 많기 때문에 잘 사용하지는 않지만, 가끔 variant call 이 제대로 되었는지 확인하는 용도로 사용할 수 있습니다.&lt;br /&gt;
 tip. 이 명령어를 사용할 때는 reference genome 을 같이 제공해주는 것이 좋습니다.&lt;br /&gt;
 다음 명령어로 사용합니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools tview example.bam reference.fa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;명령어를 실헹하고 나면, 터미널 창에 아래와 같은 검은 화면이 뜰 겁니다.&lt;br /&gt;
 여기서 slash ‘/’를 입력하고 20:341931 등의 위치를 입력하면 원하는 위치의 view를 볼 수 있습니다.&lt;br /&gt;
 키보드 방향키로 움직일 수 있고, 해당 위치에 mapping 된 reads 정보 및 variant 정보를 확인할 수 있죠.&lt;br /&gt;
 연속된 글자들이 하나의 read를 나타냅니다.&lt;br /&gt;
 다음과 같은 화면이 나타나게 됩니다:&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 341931    341941    341951    341961    341971    341981
ccaggctctgtactcagtccatcacatacattaggtcttgcagtcctcataccaccataaggt
....................R..........................................
, ..................G.................
.......................... ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,g,,,,,,
,,,,,,,,,,,,,,,,,,,,g,,,,,,,,,,,,,,,,,,
,                   g,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,g,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,g,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;view&lt;br /&gt;
 view 명령어는 두 가지 용도로 사용됩니다.&lt;br /&gt;
 첫 번째로는 bam 파일의 데이터를 특정 조건(위치, quality 등등)에 맞는 것만  뽑아내는 용도입니다.&lt;br /&gt;
 두 번째는 파일 형식을 BAM-SAM-CRAM 으로 바꿔주는 용도입니다.&lt;br /&gt;
 BAM -&amp;gt; SAM 파일도 가능하고, SAM -&amp;gt; BAM 으로도 가능합니다.&lt;br /&gt;
 기본적인 명령어는 다음과 같습니다:
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 1번 용도&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools view example.bam 2:10000-50000 &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; example.sub.bam
&lt;span class=&quot;c&quot;&gt;# 2번 용도 1 - bam 파일을 sam 파일로 바꿀 때&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools view example.bam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; output.sam
&lt;span class=&quot;c&quot;&gt;# 2번 용도 2 - sam 파일을 bam 파일로 바꿀 때&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;samtools view &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; example.sam &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; output.bam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;여기까지 samtools 설치부터 indexing, editing 그리고 viewing 까지 살펴보았습니다.&lt;br /&gt;
명령어가 무척 많아서 한 글에서 다 다루는게 매우 힘들군요.&lt;br /&gt;
부족한 부분이 많을텐데, 앞으로 조금씩 보완해나가도록 하겠습니다.&lt;br /&gt;
samtools view, flagstat 등은 여러 방면에서 유용하게 쓰이는 명령어이므로 알아두시면 편리하실 거에요.&lt;br /&gt;
그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2020/10/18/samtools.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2020/10/18/samtools.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>ACMG class 를 수치로 표현하는 방법 - bayesian score</title>
        <description>&lt;p&gt;안녕하세요. 한헌종입니다.&lt;br /&gt;
오늘은 지난번에 이어, ACMG pathogenicity class 의 수치적 표현에 대한 이야기를 하려 합니다.&lt;br /&gt;
글 맨 아래에는 ACMG evidence 조합에 따라 class 와 bayesian score를 구할 수 있는 계산기를 만들어 보았으니 한번 참고해보세요!&lt;/p&gt;

&lt;p&gt;아래 내용은 다음 논문을 참조해서 작성했습니다:&lt;br /&gt;
Tavtigian, Sean V et al. “Modeling the ACMG/AMP variant classification guidelines as a Bayesian classification framework.” Genetics in medicine : official journal of the American College of Medical Genetics vol. 20,9 (2018): 1054-1060. doi:10.1038/gim.2017.210&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;acmg-class-가-뭐더라&quot;&gt;ACMG class 가 뭐더라&lt;/h3&gt;

&lt;p&gt;지난번에 말씀드린 대로, ACMG/AMP guideline에 따라 각 유전변이의 pathogenicity를 판별할 수 있습니다.&lt;br /&gt;
규칙에 따라 여러 evidence를 할당하고, 그 결과를 조합해 5가지 class 중 하나를 규정하는 방식이죠.&lt;br /&gt;
5가지 class는 다음과 같습니다: Pathogenic, Likely pathogenic, vairiant of uncertain significance, Likely benign, Benign.&lt;br /&gt;
이를 줄여서 P, LP, VUS, LB, B 로 간단히 나타내기도 합니다.&lt;/p&gt;

&lt;p&gt;ACMG guideline을 따르면 pathogenicity를 어느정도 가늠할 수 있게 됩니다.&lt;br /&gt;
그러나 연구자들은 이를 ‘수치적’으로 나타내기를 원했습니다.&lt;br /&gt;
이를 위해 연구자들은 Bayesian framework 를 사용해 수치화 하는 방법을 강구해냅니다.&lt;br /&gt;
바로 다음 식처럼 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201011/figure1.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Bayesian framework에 따라서, 먼저 알고 있는 prior probability를 여러 조건부확률을 사용해 posterior probability를 계산하는 방식입니다.&lt;br /&gt;
이 식을 사용하면 특정 변이의 pathogenicity를 0~1 사이의 값으로 나타낼 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;물론, 결국엔 ACMG guideline 조합에 따른 5가지 class를 사용해서 변이를 설명해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;어떻게-계산하는-건가요&quot;&gt;어떻게 계산하는 건가요?&lt;/h3&gt;
&lt;p&gt;그럼 식에 대해 좀더 알아보겠습니다.&lt;br /&gt;
위의 공식은 밑에 있는 일반적인 베이즈 규칙에 따라 만들어졌습니다:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201011/figure2.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;여기서 P(A) 가 prior probability, 즉 the probability of pathogenicity 가 됩니다.&lt;br /&gt;
변이가 병원성을 가질 확률이죠.&lt;br /&gt;
P(B)는 the probability of the evidence for pathogenicity 입니다.&lt;br /&gt;
P(A|B) 가 여기서 posterior probability 가 되는데요,&lt;br /&gt;
그 의미는 the probability of pathogenicity given the evidence 즉 주어진 evidence들에 대해 이 변이가 병원성을 가질 확률입니다.&lt;br /&gt;
P(B|A) 는 the probability of the evidence, given that the variant is pathogenic, 즉 pathogenic 변이가 주어졌을 때 각 evidence를 가질 확률입니다.&lt;/p&gt;

&lt;p&gt;여기서 prior는 0.1을 기본값으로 사용합니다.&lt;br /&gt;
이는 논문에서 제시한 값으로써, 유전자 패널 등에서 병원성 변이를 발견하게 될 확률을 경험적으로 나타낸 것이라고 하는군요.&lt;/p&gt;

&lt;h3 id=&quot;odds_path-는-어떻게-구하는거죠&quot;&gt;Odds_Path 는 어떻게 구하는거죠?&lt;/h3&gt;

&lt;p&gt;Odds_Path 는 odds of pathogenicity 를 나타냅니다.&lt;br /&gt;
이는 evidence categories 들을 설명하는 방향으로 만들어졌습니다.&lt;br /&gt;
그래서 이 값이 1 보다 크면 pathogenic evidence가 많다는 것이고, 1보다 작으면 benign evidence 가 많다는 것을 의미입니다.&lt;br /&gt;
이 Odds_Path 는 다음 식으로 구해집니다:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/201011/figure3.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;설명드리자면, Odds_Path 는 PVS evidence 의 odds 값을 ‘특정 값’으로 제곱해서 계산합니다.&lt;br /&gt;
그 ‘특정 값’ 은 각 evidence 의 개수를 활용해 만들어집니다.&lt;br /&gt;
예를 들어, NPSu 는 pathogenic-supporting evidence의 개수를 말합니다.&lt;/p&gt;

&lt;p&gt;이 evidence의 개수는 그 strength에 따라서 2배씩 줄어들도록 보정이 되는데요,&lt;br /&gt;
그 결과 very strong evidence 한개의 영향력은 strong evidence 두 개의 영향력과 같게 됩니다.&lt;br /&gt;
(여기서의 그 ‘두 배’ 라는 값도 역시 논문에서 정해준 값입니다.)&lt;/p&gt;

&lt;p&gt;또한 pathogenic evidence 개수는 덧셈, benign evidence는 뺄셈으로 사용해서 결과값을 보정하고 있습니다.&lt;br /&gt;
Benign evidence 가 많으면 odds_path 가 1 이하로 떨어지겠죠?&lt;/p&gt;

&lt;p&gt;여기서, O(PVSt) 즉 the odds of very strong pathogenicity 는 논문에서 350으로 제시하고 있습니다.&lt;br /&gt;
이렇게 해서 Odds_path 를 구하는 방식을 알아보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;그럼-이-값이-뭘-뜻하나요&quot;&gt;그럼 이 값이 뭘 뜻하나요?&lt;/h3&gt;
&lt;p&gt;결국 Bayesian score를 구하기 위해서는 다음 두 단계를 거치면 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Odds_Path 를 evidence 개수를 사용해 구한다.&lt;/li&gt;
  &lt;li&gt;Posterior probability를 bayesian framework에 따라 계산한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기서 제시한 O(PVSt)=350, Prior=0.1 를 사용하면 다음과 같은 현상이 나타납니다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt;= 0.99 : &lt;strong&gt;Pathogenic&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.99 &amp;gt; &lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt;= 0.90 : &lt;strong&gt;Likely pathogenic&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.90 &amp;gt; &lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt; 0.1 : &lt;strong&gt;VUS&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.1 &amp;gt;= &lt;strong&gt;Post_P&lt;/strong&gt; &amp;gt; 0.001 : &lt;strong&gt;Likely benign&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;0.001 &amp;gt;= &lt;strong&gt;Post_P&lt;/strong&gt; : &lt;strong&gt;Benign&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉 Bayesian score 가 pathogenicity를 나타낼 수 있게 된 거죠.&lt;br /&gt;
높을 수록 Pathogenic 변이이며, 특정 값을 넘는지를 통해 class 도 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 이 공식으로 구해진 bayesian score는 완벽하지 않아서, 여러 예외상황이 발생하기도 합니다.&lt;br /&gt;
예를 들어 class 는 VUS 로 분류되지만 bayesian score 는 0.9를 넘는 경우가 발생하기도 하죠.&lt;br /&gt;
bayesian score는 설명을 돕기 위한 점수일 뿐이고, 결국 ACMG class 를 중점적으로 봐야한답니다.&lt;/p&gt;

&lt;h3 id=&quot;acmg-class-계산기&quot;&gt;ACMG class 계산기&lt;/h3&gt;
&lt;p&gt;js 를 사용해서 ACMG class 계산기를 만들어보았습니다.&lt;br /&gt;
해당하는 rule을 클릭해서 조합을 만들면, 밑부분의 결과에 ACMG class 와 bayesian score가 계산되어 나타납니다.&lt;br /&gt;
한번 직접 사용해보세요!&lt;/p&gt;
&lt;style&gt;
    table {
        border-collapse: collapse;
        margin: 10px 0px;
    }
    tr {
        padding: 0px 5px;
    }
    td {
        padding: 0px 5px;
        text-align: center;
    }
    input {
        text-align: center;
        border: none;
        font-size:24px;
    }
    input:focus {
        outline: none;
    }
    .rulebox {
        cursor:pointer;
    }
    .rulebox:hover {
        background-color: gray;
        opacity: 0.7;
    }
    .reset {
        cursor:pointer;
    }
    .reset:hover {
        background-color: gray;
        opacity: 0.7;
    }
    .rule_on{
        box-sizing: border-box;
        outline-offset: -2px;
        outline: solid 2px green;
    }
&lt;/style&gt;

&lt;h2&gt;ACMG class calculator&lt;/h2&gt;
&lt;p&gt;made by HJHan&lt;/p&gt;
&lt;h3&gt;click rules below:
&lt;table border=&quot;1&quot; style=&quot;width:100%;&quot;&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PVS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PVS1')&quot;&gt;PVS1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS1')&quot;&gt;PS1&lt;/td&gt;
        &lt;td id=&quot;PS2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS2')&quot;&gt;PS2&lt;/td&gt;
        &lt;td id=&quot;PS3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS3')&quot;&gt;PS3&lt;/td&gt;
        &lt;td id=&quot;PS4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PS4')&quot;&gt;PS4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PM1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM1')&quot;&gt;PM1&lt;/td&gt;
        &lt;td id=&quot;PM2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM2')&quot;&gt;PM2&lt;/td&gt;
        &lt;td id=&quot;PM3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM3')&quot;&gt;PM3&lt;/td&gt;
        &lt;td id=&quot;PM4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM4')&quot;&gt;PM4&lt;/td&gt;
        &lt;td id=&quot;PM5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM5')&quot;&gt;PM5&lt;/td&gt;
        &lt;td id=&quot;PM6&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PM6')&quot;&gt;PM6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;PP1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP1')&quot;&gt;PP1&lt;/td&gt;
        &lt;td id=&quot;PP2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP2')&quot;&gt;PP2&lt;/td&gt;
        &lt;td id=&quot;PP3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP3')&quot;&gt;PP3&lt;/td&gt;
        &lt;td id=&quot;PP4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP4')&quot;&gt;PP4&lt;/td&gt;
        &lt;td id=&quot;PP5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('PP5')&quot;&gt;PP5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;BS1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS1')&quot;&gt;BS1&lt;/td&gt;
        &lt;td id=&quot;BS2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS2')&quot;&gt;BS2&lt;/td&gt;
        &lt;td id=&quot;BS3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS3')&quot;&gt;BS3&lt;/td&gt;
        &lt;td id=&quot;BS4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BS4')&quot;&gt;BS4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td id=&quot;BP1&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP1')&quot;&gt;BP1&lt;/td&gt;
        &lt;td id=&quot;BP2&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP2')&quot;&gt;BP2&lt;/td&gt;
        &lt;td id=&quot;BP3&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP3')&quot;&gt;BP3&lt;/td&gt;
        &lt;td id=&quot;BP4&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP4')&quot;&gt;BP4&lt;/td&gt;
        &lt;td id=&quot;BP5&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP5')&quot;&gt;BP5&lt;/td&gt;
        &lt;td id=&quot;BP6&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP6')&quot;&gt;BP6&lt;/td&gt;
        &lt;td id=&quot;BP7&quot; class=&quot;rulebox&quot; onclick=&quot;rule_button('BP7')&quot;&gt;BP7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&quot;reset&quot; colspan=&quot;7&quot; onclick=&quot;reset()&quot;&gt;Reset&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;Class&lt;/td&gt;
        &lt;td id=&quot;acmgclass&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt;
        &lt;td&gt;Score&lt;/td&gt;
        &lt;td id=&quot;score&quot; colspan=&quot;2&quot; style=&quot;width:150px;&quot;&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/h3&gt;

&lt;script&gt;
    function reset(){
        document.getElementById('acmgclass').innerHTML = &quot;&quot;;
        document.getElementById('score').innerHTML = &quot;&quot;;
        var rulebuttons = document.getElementsByClassName(&quot;rulebox&quot;);
        for(var i=0; i&lt;rulebuttons.length; i++){
            rulebuttons[i].classList.remove(&quot;rule_on&quot;);
        }
    }

    // on/off color
    function rule_button(rule_id) {
        var element = document.getElementById(rule_id);
        element.classList.toggle(&quot;rule_on&quot;);
        update_res();
    }

    function update_res(){
        var cnt = 0;
        var pvs = 0;
        var ps = 0;
        var pm = 0;
        var pp = 0;
        var bs = 0;
        var bp = 0;
        var rulebuttons = document.getElementsByClassName(&quot;rulebox&quot;);
        for(var i=0; i&lt;rulebuttons.length; i++){
            var cond = rulebuttons[i].classList.contains(&quot;rule_on&quot;)
            if(cond){
                var rule_str = rulebuttons[i].id.substring(0,2);
                if(rule_str == &quot;PV&quot;){pvs += 1;}
                else if(rule_str == &quot;PS&quot;){ps += 1;}
                else if(rule_str == &quot;PM&quot;){pm += 1;}
                else if(rule_str == &quot;PP&quot;){pp += 1;}
                else if(rule_str == &quot;BS&quot;){bs += 1;}
                else if(rule_str == &quot;BP&quot;){bp += 1;}
            }
        }
        // update result
        var combined = combine_rule(pvs, ps, pm, pp, bs, bp);
        document.getElementById('acmgclass').innerHTML = combined;
        var b_score = cal_bayesian(pvs, ps, pm, pp, bs, bp);
        document.getElementById('score').innerHTML = b_score;
    }

    function combine_rule(pvs, ps, pm, pp, bs, bp){
        var class_res = &quot;VUS&quot;;
        if(pvs &gt;= 1){
            if(pvs &gt;= 2 || ps &gt;= 1 || pm &gt;= 2 || (pm == 1 &amp;&amp; pp == 1) || pp &gt;= 2){
                class_res = &quot;Pathogenic&quot;
            }else if(pvs == 1 &amp;&amp; pm &gt;= 1){
                class_res = &quot;Likely pathogenic&quot;
            }
        }else if(ps &gt;= 2){
                class_res = &quot;Pathogenic&quot;
        }else if(ps == 1){
            if(pm &gt;= 3 || (pm == 2 &amp;&amp; pp &gt;= 2) || (pm == 1 &amp;&amp; pp &gt;= 4)){
                class_res = &quot;Pathogenic&quot;
            }else if(pm &gt;= 1 || pp &gt;= 2){
                class_res = &quot;Likely pathogenic&quot;
            }
        }else if(pm &gt;= 3 || (pm == 2 &amp;&amp; pp &gt;= 2) || (pm == 1 &amp;&amp; pp &gt;= 4)){
            class_res = &quot;Likely pathogenic&quot;
        }
        // if the result is not &quot;VUS&quot; then break. pathogenic first.
        if(class_res !== &quot;VUS&quot;){
            return class_res
        }
        if(bs &gt;= 2){
            class_res = &quot;Benign&quot;;
        }else if((bs == 1 &amp;&amp; bp == 1) || bp &gt;= 2){
            class_res = &quot;Likely benign&quot;;
        }
        return class_res
    }

    function cal_bayesian(pvs, ps, pm, pp, bs, bp){
        var prior = 0.1;
        var odd_base = 350;
        var oddsPath = odd_base ** (pvs + ps/2 + pm/4 + pp/8 - bs/2 - bp/8)
        var res = oddsPath * prior / ((oddsPath - 1) * prior + 1)
        res = Number.parseFloat(res).toPrecision(5);
        return res
    }
&lt;/script&gt;

&lt;hr /&gt;

&lt;p&gt;지금까지 ACMG class 를 수치화 하는 bayesian framework 를 살펴보았습니다.&lt;br /&gt;
더욱 자세한 내용은 맨 위에 말씀드린 논문에서 찾아볼 수 있습니다.&lt;br /&gt;
그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Oct 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/clinical%20genomics/tech/2020/10/11/calculating-ACMG-class.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/clinical%20genomics/tech/2020/10/11/calculating-ACMG-class.html</guid>
        
        
        <category>biology</category>
        
        <category>clinical genomics</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>ACMG guideline 이란 무엇일까</title>
        <description>&lt;h3 id=&quot;acmg-guideline-이란-무엇일까&quot;&gt;ACMG guideline 이란 무엇일까&lt;/h3&gt;
&lt;p&gt;안녕하세요. 한헌종입니다.&lt;br /&gt;
오늘은 임상유전학 분야에서 거의 교과서처럼 쓰이고 있는 ACMG guideline에 대해 알아보려 합니다.&lt;br /&gt;
작성한 내용은 다음 논문을 참조해서 작성했습니다:&lt;br /&gt;
Richards, Sue et al. “Standards and guidelines for the interpretation of sequence variants: a joint consensus recommendation of the American College of Medical Genetics and Genomics and the Association for Molecular Pathology.” Genetics in medicine : official journal of the American College of Medical Genetics vol. 17,5 (2015): 405-24. doi:10.1038/gim.2015.30&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;환자의 유전 질환을 진단하려면 어디서부터 시작해야 할까요?&lt;br /&gt;
먼저 환자의 샘플을 채취하고, 시퀀싱 실험을 통해 환자의 DNA 염기서열을 알아내야겠죠.&lt;br /&gt;
그 다음 Reference genome 과 비교해 환자에게 어떤 돌연변이 (variants) 가 나타났는지 알아내야 합니다.&lt;br /&gt;
만약 환자에게서 기존에 알려진 유전병의 원인이 되는 변이가 발견된다면, 그 환자의 질병과 원인에 대해 알아낼 수 있겠죠.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/figure1.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;환자에게서 변이를 찾는 과정&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;문제는, 한명의 환자에게서 발견되는 돌연변이가 매우 많다는 것입니다.&lt;br /&gt;
Whole exome sequencing 실험을 통해 얻은 데이터를 살펴보면, 한 환자마다 약 7만~8만 개의 변이가 나타난다는 사실을 알 수 있습니다.&lt;br /&gt;
이렇게 많은 변이들 중에서 단 몇 개의 변이만 환자의 질병을 일으킵니다.&lt;br /&gt;
그럼 나머지 변이들은 뭘까요? 대부분의 변이는 질환과 상관없거나, 개인마다 그 위험성이 다르기 때문에 질병에 영향을 주지 않는 경우입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 이렇게 많은 변이들 중 ‘실제로’ 질병을 일으키는 변이를 어떻게 찾아낼 수 있을까요?&lt;br /&gt;
그 방법을 고안하기 위해 각지에서 전문가들이 모였습니다:&lt;br /&gt;
American College of Medical Genetics and Genomics,&lt;br /&gt;
Association for Molecular Pathology,&lt;br /&gt;
College of American Pathologist 에서 말이죠.&lt;br /&gt;
이렇게 모인 전문가들이 고안해낸 지침서가 바로 ACMG/AMP guideline 입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/ACMG_main.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;2015년에 출판된 ACMG/AMP guidelines 논문. 보통 줄여서 ACMG guideline 이라고 합니다.&lt;br /&gt;DOI: 10.1038/gim.2015.30&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;그래서-acmg-guideline-이-뭐라구요&quot;&gt;그래서 ACMG guideline 이 뭐라구요?&lt;/h3&gt;
&lt;p&gt;한 마디로 변이의 ‘병원성’ (pathogenicity) 를 판단하는 기준들 입니다.&lt;br /&gt;
물론 위의 논문을 읽어보시면, 변이 판별 외에도 사용되는 용어, 명명법, 사용하는 데이터베이스에 대한 설명, 변이를 보고할 때의 고려사항 등 세부적인 내용이 많이 포함되어 있습니다.&lt;br /&gt;
(이 부분들 역시 그리 간단하지가 않습니다..)&lt;br /&gt;
오늘은 그 내용 중에서도, 변이를 판단하는 기준에 집중해볼까요?&lt;/p&gt;

&lt;p&gt;변이에 대한 판별은 두 단계로 나누어집니다.&lt;br /&gt;
&lt;strong&gt;첫 번째 단계는 Evidence 를 할당하는 과정,&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;두 번째 단계는 Pathogenicity 를 구분하는 과정입니다.&lt;/strong&gt;&lt;br /&gt;
이 과정을 거치게 되면, 이중 어떤 변이가 정말로 병을 일으킬 만한지 알 수 있게 됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure2.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;첫 번째 단계를 먼저 살펴볼까요?&lt;br /&gt;
어떤 변이에 대해 evidence 를 할당한다는 것은, 다시 말해서 병원성에 대한 증거를 붙여놓는 것입니다.&lt;br /&gt;
이를 위해서 ACMG guideline 에서는 &lt;strong&gt;28 개의 ‘규칙 (rules)’&lt;/strong&gt; 들을 정해놓았습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure3.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 규칙들은 크게 병원성/비병원성 (Pathogenic/benign) 으로 나뉩니다.&lt;br /&gt;
또한 그 경중에 따라 크게 4가지로 나뉩니다. (Very strong/Strong/Moderate/Supporting)&lt;br /&gt;
예를 들어서, PS3 rule 은 특정 변이가 Pathogenic 하다는 것에 관련된 rule 중 하나이며, 그 강도가 Strong 으로 매우 강력합니다.&lt;br /&gt;
BP7 rule 은 특정 변이가 Benign 하다는 것에 관련된 규칙이고, 그 강도가 Supporting으로 약합니다.&lt;br /&gt;
이 규칙들에 따라서 특정 변이에 대해서 evidence 들을 할당하는 과정이 첫 번째 단계라고 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;그런데-대체-그-rule-이-뭐죠&quot;&gt;그런데 대체 그 rule 이 뭐죠?&lt;/h3&gt;
&lt;p&gt;아래 그림에 28개 rule에 대한 설명 중 일부를 가져와봤습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200927/figure4.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예를 들어, PS3 evidence 다음과 같은 경우에 할당한다고 하네요:&lt;br /&gt;
PS3: Well-established in vitro or in vivo functional studies supportive of a damaging effect on the gene or gene &lt;br /&gt;
product&lt;br /&gt;
즉, in vitro/in vivo 실험을 통해 특정 변이가 유전자에 손상을 줄 수 있다는 연구가 제시된 경우, 그 변이에 PS3를 할당할 수 있습니다.&lt;br /&gt;
한 변이가 여러 규칙에 해당된다면, 여러 evidence 들을 할당할 수도 있는거죠.&lt;br /&gt;
이렇게 각 규칙에 따라서 변이에 여러가지 evidence 들을 적용하는 과정을 거치면, 1단계가 완성됩니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;두 번째 단계를 살펴볼까요?&lt;br /&gt;
변이에 대해 evidence들을 할당하고 나면, 어떤 변이들은 Pathogenic evidence를 매우 많이 가지고 있을 수도 있습니다.&lt;br /&gt;
혹은 몇몇 강력한 evidence를 가지고 있는 변이도 있겠죠.&lt;br /&gt;
이 evidence를 종합적으로 판단해서 변이를 다섯 등급 중 하나로 구분합니다:&lt;br /&gt;
Pathogenic, Likely pathogenic, Uncertain signifiacne, Likely benign, Benign&lt;/p&gt;

&lt;p&gt;사실 각 evidence를 정량적으로 판단할 수는 없지만, ACMG guideline에서 방법을 제시하고 있습니다.&lt;br /&gt;
예를 들어 Pathogenic strong evidence 를 두 개 가지고 있는 변이는 마침내 ‘Pathogenic’ 변이로 구분될 수 있습니다.&lt;br /&gt;
이렇게 evidence 들의 조합으로 변이가 정말 pathogenic 인지 확인하는 과정이 바로 두 번째 단계입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200927/figure5.jpg&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;논문에서 발췌한 Pathogenicity class 구분표 입니다.&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;이렇게 ACMG guidelines 의 일부분을 살펴보았습니다.&lt;br /&gt;
물론 이렇게 변이의 pathogenicity를 구분한 뒤에도, 아직도 매우 많은 변이가 Pathogenic 하다고 나올 수 있습니다.&lt;br /&gt;
또한, Pathogenic 으로 구분된 변이라고 무조건 질병을 일으킨다는 보장이 없으며, Uncertain 변이로 구분되었다고 해서 질병과 상관없다고 단정지을 수도 없습니다.&lt;br /&gt;
그리고 실제 진단까지 가려면 이 뿐만 아니라 환자의 증상이나 가족력 등 더 자세한 정보가 필요할 것입니다.&lt;br /&gt;
그럼에도 불구하고, 적어도 선택해야 할 변이의 수를 줄여줄 뿐만 아니라 그 변이들에 대한 설명을 제시해준다는 점에서 ACMG guideline은 큰 의미를 가진다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;오늘도 매우 어려운 내용의 겉핥기를 해보았습니다.&lt;br /&gt;
ACMG guidelines 는 2015년에 나온 이후로 계속 발전하고 있습니다.&lt;br /&gt;
향후 이런 내용에 대해서도 나중에 자세히 다뤄볼까 합니다.&lt;/p&gt;

&lt;p&gt;그럼 여러분, 다음 글에서 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/clinical%20genomics/2020/09/27/ACMG-guideline-2015.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/clinical%20genomics/2020/09/27/ACMG-guideline-2015.html</guid>
        
        
        <category>biology</category>
        
        <category>clinical genomics</category>
        
      </item>
    
      <item>
        <title>파일 형식을 알아보자! 두번째 (VCF, BED, GTF, GFF)</title>
        <description>&lt;h3 id=&quot;생명정보학-분석에서-자주-만나는-파일-형식을-알아봅시다-2&quot;&gt;생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다 (2)&lt;/h3&gt;

&lt;p&gt;안녕하세요, 한헌종입니다.&lt;br /&gt;
오늘은 저번 포스팅에 이어서 생명정보학 분야에서 자주 만나게 되는 파일 형식을 알아보려 합니다.&lt;br /&gt;
오늘은 VCF, BED, GTF, GFF를 알아봅시다.&lt;/p&gt;

&lt;h3 id=&quot;vcf-variant-call-format&quot;&gt;VCF (Variant Call Format)&lt;/h3&gt;

&lt;p&gt;VCF 파일은 Variants 즉 변이 정보를 기록할 때 사용되는 형식입니다.&lt;br /&gt;
Genome 상에서 어느 위치에 원래는 어떤 서열인데 어떤 유전변이가 일어난건지, genotype은 무엇인지에 대한 정보를 가지고 있죠.&lt;br /&gt;
이 VCF 파일 형식은 1000 genome project와 같이 대규모 시퀀싱 프로젝트가 진행되면서 만들어졌다고 해요.&lt;br /&gt;
VCF 파일은 아래와 같이 생겼습니다. 크게 두 부분으로 나뉘어져 있죠. header 와 body 입니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;##fileformat=VCFv4.3&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##fileDate=20090805&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##source=myImputationProgramV3.1&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##reference=file:///seq/references/1000GenomesPilot-NCBI36.fasta&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##contig=&amp;lt;ID=20,length=62435964,assembly=B36,md5=f126cdf8a6e0c7f379d618ff66beb2da,species=&quot;Homo sapiens&quot;,taxonomy=x&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##phasing=partial&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##INFO=&amp;lt;ID=NS,Number=1,Type=Integer,Description=&quot;Number of Samples With Data&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##INFO=&amp;lt;ID=DP,Number=1,Type=Integer,Description=&quot;Total Depth&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##INFO=&amp;lt;ID=AF,Number=A,Type=Float,Description=&quot;Allele Frequency&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##INFO=&amp;lt;ID=AA,Number=1,Type=String,Description=&quot;Ancestral Allele&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##INFO=&amp;lt;ID=DB,Number=0,Type=Flag,Description=&quot;dbSNP membership, build 129&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##INFO=&amp;lt;ID=H2,Number=0,Type=Flag,Description=&quot;HapMap2 membership&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##FILTER=&amp;lt;ID=q10,Description=&quot;Quality below 10&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##FILTER=&amp;lt;ID=s50,Description=&quot;Less than 50% of samples have data&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##FORMAT=&amp;lt;ID=GT,Number=1,Type=String,Description=&quot;Genotype&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##FORMAT=&amp;lt;ID=GQ,Number=1,Type=Integer,Description=&quot;Genotype Quality&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##FORMAT=&amp;lt;ID=DP,Number=1,Type=Integer,Description=&quot;Read Depth&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;##FORMAT=&amp;lt;ID=HQ,Number=2,Type=Integer,Description=&quot;Haplotype Quality&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#CHROM POS      ID         REF   ALT    QUAL  FILTER   INFO                             FORMAT       NA00001         NA00002          NA00003&lt;/span&gt;
20     14370    rs6054257  G     A      29    PASS    &lt;span class=&quot;nv&quot;&gt;NS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;14&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.5&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;DB&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;H2           GT:GQ:DP:HQ  0|0:48:1:51,51  1|0:48:8:51,51   1/1:43:5:.,.
20     17330    &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;          T     A      3     q10     &lt;span class=&quot;nv&quot;&gt;NS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;11&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.017               GT:GQ:DP:HQ  0|0:49:3:58,50  0|1:3:5:65,3     0/0:41:3
20     1110696  rs6040355  A     G,T    67    PASS    &lt;span class=&quot;nv&quot;&gt;NS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.333,0.667&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;T&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;DB GT:GQ:DP:HQ  1|2:21:6:23,27  2|1:2:0:18,2     2/2:35:4
20     1230237  &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;          T     &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;      47    PASS    &lt;span class=&quot;nv&quot;&gt;NS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;13&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;T                   GT:GQ:DP:HQ  0|0:54:7:56,60  0|0:48:4:51,51   0/0:61:2
20     1234567  microsat1  GTC   G,GTCT 50    PASS    &lt;span class=&quot;nv&quot;&gt;NS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;9&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;AA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;G                    GT:GQ:DP     0/1:35:4        0/2:17:2         1/1:40:3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;VCF 파일의 예시. header 21줄과 body 5줄로 이루어져 있군요.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;header&lt;/strong&gt; 는 샵 (#) 으로 시작하는 VCF의 가장 윗부분을 말합니다.&lt;br /&gt;
샵 두개 (##) 로 시작하는 metadata 부분과, 샵 하나 (#)로 시작하는 header 으로 되어있죠.&lt;/p&gt;

&lt;p&gt;metadata 부분은 VCF 파일의 전반적인 정보를 가지고 있습니다.&lt;br /&gt;
파일 형식, 날짜, 그리고 body의 INFO/FORMAT column에서 사용되는 단어들에 대한 설명이 포함되어 있죠.&lt;br /&gt;
예를 들어 body 의 INFO column에 있는 정보 중 NS=3 이란 정보가 있는데, header의 설명을 보면&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;INFO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;&lt;span class=&quot;nv&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;NS, ... &lt;span class=&quot;nv&quot;&gt;Description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Number of Samples With Data&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;라고 되어 있으니 NS가 샘플 수라는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;header 부분은 body 에 적혀있는 데이터의 각 열이 어떤 걸 뜻하는지를 나타내는 컬럼 제목부분 입니다.&lt;br /&gt;
즉 이 부분은 body 의 데이터와 같은 수의 항목을 가지고 있지요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt; 부분은 실제 변이들의 데이터로 되어있습니다.&lt;br /&gt;
body에는 꼭 들어가야 하는 8개의 컬럼이 있는데요, 순서대로 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;#CHROM: 염색체 정보&lt;/li&gt;
  &lt;li&gt;POS: position. 해당 염색체에서 변이가 일어난 염기서열 위치를 말합니다.&lt;/li&gt;
  &lt;li&gt;ID: 변이를 나타내는 고유 ID가 있는 경우 표시합니다. 보통 dbSNP (rs로 시작하는) ID를 적거나 ‘.’ 으로만 적어둡니다.&lt;/li&gt;
  &lt;li&gt;REF: reference genome 상에서의 원래 염기서열&lt;/li&gt;
  &lt;li&gt;ALT: 돌연변이로 바뀐 서열&lt;/li&gt;
  &lt;li&gt;QUAL: 해당 variant를 찾아낸 것에 대한 quality score&lt;/li&gt;
  &lt;li&gt;FILTER: 해당 변이가 특정 필터기준을 통과했는지에 대한 표시 (flag)&lt;/li&gt;
  &lt;li&gt;INFO: 각 변이에 대한 자세한 설명이 적힌 컬럼.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 컬럼들은 모두 탭 (tab)으로 나뉘어져 있죠.&lt;br /&gt;
이 외의 컬럼은 없어도 VCF파일이라 할 수 있습니다. 그러나 보통 FORMAT 컬럼, sample 컬럼 하나씩이 더 추가되어 있는 경우가 많습니다.&lt;br /&gt;
보통 한 개의 샘플 정보가 적혀있지만, 가끔 2개 이상의 샘플 정보가 있는 경우 그만큼 컬럼 수도 늘어나게 됩니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;FORMAT: 각 샘플에서 변이 정보를 나타내는 필드 종류. colon (:) 으로 나뉘어져 있습니다. 보통 genotype (GT), AD (allele depth), DP (Total read depth) 등이 적혀 있습니다.&lt;/li&gt;
  &lt;li&gt;sample (실제 샘플 이름이 적힘): FORMAT 에 적힌 필드들의 각 샘플에서의 수치. colon (:)으로 나뉘어져 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;bed-browser-extensible-data&quot;&gt;BED (Browser Extensible Data)&lt;/h3&gt;
&lt;p&gt;BED 파일 형식은 Human Genome Project 가 진행되면서 만들어진 형식이라고 해요.&lt;br /&gt;
bed 파일은 염색체의 특정 ‘영역’에 대한 정보 (annotation) 를 기록하고 사용하기 위해 만들어 졌습니다.&lt;br /&gt;
예를 들어, ChIP-seq 실험 결과를 통해 얻은 protein binding region 을 표시하고자 할 때 쓰일 수 있어요.&lt;br /&gt;
탭 (tab)으로 나뉘어져 있고 염기서열과 같이 큰 정보가 없어서 파싱하기 용이한 형식으로 널리 쓰이게 되었죠.&lt;/p&gt;

&lt;p&gt;bed 파일은 최소 3개의 컬럼만 있으면 되는데, 이에 컬럼이 추가되어서 총 12개까지 늘어날 수 있습니다.&lt;br /&gt;
용도에 따라 필요한 컬럼 수가 다른거죠.&lt;br /&gt;
그래서 컬럼 수에 따라서 확장자 이름을 bed3, bed4, bed12 등으로 나타내기도 합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;track &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pairedReads &lt;span class=&quot;nv&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Clone Paired Reads&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;useScore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1
chr22 1000 5000 cloneA 960 + 1000 5000 0 2 567,488, 0,3512
chr22 2000 6000 cloneB 900 - 2000 6000 0 2 433,399, 0,3601
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;일반적인 bed 파일의 예시.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;bed 파일도 header 와 body 로 나뉘어져 있습니다.&lt;br /&gt;
&lt;strong&gt;header&lt;/strong&gt; 는 기본적으로 track name, description 등이 적혀져 있는 한 줄입니다.&lt;br /&gt;
그런데 이 bed 파일이 UCSC genome browser 등에서 쓰이는 경우, header 에는 추가적인 정보가 들어가기도 합니다.&lt;br /&gt;
추가적인 정보는 browser에서 이 파일을 사용했을 때, 어느 위치를 보여줄 것인지, 어떤 포맷으로 보여줄지 등 다양합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;browser position chr7:127471196-127495720
browser hide all
track &lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ItemRGBDemo&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Item RGB demonstration&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;visibility&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2 &lt;span class=&quot;nv&quot;&gt;itemRgb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;On&quot;&lt;/span&gt;
chr7    127471196  127472363  Pos1  0  +  127471196  127472363  255,0,0
chr7    127472363  127473530  Pos2  0  +  127472363  127473530  255,0,0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;추가 정보가 header 에 들어있는 bed 파일의 예시.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt; 부분은 탭으로 나뉘어져 있습니다.&lt;br /&gt;
컬럼 수는 3개짜리 파일도 있고, 6개, 9개 등 다양합니다.&lt;br /&gt;
각 컬럼에는 다음과 같은 정보들이 포함되어 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;chrom: 염색체 정보&lt;/li&gt;
  &lt;li&gt;chromStart: 해당 영역의 시작서열 위치&lt;/li&gt;
  &lt;li&gt;chromEnd: 해당 영역의 끝서열 위치&lt;/li&gt;
  &lt;li&gt;name: 영역의 이름&lt;/li&gt;
  &lt;li&gt;score: 영역의 점수 0~1000&lt;/li&gt;
  &lt;li&gt;strand: DNA strand (+/-)&lt;/li&gt;
  &lt;li&gt;thickstart: 해당 영역이 시각화 될 때 두껍게 보여질 부분의 시작위치&lt;/li&gt;
  &lt;li&gt;thickend: 해당 영역이 시각화 될 때 두껍게 보여질 부분의 끝위치&lt;/li&gt;
  &lt;li&gt;itemRgb: 해당 영역이 시각화 될 때 나타날 색깔&lt;/li&gt;
  &lt;li&gt;blockCount: 해당 영역의 Exon 과 같은 block의 수&lt;/li&gt;
  &lt;li&gt;blockSizes: comma (,) 로 나뉘어진 블록들의 크기&lt;/li&gt;
  &lt;li&gt;blockStarts: comma (,) 로 나뉘어진 start 위치 목록. 이는 두번째 컬럼인 chromStart로 부터의 상대적 위치 (zero-base) 입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gff-general-feature-format&quot;&gt;GFF (General Feature Format)&lt;/h3&gt;
&lt;p&gt;GFF 는 DNA/RNA/protein 서열을 설명할 때 사용되는 파일 형식입니다.&lt;br /&gt;
한 줄에는 한 영역 (feature) 에 대한 설명이 9개 컬럼에 걸쳐서 적혀있습니다.&lt;br /&gt;
아래는 그 예시입니다:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chr22	TeleGene	enhancer	10000000	10001000	500	+	&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;	touch1
chr22	TeleGene	promoter	10010000	10010100	900	+	&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;	touch1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 컬럼이 어떤건지 살펴볼까요?&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sequence: 해당 서열의 이름&lt;/li&gt;
  &lt;li&gt;source: 해당 feature 이 어디서 왔는지에 대한 설명 (feature를 작성한 프로그램이나 연구기관 등)&lt;/li&gt;
  &lt;li&gt;feature: 해당 영역의 이름 (gene 혹은 exon 등)&lt;/li&gt;
  &lt;li&gt;start: 해당 영역의 시작위치 (one-base)&lt;/li&gt;
  &lt;li&gt;end: 해당 영역의 끝 위치 (one-base)&lt;/li&gt;
  &lt;li&gt;score: 영역에 대한 신뢰도 점수&lt;/li&gt;
  &lt;li&gt;strand: ‘+’ (forward) 혹은 ‘-‘ (reverse) 가닥&lt;/li&gt;
  &lt;li&gt;frame: 0,1,2 혹은 dot(.). 0은 해당 feature 의 첫 번째 서열이 reference 의 codon start 서열이라는 뜻이며, 1은 해당 feature의 두 번째 서열이 reference 의 codon start 서열이라는 뜻입니다. 만약 feature 가 exon 이 아닌 경우에는 ‘.’ 으로 되어있어요.&lt;/li&gt;
  &lt;li&gt;group: feature 가 속한 group. 같은 group 인 line 들은 같은 group 값을 가집니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 중 frame 컬럼은 phase라고도 불리는데, &lt;a href=&quot;https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md&quot;&gt;Sequence Ontology (SO) 문서&lt;/a&gt; 에 더 자세히 설명되어 있으니 한번 살펴보세요.&lt;/p&gt;

&lt;h3 id=&quot;gtf-gene-transfer-format&quot;&gt;GTF (Gene Transfer Format)&lt;/h3&gt;
&lt;p&gt;GTF 파일 형식은 GFF 와 매우 유사한 형식이에요.&lt;br /&gt;
실제로 GFF - GTF 변환도 가능하죠.&lt;br /&gt;
GTF 형식의 처음 8개 컬럼은 GFF 와 동일합니다.&lt;/p&gt;

&lt;p&gt;그러나 차이점이 있습니다.&lt;br /&gt;
GTF 파일에는 gene, exon 등의 feature 말고도 5’UTR, 3’UTR, inter, intron 등이 포함되어 있기도 합니다.&lt;br /&gt;
또한, GFF 형식의 9번째 컬럼 ‘group’이 semicolon으로 나뉜 ‘attribute’ 컬럼으로 바뀝니다.&lt;br /&gt;
각 attribute 는 해당 feature에 대한 설명이 type-value 짝을 이루어서 적혀 있어요.&lt;/p&gt;

&lt;p&gt;9번째 컬럼만 보면 다음과 같이 되어 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gene_id &lt;span class=&quot;s2&quot;&gt;&quot;ENSG00000223972&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; gene_name &lt;span class=&quot;s2&quot;&gt;&quot;DDX11L1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; gene_source &lt;span class=&quot;s2&quot;&gt;&quot;havana&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; gene_biotype &lt;span class=&quot;s2&quot;&gt;&quot;transcribed_unprocessed_pseudogene&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
gene_id &lt;span class=&quot;s2&quot;&gt;&quot;ENSG00000223972&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; transcript_id &lt;span class=&quot;s2&quot;&gt;&quot;ENST00000456328&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; gene_name &lt;span class=&quot;s2&quot;&gt;&quot;DDX11L1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; gene_sourc e &lt;span class=&quot;s2&quot;&gt;&quot;havana&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; gene_biotype &lt;span class=&quot;s2&quot;&gt;&quot;transcribed_unprocessed_pseudogene&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; transcript_name &lt;span class=&quot;s2&quot;&gt;&quot;DDX11L1-002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; transcript_source &lt;span class=&quot;s2&quot;&gt;&quot;havana&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;GTF 에는 해당 feature에 대해 더 자세한 설명이 적혀있는 걸 알 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘 설명드린 파일들은 제가 자주 사용해오던 파일 형식들입니다.&lt;br /&gt;
그런데도 각 컬럼에 대한 세세한 설명까지 알고 있지는 못했던 것 같아요.&lt;br /&gt;
이번 기회에 공부해볼 수 있어서 좋았던 것 같습니다.&lt;/p&gt;

&lt;p&gt;다음에는 또 다른 내용으로 포스팅 해보겠습니다.&lt;br /&gt;
그럼 다음에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Sep 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2020/09/13/bioinformatics-formats2.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2020/09/13/bioinformatics-formats2.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>파일 형식을 알아보자! (FASTA, FASTQ, BAM, SAM)</title>
        <description>&lt;h3 id=&quot;생명정보학-분석에서-자주-만나는-파일-형식을-알아봅시다&quot;&gt;생명정보학 분석에서 자주 만나는 파일 형식을 알아봅시다&lt;/h3&gt;

&lt;p&gt;안녕하세요, 한헌종입니다.&lt;br /&gt;
오늘은 생명정보학 분야에서 자주 만나게 되는 파일 형식이 어떤 게 있는지 알아봅시다.&lt;/p&gt;

&lt;p&gt;생명정보학을 공부하면서 가장 많이 만나게 되는 파일 형식은 사실 tsv, csv일 것입니다.&lt;br /&gt;
이 형식들은 여러분이 잘 알고 계시는 ‘표’ 형태의 정보를 텍스트 파일로 나타낸 것입니다.&lt;br /&gt;
tsv 는 tab-separated values, 즉 ‘탭’으로 데이터를 나누어 적어놓은 파일이구요,&lt;br /&gt;
csv 는 comma-separated values, 즉 ‘쉼표’로 데이터를 나누어 적어놓은 파일입니다.&lt;br /&gt;
어려울 것 없이, 그냥 표라고 생각하시면 됩니다. tsv,csv 파일을 엑셀로 열면 아주 이쁘게 표로 표현된답니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;csv 형태의 데이터는 표와 같습니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;세상의 모든 데이터가 tsv/csv 처럼 단순한 형태로 있으면 참 편할텐데, 그렇지가 않습니다.&lt;br /&gt;
생명정보학을 공부하시다 보면 아래에 소개드릴 특별한 파일 형식들을 많이 만나보시게 될 겁니다.&lt;br /&gt;
(사실 생각나는 대로 적어본 거라, 서로 연관성은 많이 없습니다.)&lt;br /&gt;
이 형식들에 익숙해지시면 데이터를 이해하고 분석하는 게 한결 수월해지실 겁니다.&lt;/p&gt;

&lt;p&gt;그럼 한 번 알아볼까요?&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;fasta&quot;&gt;FASTA&lt;/h3&gt;

&lt;p&gt;FASTA 파일은 특정 분자의 서열을 나타내는 데에 사용됩니다.&lt;br /&gt;
주로 Genome 의 각 chromosome 마다의 서열을 저장하는 데 쓰이죠.&lt;br /&gt;
혹은 gene/transcript/protein 각각의 염기서열 및 아미노산 서열을 저장할 때 사용되는 형식이에요.&lt;/p&gt;

&lt;p&gt;FASTA 파일은 두 형태가 반복되는 형식입니다.&lt;br /&gt;
첫 부분은 그 아래에 나올 서열의 이름/ID 입니다. 항상 &amp;gt; (꺽쇠) 글자로 시작하죠.&lt;br /&gt;
다음에는 그 이름에 해당하는 서열이 나오게 됩니다.&lt;br /&gt;
보통 그 서열은 굉장히 깁니다. 염색체는 말할 것도 없고, 특정 유전자나 단백질도 몇백-몇만 글자로 표현해야 하죠.&lt;br /&gt;
그래서 이를 한 줄로 나타내지 않고, 보통 60글자씩 나눠서 여러 줄에 걸쳐 표현합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;FASTA 파일의 예시. 이름-서열-이름-서열 이 반복되네요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* 주의: FASTA 파일은 보통 엄청나게 크기 때문에, 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;fastq&quot;&gt;FASTQ&lt;/h3&gt;

&lt;p&gt;fastq 파일은 NGS (Next generation sequencing data) 의 결과를 저장하는 데 주로 쓰입니다.&lt;br /&gt;
NGS 실험을 진행하면, 그 결과로 cDNA library 서열을 읽어서 데이터로 얻을 수 있습니다.&lt;br /&gt;
즉, 각 cDNA library 의 염기서열을 알 수 있는거죠.&lt;br /&gt;
이 서열 하나를 ‘read’ 라고 하는데요.&lt;br /&gt;
fastq 파일은 여러 read 의 정보를 한 파일에 저장하게 됩니다.&lt;/p&gt;

&lt;p&gt;보통 이 파일을 직접 사용하기보다, reference genome 에 align 한 뒤에 활용됩니다.&lt;br /&gt;
fastq 파일은 대부분의 연구에서 raw data, 즉 가공되지 않은 원본 파일로 여겨집니다.&lt;br /&gt;
그러니 분석하실 땐 fastq를 잘 백업해두셔서 잃어버리지 않도록 하세요!&lt;/p&gt;

&lt;p&gt;fastq 파일은 네 줄이 한 단위입니다.&lt;br /&gt;
위에서 말씀드린 것처럼 하나의 cDNA library 정보가 네 줄에 나눠서 표현되어 있는 거죠.&lt;br /&gt;
이들은 각각 다음 정보를 가지고 있습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sequence ID: @ 로 시작하며, 해당 서열의 이름을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;sequence: 실제로 읽은 염기서열 정보입니다.&lt;/li&gt;
  &lt;li&gt;description: ‘+’ 글자로 시작하는데, + 하나만 있기도 하고 sequence ID를 넣거나 설명을 넣는 부분입니다.&lt;/li&gt;
  &lt;li&gt;quality: 각 염기서열이 얼마나 정확히 읽혔는지를 나타냅니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Phred_quality_score&quot;&gt;Phred quality score&lt;/a&gt; 라는 표현법을 사용합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;fastq 파일의 예시. 이름-서열-설명-품질 이 반복됩니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;* 주의: fastq 파일도 역시, 보통은 엄청나게 크기 때문에 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;bam-sam&quot;&gt;BAM, SAM&lt;/h3&gt;

&lt;p&gt;BAM 파일을 먼저 살펴볼까요.&lt;br /&gt;
BAM 은 binary alignment map 이라는 형식이에요.&lt;br /&gt;
이 파일은 위에서 설명한 fastq 파일을 reference genome에 align 했을 때 만들어지는 파일이죠.&lt;br /&gt;
즉, 각 cDNA library 조각이 reference genome 의 어느부분에서 나왔구나~ 하는 정보를 담았다는 거죠.&lt;br /&gt;
fastq 에서는 각 read 의 염기서열과 그 품질을 알 수 있다면, BAM 파일은 염기서열과 reference 에서의 위치정보 를 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇지만 BAM 파일은 사람이 읽을 수 없는 파일입니다…&lt;br /&gt;
정보를 압축하기 위해 binary 형태로 저장된 파일이기 때문이죠.&lt;br /&gt;
다행히도 이 BAM 파일을 ‘볼 수 있게’ 해놓은 파일이 있습니다. 바로 SAM 파일입니다.&lt;br /&gt;
BAM 파일과 SAM 파일은 동일한 정보를 가지고 있고, 서로 변환이 가능합니다. (변환 방법은 다음에 설명드릴게요)&lt;/p&gt;

&lt;p&gt;SAM 파일은 header 부분과 alignment 부분으로 이루어져 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;header&lt;br /&gt;
header 부분은 파일에 대한 설명을 주는 부분입니다. @ 로 시작하는 라인들입니다.&lt;/li&gt;
  &lt;li&gt;alignment&lt;br /&gt;
alignment 부분이 각 read에 대한 alignment 정보를 제공하는 부분입니다.&lt;br /&gt;
필수적인 11개의 컬럼으로 이루어져 있고, 추가로 몇 개의 컬럼이 더 있을 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200826/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;SAM 파일의 예시. 11개 컬럼이 너무 길어서 엑셀로 표시해보았어요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;각 column의 설명은 다음과 같습니다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;QNAME: read 이름&lt;/li&gt;
  &lt;li&gt;FLAG: 2진수로 된 read alignment 에 대한 설명&lt;/li&gt;
  &lt;li&gt;RNAME: refernce sequence 의 이름&lt;/li&gt;
  &lt;li&gt;POS: reference sequence 에서 align 된 위치&lt;/li&gt;
  &lt;li&gt;MAPQ: mapping quality. 즉 얼마나 정확히 align 되었는지.&lt;/li&gt;
  &lt;li&gt;CIGAR string: alignment 정보를 표현한 문자열. Match, Gap 등의 설명을 각 염기마다 표현합니다.&lt;/li&gt;
  &lt;li&gt;RNEXT: 다음 read 의 reference sequence 이름. 주로 paired end read 에 대한 분석을 위해 사용됩니다.&lt;/li&gt;
  &lt;li&gt;PNEXT: 다음 read 의 align 된 위치. 주로 paired end read 에 대한 분석을 위해 사용됩니다.&lt;/li&gt;
  &lt;li&gt;TLEN: Template length. paired-end read 둘의 left-end 부터 right-end 까지의 길이입니다.&lt;/li&gt;
  &lt;li&gt;SEQ: segment sequence. 염기 서열을 나타냅니다.&lt;/li&gt;
  &lt;li&gt;QUAL: Phread quality score 입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;와, 저도 이 11개 컬럼의 뜻을 모두 알지는 못했는데 이렇게 많은 정보가 있는 줄은 몰랐네요!&lt;br /&gt;
* 주의: SAM 파일도 역시, 읽을수는 있다고 하나 엄청나게 크기 때문에 가정용 컴퓨터에서 열어보지 않는 걸 추천합니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘은 FASTA, FASTQ, BAM/SAM 파일에 대해 알아봤습니다.&lt;br /&gt;
분석의 앞부분에서 꼭 마주치게 되는 형식들이죠.&lt;br /&gt;
평소에 잘 안다고 생각했던 것들인데, 자세히 들어가보니 내용이 무척 많네요.&lt;br /&gt;
언젠가 이 파일들이 분석 순서상으로 어떻게 연관되어 있는지도 설명드릴게요.&lt;/p&gt;

&lt;p&gt;아, 그리고 이 외에도 널리 사용되는 파일 형식들이 많은데요, VCF/BED/GTF 등이 있어요.&lt;br /&gt;
이 형식들은 다음에 또 알아보도록 할게요.&lt;/p&gt;

&lt;p&gt;그럼 다음시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/biology/tech/2020/08/26/Bioinformatics-fileformats.html</link>
        <guid isPermaLink="true">http://localhost:4000/biology/tech/2020/08/26/Bioinformatics-fileformats.html</guid>
        
        
        <category>biology</category>
        
        <category>tech</category>
        
      </item>
    
      <item>
        <title>깃 블로그에서 코드블록 만들기 - liquid, html, markdown을 한 번에!</title>
        <description>&lt;h3 id=&quot;깃-블로그에서-코드-부분을-볼-수-있게-해보자&quot;&gt;깃 블로그에서 코드 부분을 볼 수 있게 해보자!&lt;/h3&gt;

&lt;p&gt;안녕하세요 한헌종입니다.&lt;br /&gt;
이번엔 블로그에서 코드를 설명할 때 특정 블록으로 처리하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;깃 블로그는 Jekyll로 이루어져 있고, 각 포스트는 .md 파일로 구성되어 있죠.&lt;br /&gt;
이 파일 안에는 그냥 텍스트를 쓸 수도 있지만, liquid, html, markdown 세가지 언어를 통해 특정 기능이나 표현을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그런데 어떤 코드를 썼는지를 그대로 보여주려면 어떻게 할까요?&lt;br /&gt;
예를 들어, 아래처럼 이탤릭체로 기울어진 텍스트는 ‘asterisk 별표 모양을 글 양옆에 붙이면 된다’는 설명을 어떻게 하면 될까요?&lt;br /&gt;
&lt;em&gt;기울임글자&lt;/em&gt;&lt;br /&gt;
별표-텍스트-별표 라고 쓰세요! 이런식으로 설명할 수도 없고 말이죠.&lt;/p&gt;

&lt;p&gt;이럴 때, 코드블록이 필요합니다.&lt;br /&gt;
깃 블로그에서 쓰는 liquid, html, markdown 세가지에 대해 어떻게 코드를 나타낼 수 있는지 알아보겠습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;liquid-의-경우&quot;&gt;liquid 의 경우&lt;/h3&gt;

&lt;p&gt;Jekyll 은 중괄호-퍼센트 글자 사이, 즉 {% 와 %} 모양 안에 특정 문구를 넣어서 원하는 명령을 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이걸 liquid 언어라고 하는데요, 이처럼 작성하면 Jekyll이 이 부분을 인식하고 렌더링을 통해 특정 기능을 실행합니다.&lt;br /&gt;
사실 이전 포스트에서 ‘이 코드를 넣으세요’ 라며 설명하는 부분이 있었는데,&lt;br /&gt;
그 코드를 실제로 쓰려니 코드가 렌더링 되어서 여러분께 보여드릴 수가 없었습니다.&lt;/p&gt;

&lt;p&gt;그래서 찾아보았습니다. 역시 구글은 검색하면 다 나오는군요.&lt;br /&gt;
아래처럼 Jekyll liquid 언어를 블로그에 넣는 방법을 설명드리겠습니다.&lt;br /&gt;
두 가지 방법이 있습니다. 하나는 raw-endraw 구문, 다른 하나는 highlight-endhighlight 구문입니다.&lt;/p&gt;

&lt;p&gt;{%- if page.comments -%}&lt;br /&gt;
    {%- include disqus_comments.html -%}&lt;br /&gt;
{%- endif -%}&lt;/p&gt;

&lt;p&gt;위 세줄을 .md 파일에 그냥 쓰면 이 글에서 보이지 않을 겁니다. 그럼 어떻게 한 걸까요?&lt;br /&gt;
방법은 정말 간단합니다.&lt;br /&gt;
아래 그림처럼 raw - endraw 구문을 넣으면 됩니다!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200822/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;이렇게 말입니다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;정말 쉽죠?&lt;br /&gt;
liquid 문구 중 raw-endraw 라는 문구를 쓰면, 그 안에서 Jekyll liquid 언어를 작성하더라도&lt;br /&gt;
실제로 렌더링 하는 대신 ‘그대로’ 보여주더군요.&lt;/p&gt;

&lt;p&gt;그런데, 너무 코드블록 느낌이 안 나는군요. 어떻게 하면 될까요?&lt;br /&gt;
이 때는 pre, code 문구를 추가로 위아래에 집어넣으면 됩니다. 아래 그림처럼요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 표시할 코드부분만 코드블록 안에 나오게 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{%- if page.comments -%}
    {%- include disqus_comments.html -%}
{%- endif -%}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 방법을 통해서 여러분께 liquid 언어 쓰는 방법을 더 자세하게 설명할 수 있게 되었습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;html의-경우&quot;&gt;html의 경우&lt;/h3&gt;
&lt;p&gt;html 을 코드블록에 표시하는 방법은 두가지입니다.&lt;br /&gt;
첫 번째는 물결 세 개를 쓰고 html이라고 쓰면 되는군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 이렇게 나옵니다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://hhj6212.github.io/&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   블로그 링크
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;혹은 highlight-endhighlight 기능을 사용할 수 있습니다.&lt;br /&gt;
highlight는 특정 언어를 지정하면, 그 언어에 맞는 형식대로 코드블록에서 보여줄 수 있게 해줍니다.&lt;br /&gt;
여기서 표시해야 할 언어는 html 이니, {% highlight html %} 이라고 작성해야 합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이것도 똑같은 효과를 가져옵니다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://hhj6212.github.io/&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   블로그 링크
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;markdown-언어의-경우&quot;&gt;markdown 언어의 경우&lt;/h3&gt;
&lt;p&gt;markdown 언어는 어떻게 할까요?&lt;br /&gt;
위에서 썼던 방법 중 pre, code 문구를 사용하면 됩니다.&lt;br /&gt;
이렇게 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 나타나게 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 하하하&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;세-언어를-동시에-사용할-때는요&quot;&gt;세 언어를 동시에 사용할 때는요?&lt;/h3&gt;
&lt;p&gt;만약 제가 liquid, html, markdown 세 가지 언어로 작성된 .md 파일을 여러분께 그대로 보여드리고 싶을 때는 어떻게 할까요?&lt;br /&gt;
물론 스크린샷을 찍어서 보여드릴 순 있겠죠.&lt;br /&gt;
그렇지만 여러분께서 따라서 연습하고 싶으실 땐 복사-붙여넣기를 하고 싶으실테니까, 좀 더 좋은 방법을 사용해봅시다.&lt;/p&gt;

&lt;p&gt;위에서 사용한 세 가지 방법을 잘 조합하면 됩니다!&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;liquid: raw-endraw 문구&lt;/li&gt;
  &lt;li&gt;html: highlight 문구&lt;/li&gt;
  &lt;li&gt;markdown: pre/code 문구&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;코드를 감쌀 때, 위 세 개의 물고 물리는 관계를 잘 고려해야 합니다.&lt;br /&gt;
예를 들어, pre/code 문구는 html이니, 이건 highlight로 묶기 전에 선언해야 합니다.&lt;br /&gt;
또, highlight 문구는 liquid 언어이므로, raw-endraw로 묶기 전에 선언해야 하죠.&lt;/p&gt;

&lt;p&gt;즉 다음과 같은 구조로 짜야 합니다.&lt;br /&gt;
가장 바깥에 pre-code, 그 다음에 highlight, 그리고 raw 로 묶으면 됩니다.&lt;br /&gt;
아래 그림처럼 말이죠.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200822/image6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그럼 아래처럼 liquid, html, markdown 세가지 언어가 모두 ‘그대로’ 여러분께 표시됩니다!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;{%- if page.comments -%}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post-disqus&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        ### 하하하
        {%- include disqus_comments.html -%}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{%- endif -%}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;지금까지 Jekyll 에서 liquid, html, markdown 을 코드블록으로 표시하는 방법을 배워보았습니다.&lt;br /&gt;
여러분의 블로그에서도 잘 활용하셨으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;그럼 다음 시간에 만나요!&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/2020/08/22/Jekyll-highlight-codeblock.html</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2020/08/22/Jekyll-highlight-codeblock.html</guid>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>깃블로그에 댓글창 달기</title>
        <description>&lt;h3 id=&quot;깃허브-블로그에-댓글창을-달아보자&quot;&gt;깃허브 블로그에 댓글창을 달아보자&lt;/h3&gt;
&lt;p&gt;안녕하세요. 한헌종입니다.&lt;/p&gt;

&lt;p&gt;이번엔 Jekyll 로 구축된 깃허브 블로그에 댓글창을 넣는 방법을 설명해 보겠습니다.&lt;br /&gt;
블로그에는 당연하게 댓글창이 달려있을 거라 생각하실 겁니다.&lt;br /&gt;
그러나 깃허브 블로그는 그렇지 않습니다…&lt;br /&gt;
오로지 글만 올리는 용도의 블로그로만 써야하나? 하는 생각이 들었습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image1.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;소통 없는 삭막한 블로그의 현장&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그래서 찾아봤습니다. 어딘가 당연히 방법이 있겠지.&lt;br /&gt;
구글링을 해보니 이미 많은 분들이 Jekyll 에 댓글창을 추가해 사용하고 계시더군요.&lt;br /&gt;
그 방법은 바로 Disqus 라는 사이트의 서비스를 이용하는 것이었습니다.&lt;br /&gt;
자, 일단 &lt;a href=&quot;https://disqus.com/&quot;&gt;https://disqus.com/&lt;/a&gt; 에 접속해서 계정을 만들어 봅시다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image2.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;계정을 만든 다음에는 이메일 인증을 꼭 해주세요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;계정을 만들고 Get started 를 클릭하면 다음과 같은 선택창이 뜹니다.&lt;br /&gt;
저는 제 사이트에 댓글을 만들고 싶으므로 아래의 “I want to install Disqus on my site” 를 클릭합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image3.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;선택지가 둘 뿐이군요. 아래꺼 선택!&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 후 Disqus를 사용하기 위한 설정들을 해야 합니다.&lt;br /&gt;
먼저 사이트를 나타낼 이름을 지어봅니다. (저는 간단하게 hhangitblog로 했습니다.)&lt;br /&gt;
Category 도 아무거나 선택해주시구요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image4.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;간단하고 기억하기 쉬운 걸로 지어봅시다&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그런 다음엔 서비스를 선택해야 합니다.&lt;br /&gt;
돈 내고 굉장히 좋은 서비스를 사용할 수도 있군요.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image5.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;돈 안내는 서비스는 없나 찾아보니, 아래쪽에 숨겨뒀네요.&lt;br /&gt;
Basic을 선택하시면 무료로 이용이 가능합니다.&lt;br /&gt;
물론 선택은 여러분에게 달려있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image6.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그 다음엔 어떤 플랫폼을 사용하고 있는지 고르게 되어있습니다.&lt;br /&gt;
이중 Jekyll을 선택해줍시다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image7.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;Jekyll 말고도 웹사이트 만드는 선택지가 굉장히 많군요&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 이러면 disqus 사이트에서 설정할 부분은 모두 끝났습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;다음 장면에서는 Jekyll 코드에서 어떤 부분을 만져야 댓글창이 나오는지 알려줍니다.&lt;br /&gt;
Post를 작성할 때 _post/ 디렉터리에 yyyy-mm-dd-name.md 문서를 작성하실 겁니다.&lt;br /&gt;
이 때, 각 .md 파일의 맨 윗부분에 변수로 “comments” 라는 것을 만들고, 이를 “true”로 설정해줘야 합니다.&lt;br /&gt;
그림에서처럼 말이죠.&lt;br /&gt;
여기서, layout: default 처럼 여러분이 포스트 글에서 사용하고 계신 _layout/[레이아웃이름].html 을 기억하고 계세요!&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image8.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이후, 위 그림의 아래 부분에 나와있는 파란 글씨의 “Universal Embed Code”라는 것을 클릭해봅시다.&lt;br /&gt;
그럼 다음과 같은 긴 코드가 나오는데요.&lt;br /&gt;
여러분의 Jekyll 디렉토리에 _includes/disqus_comments.html 이라는 파일을 만들고, 이 코드를 모두 복사해 붙여넣어 주세요.&lt;br /&gt;
코드 중간에 보시면 제가 위에서 지은 블로그이름 ‘hhangitblog’ 가 사용되고 있는 걸 확인하실 수 있어요.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image9.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image10.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;위 코드를 _includes/disqus_comments.html 에 붙여넣기 한 모습&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;거의 다 됐습니다!&lt;br /&gt;
이제 _layouts 만 바꾸면 됩니다.&lt;br /&gt;
저는 각 포스트의 레이아웃을 _layouts/post.html 을 참조하게 해놨는데요.&lt;br /&gt;
그럼 이 코드의 밑 부분에 아래 코드들을 추가하면 댓글창 사용이 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  {%- if page.comments -%}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;post-disqus&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    {%- include disqus_comments.html -%}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  {%- endif -%}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;/assets/200820/image11.png&quot; alt=&quot;-&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자, 끝났습니다!&lt;br /&gt;
이제 포스트를 확인하시면 댓글창이 들어와 있는 걸 보실 수 있습니다.&lt;br /&gt;
간단한 것 같으면서도 여러 과정을 거쳐야 하는군요.&lt;br /&gt;
그래도 블로그에 댓글창 정도는 있어야겠죠.&lt;br /&gt;
배워보길 잘했다는 생각이 듭니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/200820/image12.png&quot; alt=&quot;-&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;em&gt;드디어 댓글로 소통이 가능해졌군요. 편-안&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이제 여러분도 댓글창을 만드실 수 있습니다.&lt;br /&gt;
긴 글 읽어주셔서 감사합니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/tech/programming/2020/08/20/comments-section-gitblog.html</link>
        <guid isPermaLink="true">http://localhost:4000/blog/tech/programming/2020/08/20/comments-section-gitblog.html</guid>
        
        
        <category>blog</category>
        
        <category>tech</category>
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>깃블로그를 시작하며</title>
        <description>&lt;h3 id=&quot;블로그를-시작하며&quot;&gt;블로그를 시작하며&lt;/h3&gt;
&lt;p&gt;얼마전까지만 해도 블로그 하면 네이버 블로그밖에 생각이 안나고, 저랑은 전혀 관련없는 세상이라고 생각했습니다.&lt;br /&gt;
그런데 최근들어 주변에서 블로그를 시작해보라는 이야기를 많이 해주셨습니다.&lt;br /&gt;
추천해주신 분들 중에는 이미 몇년간, 혹은 십년 이상 블로그를 운영해오신 분들이 계셨습니다.&lt;br /&gt;
그분들을 보며 “와 저렇게 오래 많은 글을 기록하는 건 무척 힘들겠구나” 라며 압도되었습니다.&lt;br /&gt;
그때마다 제가 들었던 말은, 바로 가장 작은 것부터 시작해보라는 이야기였습니다.&lt;br /&gt;
처음부터 크게 할 생각을 하지 말고, 조금씩 꾸준히 해나가는게 중요하다는 것이었습니다.&lt;br /&gt;
그러다보면 어느새 수많은 글을 포스팅하게 되고, 그 분야의 전문가로 인정받을 수 있다는 말이었죠.&lt;/p&gt;

&lt;p&gt;그래서 한번, 시작해보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;어떤-내용을-써볼까&quot;&gt;어떤 내용을 써볼까&lt;/h3&gt;
&lt;p&gt;저는 글을 잘쓰는 스타일은 아닙니다.&lt;br /&gt;
그러나 기록하는 걸 좋아합니다.&lt;br /&gt;
기록의 용도는 주로 배웠던 걸 까먹지 않기 위해, 혹은 이전에 할줄 알았던 것들이 오랜만에 하려니 잘 생각이 안날때를 위한 것이었습니다.&lt;br /&gt;
간단한 파이썬 함수라도, 사용법을 알기쉽게 정리해 놓으면 나중에 유용한 경우가 많더군요.&lt;br /&gt;
마침 최근에 새로운 분야를 경험하고 배우고 있기 때문에 관련 지식을 조금씩 정리해나가면 좋을 것 같다는 생각을 했습니다.&lt;br /&gt;
물론, 일상적인 일들도 기록해두면 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;왜-깃블로그-인가&quot;&gt;왜 깃블로그 인가&lt;/h3&gt;
&lt;p&gt;깃허브로 블로그를 시작한 이유는, 일단 추천을 받았기 때문입니다.&lt;br /&gt;
깃허브 자체는 업무에는 많이 써왔지만 그 외에 써본 적은 없었습니다.&lt;br /&gt;
그런데 깃허브는 각 계정마다 하나씩 Git page라는 걸 쓸 수 있게 해주더군요. 무료로!&lt;br /&gt;
또, 몇몇 사람들의 깃허브 블로그를 보니 매우 깔끔했습니다.&lt;br /&gt;
마크다운 언어도 배워가던 중인데 이를 적절히 사용하면 깔끔하게 내용을 정리할 수 있겠다는 생각에 바로 시작하게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;시행착오&quot;&gt;시행착오&lt;/h3&gt;
&lt;p&gt;…물론 생각보다 쉽지 않더군요.&lt;br /&gt;
깃블로그를 무작정 시작하려니 정말 하나도 이해할 수 없었습니다.&lt;br /&gt;
깃허브, 루비, Jekyll, Markdown, HTML, CSS, Liquid 등 알아야 하는게 왜이렇게 많은지.&lt;br /&gt;
블로그들의 설명대로 따라해도 뭔가 이상하고 맘에 안들었습니다.&lt;br /&gt;
몇번의 시행착오 끝에, 깃블로그란 깃허브에서 제공하는 개인 페이지에 만드는 것이며 이는 루비 언어로 만들어진 Jekyll 이라는 엔진으로 구축하는 것을 알 수 있었습니다. (쓰면서도 맞나 싶습니다)&lt;br /&gt;
Jekyll 이라는게 뭔지부터 차근차근 공부했다면 시행착오가 덜했을텐데.&lt;br /&gt;
이렇게 겪은 시행착오도 하나씩 블로그에 정리해 나갈 예정입니다.&lt;br /&gt;
앞으로 배울 게 매우 많겠군요.&lt;/p&gt;

&lt;h3 id=&quot;앞으로&quot;&gt;앞으로&lt;/h3&gt;
&lt;p&gt;블로그는 처음이라 어떻게 가꿔나가야 할지 모르겠습니다.&lt;br /&gt;
그러나 누군가 이야기해준 것처럼, 정말 작은것부터 하나하나 해나가는게 중요한 것 같습니다.&lt;br /&gt;
오늘 이렇게 한 페이지를 작성했고, 앞으로 꾸준히 작성해보려 합니다.&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Aug 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/life/2020/08/19/beginning_gitblog.html</link>
        <guid isPermaLink="true">http://localhost:4000/life/2020/08/19/beginning_gitblog.html</guid>
        
        
        <category>life</category>
        
      </item>
    
  </channel>
</rss>